{"version":3,"file":"chartjs-lazy.min.js","sources":["../src/chartjs-lazy.js"],"sourcesContent":["/*!\r\n * Chart.js v3.8.0\r\n * https://www.chartjs.org\r\n * (c) 2022 Chart.js Contributors\r\n * Released under the MIT License\r\n */\r\n\r\n/**\r\n * Description of import into Moodle:\r\n *\r\n * - Download Chartjs source code (zip) file from https://github.com/chartjs/Chart.js/releases/latest.\r\n * - You must build Chart.js to generate the dist files (https://www.chartjs.org/docs/latest/developers/contributing.html#building-and-testing).\r\n * - Copy /dist/chart.js content to lib/amd/src/chartjs-lazy.js.\r\n * - Convert line endings to LF-Unix format.\r\n * - Keep these instructions to the file.\r\n * - Visit lib/tests/other/chartjstestpage.php to see if the library still works after the update.\r\n */\r\n\r\n(function (global, factory) {\r\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\ntypeof define === 'function' && define.amd ? define(factory) :\r\n(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());\r\n})(this, (function () { 'use strict';\r\n\r\nfunction fontString(pixelSize, fontStyle, fontFamily) {\r\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n}\r\nconst requestAnimFrame = (function() {\r\n  if (typeof window === 'undefined') {\r\n    return function(callback) {\r\n      return callback();\r\n    };\r\n  }\r\n  return window.requestAnimationFrame;\r\n}());\r\nfunction throttled(fn, thisArg, updateFn) {\r\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\r\n  let ticking = false;\r\n  let args = [];\r\n  return function(...rest) {\r\n    args = updateArgs(rest);\r\n    if (!ticking) {\r\n      ticking = true;\r\n      requestAnimFrame.call(window, () => {\r\n        ticking = false;\r\n        fn.apply(thisArg, args);\r\n      });\r\n    }\r\n  };\r\n}\r\nfunction debounce(fn, delay) {\r\n  let timeout;\r\n  return function(...args) {\r\n    if (delay) {\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(fn, delay, args);\r\n    } else {\r\n      fn.apply(this, args);\r\n    }\r\n    return delay;\r\n  };\r\n}\r\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\r\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\r\nconst _textX = (align, left, right, rtl) => {\r\n  const check = rtl ? 'left' : 'right';\r\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\r\n};\r\n\r\nclass Animator {\r\n  constructor() {\r\n    this._request = null;\r\n    this._charts = new Map();\r\n    this._running = false;\r\n    this._lastDate = undefined;\r\n  }\r\n  _notify(chart, anims, date, type) {\r\n    const callbacks = anims.listeners[type];\r\n    const numSteps = anims.duration;\r\n    callbacks.forEach(fn => fn({\r\n      chart,\r\n      initial: anims.initial,\r\n      numSteps,\r\n      currentStep: Math.min(date - anims.start, numSteps)\r\n    }));\r\n  }\r\n  _refresh() {\r\n    if (this._request) {\r\n      return;\r\n    }\r\n    this._running = true;\r\n    this._request = requestAnimFrame.call(window, () => {\r\n      this._update();\r\n      this._request = null;\r\n      if (this._running) {\r\n        this._refresh();\r\n      }\r\n    });\r\n  }\r\n  _update(date = Date.now()) {\r\n    let remaining = 0;\r\n    this._charts.forEach((anims, chart) => {\r\n      if (!anims.running || !anims.items.length) {\r\n        return;\r\n      }\r\n      const items = anims.items;\r\n      let i = items.length - 1;\r\n      let draw = false;\r\n      let item;\r\n      for (; i >= 0; --i) {\r\n        item = items[i];\r\n        if (item._active) {\r\n          if (item._total > anims.duration) {\r\n            anims.duration = item._total;\r\n          }\r\n          item.tick(date);\r\n          draw = true;\r\n        } else {\r\n          items[i] = items[items.length - 1];\r\n          items.pop();\r\n        }\r\n      }\r\n      if (draw) {\r\n        chart.draw();\r\n        this._notify(chart, anims, date, 'progress');\r\n      }\r\n      if (!items.length) {\r\n        anims.running = false;\r\n        this._notify(chart, anims, date, 'complete');\r\n        anims.initial = false;\r\n      }\r\n      remaining += items.length;\r\n    });\r\n    this._lastDate = date;\r\n    if (remaining === 0) {\r\n      this._running = false;\r\n    }\r\n  }\r\n  _getAnims(chart) {\r\n    const charts = this._charts;\r\n    let anims = charts.get(chart);\r\n    if (!anims) {\r\n      anims = {\r\n        running: false,\r\n        initial: true,\r\n        items: [],\r\n        listeners: {\r\n          complete: [],\r\n          progress: []\r\n        }\r\n      };\r\n      charts.set(chart, anims);\r\n    }\r\n    return anims;\r\n  }\r\n  listen(chart, event, cb) {\r\n    this._getAnims(chart).listeners[event].push(cb);\r\n  }\r\n  add(chart, items) {\r\n    if (!items || !items.length) {\r\n      return;\r\n    }\r\n    this._getAnims(chart).items.push(...items);\r\n  }\r\n  has(chart) {\r\n    return this._getAnims(chart).items.length > 0;\r\n  }\r\n  start(chart) {\r\n    const anims = this._charts.get(chart);\r\n    if (!anims) {\r\n      return;\r\n    }\r\n    anims.running = true;\r\n    anims.start = Date.now();\r\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\r\n    this._refresh();\r\n  }\r\n  running(chart) {\r\n    if (!this._running) {\r\n      return false;\r\n    }\r\n    const anims = this._charts.get(chart);\r\n    if (!anims || !anims.running || !anims.items.length) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  stop(chart) {\r\n    const anims = this._charts.get(chart);\r\n    if (!anims || !anims.items.length) {\r\n      return;\r\n    }\r\n    const items = anims.items;\r\n    let i = items.length - 1;\r\n    for (; i >= 0; --i) {\r\n      items[i].cancel();\r\n    }\r\n    anims.items = [];\r\n    this._notify(chart, anims, Date.now(), 'complete');\r\n  }\r\n  remove(chart) {\r\n    return this._charts.delete(chart);\r\n  }\r\n}\r\nvar animator = new Animator();\r\n\r\n/*!\r\n * @kurkle/color v0.2.1\r\n * https://github.com/kurkle/color#readme\r\n * (c) 2022 Jukka Kurkela\r\n * Released under the MIT License\r\n */\r\nfunction round(v) {\r\n  return v + 0.5 | 0;\r\n}\r\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\r\nfunction p2b(v) {\r\n  return lim(round(v * 2.55), 0, 255);\r\n}\r\nfunction n2b(v) {\r\n  return lim(round(v * 255), 0, 255);\r\n}\r\nfunction b2n(v) {\r\n  return lim(round(v / 2.55) / 100, 0, 1);\r\n}\r\nfunction n2p(v) {\r\n  return lim(round(v * 100), 0, 100);\r\n}\r\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\r\nconst hex = [...'0123456789ABCDEF'];\r\nconst h1 = b => hex[b & 0xF];\r\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\r\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\r\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\r\nfunction hexParse(str) {\r\n  var len = str.length;\r\n  var ret;\r\n  if (str[0] === '#') {\r\n    if (len === 4 || len === 5) {\r\n      ret = {\r\n        r: 255 & map$1[str[1]] * 17,\r\n        g: 255 & map$1[str[2]] * 17,\r\n        b: 255 & map$1[str[3]] * 17,\r\n        a: len === 5 ? map$1[str[4]] * 17 : 255\r\n      };\r\n    } else if (len === 7 || len === 9) {\r\n      ret = {\r\n        r: map$1[str[1]] << 4 | map$1[str[2]],\r\n        g: map$1[str[3]] << 4 | map$1[str[4]],\r\n        b: map$1[str[5]] << 4 | map$1[str[6]],\r\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\r\n      };\r\n    }\r\n  }\r\n  return ret;\r\n}\r\nconst alpha = (a, f) => a < 255 ? f(a) : '';\r\nfunction hexString(v) {\r\n  var f = isShort(v) ? h1 : h2;\r\n  return v\r\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\r\n    : undefined;\r\n}\r\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\nfunction hsl2rgbn(h, s, l) {\r\n  const a = s * Math.min(l, 1 - l);\r\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\r\n  return [f(0), f(8), f(4)];\r\n}\r\nfunction hsv2rgbn(h, s, v) {\r\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\r\n  return [f(5), f(3), f(1)];\r\n}\r\nfunction hwb2rgbn(h, w, b) {\r\n  const rgb = hsl2rgbn(h, 1, 0.5);\r\n  let i;\r\n  if (w + b > 1) {\r\n    i = 1 / (w + b);\r\n    w *= i;\r\n    b *= i;\r\n  }\r\n  for (i = 0; i < 3; i++) {\r\n    rgb[i] *= 1 - w - b;\r\n    rgb[i] += w;\r\n  }\r\n  return rgb;\r\n}\r\nfunction hueValue(r, g, b, d, max) {\r\n  if (r === max) {\r\n    return ((g - b) / d) + (g < b ? 6 : 0);\r\n  }\r\n  if (g === max) {\r\n    return (b - r) / d + 2;\r\n  }\r\n  return (r - g) / d + 4;\r\n}\r\nfunction rgb2hsl(v) {\r\n  const range = 255;\r\n  const r = v.r / range;\r\n  const g = v.g / range;\r\n  const b = v.b / range;\r\n  const max = Math.max(r, g, b);\r\n  const min = Math.min(r, g, b);\r\n  const l = (max + min) / 2;\r\n  let h, s, d;\r\n  if (max !== min) {\r\n    d = max - min;\r\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n    h = hueValue(r, g, b, d, max);\r\n    h = h * 60 + 0.5;\r\n  }\r\n  return [h | 0, s || 0, l];\r\n}\r\nfunction calln(f, a, b, c) {\r\n  return (\r\n    Array.isArray(a)\r\n      ? f(a[0], a[1], a[2])\r\n      : f(a, b, c)\r\n  ).map(n2b);\r\n}\r\nfunction hsl2rgb(h, s, l) {\r\n  return calln(hsl2rgbn, h, s, l);\r\n}\r\nfunction hwb2rgb(h, w, b) {\r\n  return calln(hwb2rgbn, h, w, b);\r\n}\r\nfunction hsv2rgb(h, s, v) {\r\n  return calln(hsv2rgbn, h, s, v);\r\n}\r\nfunction hue(h) {\r\n  return (h % 360 + 360) % 360;\r\n}\r\nfunction hueParse(str) {\r\n  const m = HUE_RE.exec(str);\r\n  let a = 255;\r\n  let v;\r\n  if (!m) {\r\n    return;\r\n  }\r\n  if (m[5] !== v) {\r\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\r\n  }\r\n  const h = hue(+m[2]);\r\n  const p1 = +m[3] / 100;\r\n  const p2 = +m[4] / 100;\r\n  if (m[1] === 'hwb') {\r\n    v = hwb2rgb(h, p1, p2);\r\n  } else if (m[1] === 'hsv') {\r\n    v = hsv2rgb(h, p1, p2);\r\n  } else {\r\n    v = hsl2rgb(h, p1, p2);\r\n  }\r\n  return {\r\n    r: v[0],\r\n    g: v[1],\r\n    b: v[2],\r\n    a: a\r\n  };\r\n}\r\nfunction rotate(v, deg) {\r\n  var h = rgb2hsl(v);\r\n  h[0] = hue(h[0] + deg);\r\n  h = hsl2rgb(h);\r\n  v.r = h[0];\r\n  v.g = h[1];\r\n  v.b = h[2];\r\n}\r\nfunction hslString(v) {\r\n  if (!v) {\r\n    return;\r\n  }\r\n  const a = rgb2hsl(v);\r\n  const h = a[0];\r\n  const s = n2p(a[1]);\r\n  const l = n2p(a[2]);\r\n  return v.a < 255\r\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\r\n    : `hsl(${h}, ${s}%, ${l}%)`;\r\n}\r\nconst map$2 = {\r\n  x: 'dark',\r\n  Z: 'light',\r\n  Y: 're',\r\n  X: 'blu',\r\n  W: 'gr',\r\n  V: 'medium',\r\n  U: 'slate',\r\n  A: 'ee',\r\n  T: 'ol',\r\n  S: 'or',\r\n  B: 'ra',\r\n  C: 'lateg',\r\n  D: 'ights',\r\n  R: 'in',\r\n  Q: 'turquois',\r\n  E: 'hi',\r\n  P: 'ro',\r\n  O: 'al',\r\n  N: 'le',\r\n  M: 'de',\r\n  L: 'yello',\r\n  F: 'en',\r\n  K: 'ch',\r\n  G: 'arks',\r\n  H: 'ea',\r\n  I: 'ightg',\r\n  J: 'wh'\r\n};\r\nconst names$1 = {\r\n  OiceXe: 'f0f8ff',\r\n  antiquewEte: 'faebd7',\r\n  aqua: 'ffff',\r\n  aquamarRe: '7fffd4',\r\n  azuY: 'f0ffff',\r\n  beige: 'f5f5dc',\r\n  bisque: 'ffe4c4',\r\n  black: '0',\r\n  blanKedOmond: 'ffebcd',\r\n  Xe: 'ff',\r\n  XeviTet: '8a2be2',\r\n  bPwn: 'a52a2a',\r\n  burlywood: 'deb887',\r\n  caMtXe: '5f9ea0',\r\n  KartYuse: '7fff00',\r\n  KocTate: 'd2691e',\r\n  cSO: 'ff7f50',\r\n  cSnflowerXe: '6495ed',\r\n  cSnsilk: 'fff8dc',\r\n  crimson: 'dc143c',\r\n  cyan: 'ffff',\r\n  xXe: '8b',\r\n  xcyan: '8b8b',\r\n  xgTMnPd: 'b8860b',\r\n  xWay: 'a9a9a9',\r\n  xgYF: '6400',\r\n  xgYy: 'a9a9a9',\r\n  xkhaki: 'bdb76b',\r\n  xmagFta: '8b008b',\r\n  xTivegYF: '556b2f',\r\n  xSange: 'ff8c00',\r\n  xScEd: '9932cc',\r\n  xYd: '8b0000',\r\n  xsOmon: 'e9967a',\r\n  xsHgYF: '8fbc8f',\r\n  xUXe: '483d8b',\r\n  xUWay: '2f4f4f',\r\n  xUgYy: '2f4f4f',\r\n  xQe: 'ced1',\r\n  xviTet: '9400d3',\r\n  dAppRk: 'ff1493',\r\n  dApskyXe: 'bfff',\r\n  dimWay: '696969',\r\n  dimgYy: '696969',\r\n  dodgerXe: '1e90ff',\r\n  fiYbrick: 'b22222',\r\n  flSOwEte: 'fffaf0',\r\n  foYstWAn: '228b22',\r\n  fuKsia: 'ff00ff',\r\n  gaRsbSo: 'dcdcdc',\r\n  ghostwEte: 'f8f8ff',\r\n  gTd: 'ffd700',\r\n  gTMnPd: 'daa520',\r\n  Way: '808080',\r\n  gYF: '8000',\r\n  gYFLw: 'adff2f',\r\n  gYy: '808080',\r\n  honeyMw: 'f0fff0',\r\n  hotpRk: 'ff69b4',\r\n  RdianYd: 'cd5c5c',\r\n  Rdigo: '4b0082',\r\n  ivSy: 'fffff0',\r\n  khaki: 'f0e68c',\r\n  lavFMr: 'e6e6fa',\r\n  lavFMrXsh: 'fff0f5',\r\n  lawngYF: '7cfc00',\r\n  NmoncEffon: 'fffacd',\r\n  ZXe: 'add8e6',\r\n  ZcSO: 'f08080',\r\n  Zcyan: 'e0ffff',\r\n  ZgTMnPdLw: 'fafad2',\r\n  ZWay: 'd3d3d3',\r\n  ZgYF: '90ee90',\r\n  ZgYy: 'd3d3d3',\r\n  ZpRk: 'ffb6c1',\r\n  ZsOmon: 'ffa07a',\r\n  ZsHgYF: '20b2aa',\r\n  ZskyXe: '87cefa',\r\n  ZUWay: '778899',\r\n  ZUgYy: '778899',\r\n  ZstAlXe: 'b0c4de',\r\n  ZLw: 'ffffe0',\r\n  lime: 'ff00',\r\n  limegYF: '32cd32',\r\n  lRF: 'faf0e6',\r\n  magFta: 'ff00ff',\r\n  maPon: '800000',\r\n  VaquamarRe: '66cdaa',\r\n  VXe: 'cd',\r\n  VScEd: 'ba55d3',\r\n  VpurpN: '9370db',\r\n  VsHgYF: '3cb371',\r\n  VUXe: '7b68ee',\r\n  VsprRggYF: 'fa9a',\r\n  VQe: '48d1cc',\r\n  VviTetYd: 'c71585',\r\n  midnightXe: '191970',\r\n  mRtcYam: 'f5fffa',\r\n  mistyPse: 'ffe4e1',\r\n  moccasR: 'ffe4b5',\r\n  navajowEte: 'ffdead',\r\n  navy: '80',\r\n  Tdlace: 'fdf5e6',\r\n  Tive: '808000',\r\n  TivedBb: '6b8e23',\r\n  Sange: 'ffa500',\r\n  SangeYd: 'ff4500',\r\n  ScEd: 'da70d6',\r\n  pOegTMnPd: 'eee8aa',\r\n  pOegYF: '98fb98',\r\n  pOeQe: 'afeeee',\r\n  pOeviTetYd: 'db7093',\r\n  papayawEp: 'ffefd5',\r\n  pHKpuff: 'ffdab9',\r\n  peru: 'cd853f',\r\n  pRk: 'ffc0cb',\r\n  plum: 'dda0dd',\r\n  powMrXe: 'b0e0e6',\r\n  purpN: '800080',\r\n  YbeccapurpN: '663399',\r\n  Yd: 'ff0000',\r\n  Psybrown: 'bc8f8f',\r\n  PyOXe: '4169e1',\r\n  saddNbPwn: '8b4513',\r\n  sOmon: 'fa8072',\r\n  sandybPwn: 'f4a460',\r\n  sHgYF: '2e8b57',\r\n  sHshell: 'fff5ee',\r\n  siFna: 'a0522d',\r\n  silver: 'c0c0c0',\r\n  skyXe: '87ceeb',\r\n  UXe: '6a5acd',\r\n  UWay: '708090',\r\n  UgYy: '708090',\r\n  snow: 'fffafa',\r\n  sprRggYF: 'ff7f',\r\n  stAlXe: '4682b4',\r\n  tan: 'd2b48c',\r\n  teO: '8080',\r\n  tEstN: 'd8bfd8',\r\n  tomato: 'ff6347',\r\n  Qe: '40e0d0',\r\n  viTet: 'ee82ee',\r\n  JHt: 'f5deb3',\r\n  wEte: 'ffffff',\r\n  wEtesmoke: 'f5f5f5',\r\n  Lw: 'ffff00',\r\n  LwgYF: '9acd32'\r\n};\r\nfunction unpack() {\r\n  const unpacked = {};\r\n  const keys = Object.keys(names$1);\r\n  const tkeys = Object.keys(map$2);\r\n  let i, j, k, ok, nk;\r\n  for (i = 0; i < keys.length; i++) {\r\n    ok = nk = keys[i];\r\n    for (j = 0; j < tkeys.length; j++) {\r\n      k = tkeys[j];\r\n      nk = nk.replace(k, map$2[k]);\r\n    }\r\n    k = parseInt(names$1[ok], 16);\r\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\r\n  }\r\n  return unpacked;\r\n}\r\nlet names;\r\nfunction nameParse(str) {\r\n  if (!names) {\r\n    names = unpack();\r\n    names.transparent = [0, 0, 0, 0];\r\n  }\r\n  const a = names[str.toLowerCase()];\r\n  return a && {\r\n    r: a[0],\r\n    g: a[1],\r\n    b: a[2],\r\n    a: a.length === 4 ? a[3] : 255\r\n  };\r\n}\r\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\r\nfunction rgbParse(str) {\r\n  const m = RGB_RE.exec(str);\r\n  let a = 255;\r\n  let r, g, b;\r\n  if (!m) {\r\n    return;\r\n  }\r\n  if (m[7] !== r) {\r\n    const v = +m[7];\r\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\r\n  }\r\n  r = +m[1];\r\n  g = +m[3];\r\n  b = +m[5];\r\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\r\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\r\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\r\n  return {\r\n    r: r,\r\n    g: g,\r\n    b: b,\r\n    a: a\r\n  };\r\n}\r\nfunction rgbString(v) {\r\n  return v && (\r\n    v.a < 255\r\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\r\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\r\n  );\r\n}\r\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\r\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\r\nfunction interpolate$1(rgb1, rgb2, t) {\r\n  const r = from(b2n(rgb1.r));\r\n  const g = from(b2n(rgb1.g));\r\n  const b = from(b2n(rgb1.b));\r\n  return {\r\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\r\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\r\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\r\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\r\n  };\r\n}\r\nfunction modHSL(v, i, ratio) {\r\n  if (v) {\r\n    let tmp = rgb2hsl(v);\r\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\r\n    tmp = hsl2rgb(tmp);\r\n    v.r = tmp[0];\r\n    v.g = tmp[1];\r\n    v.b = tmp[2];\r\n  }\r\n}\r\nfunction clone$1(v, proto) {\r\n  return v ? Object.assign(proto || {}, v) : v;\r\n}\r\nfunction fromObject(input) {\r\n  var v = {r: 0, g: 0, b: 0, a: 255};\r\n  if (Array.isArray(input)) {\r\n    if (input.length >= 3) {\r\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\r\n      if (input.length > 3) {\r\n        v.a = n2b(input[3]);\r\n      }\r\n    }\r\n  } else {\r\n    v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});\r\n    v.a = n2b(v.a);\r\n  }\r\n  return v;\r\n}\r\nfunction functionParse(str) {\r\n  if (str.charAt(0) === 'r') {\r\n    return rgbParse(str);\r\n  }\r\n  return hueParse(str);\r\n}\r\nclass Color {\r\n  constructor(input) {\r\n    if (input instanceof Color) {\r\n      return input;\r\n    }\r\n    const type = typeof input;\r\n    let v;\r\n    if (type === 'object') {\r\n      v = fromObject(input);\r\n    } else if (type === 'string') {\r\n      v = hexParse(input) || nameParse(input) || functionParse(input);\r\n    }\r\n    this._rgb = v;\r\n    this._valid = !!v;\r\n  }\r\n  get valid() {\r\n    return this._valid;\r\n  }\r\n  get rgb() {\r\n    var v = clone$1(this._rgb);\r\n    if (v) {\r\n      v.a = b2n(v.a);\r\n    }\r\n    return v;\r\n  }\r\n  set rgb(obj) {\r\n    this._rgb = fromObject(obj);\r\n  }\r\n  rgbString() {\r\n    return this._valid ? rgbString(this._rgb) : undefined;\r\n  }\r\n  hexString() {\r\n    return this._valid ? hexString(this._rgb) : undefined;\r\n  }\r\n  hslString() {\r\n    return this._valid ? hslString(this._rgb) : undefined;\r\n  }\r\n  mix(color, weight) {\r\n    if (color) {\r\n      const c1 = this.rgb;\r\n      const c2 = color.rgb;\r\n      let w2;\r\n      const p = weight === w2 ? 0.5 : weight;\r\n      const w = 2 * p - 1;\r\n      const a = c1.a - c2.a;\r\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n      w2 = 1 - w1;\r\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\r\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\r\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\r\n      c1.a = p * c1.a + (1 - p) * c2.a;\r\n      this.rgb = c1;\r\n    }\r\n    return this;\r\n  }\r\n  interpolate(color, t) {\r\n    if (color) {\r\n      this._rgb = interpolate$1(this._rgb, color._rgb, t);\r\n    }\r\n    return this;\r\n  }\r\n  clone() {\r\n    return new Color(this.rgb);\r\n  }\r\n  alpha(a) {\r\n    this._rgb.a = n2b(a);\r\n    return this;\r\n  }\r\n  clearer(ratio) {\r\n    const rgb = this._rgb;\r\n    rgb.a *= 1 - ratio;\r\n    return this;\r\n  }\r\n  greyscale() {\r\n    const rgb = this._rgb;\r\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\r\n    rgb.r = rgb.g = rgb.b = val;\r\n    return this;\r\n  }\r\n  opaquer(ratio) {\r\n    const rgb = this._rgb;\r\n    rgb.a *= 1 + ratio;\r\n    return this;\r\n  }\r\n  negate() {\r\n    const v = this._rgb;\r\n    v.r = 255 - v.r;\r\n    v.g = 255 - v.g;\r\n    v.b = 255 - v.b;\r\n    return this;\r\n  }\r\n  lighten(ratio) {\r\n    modHSL(this._rgb, 2, ratio);\r\n    return this;\r\n  }\r\n  darken(ratio) {\r\n    modHSL(this._rgb, 2, -ratio);\r\n    return this;\r\n  }\r\n  saturate(ratio) {\r\n    modHSL(this._rgb, 1, ratio);\r\n    return this;\r\n  }\r\n  desaturate(ratio) {\r\n    modHSL(this._rgb, 1, -ratio);\r\n    return this;\r\n  }\r\n  rotate(deg) {\r\n    rotate(this._rgb, deg);\r\n    return this;\r\n  }\r\n}\r\nfunction index_esm(input) {\r\n  return new Color(input);\r\n}\r\n\r\nfunction isPatternOrGradient(value) {\r\n  if (value && typeof value === 'object') {\r\n    const type = value.toString();\r\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\r\n  }\r\n  return false;\r\n}\r\nfunction color(value) {\r\n  return isPatternOrGradient(value) ? value : index_esm(value);\r\n}\r\nfunction getHoverColor(value) {\r\n  return isPatternOrGradient(value)\r\n    ? value\r\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\r\n}\r\n\r\nfunction noop() {}\r\nconst uid = (function() {\r\n  let id = 0;\r\n  return function() {\r\n    return id++;\r\n  };\r\n}());\r\nfunction isNullOrUndef(value) {\r\n  return value === null || typeof value === 'undefined';\r\n}\r\nfunction isArray(value) {\r\n  if (Array.isArray && Array.isArray(value)) {\r\n    return true;\r\n  }\r\n  const type = Object.prototype.toString.call(value);\r\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nfunction isObject(value) {\r\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\r\n}\r\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\r\nfunction finiteOrDefault(value, defaultValue) {\r\n  return isNumberFinite(value) ? value : defaultValue;\r\n}\r\nfunction valueOrDefault(value, defaultValue) {\r\n  return typeof value === 'undefined' ? defaultValue : value;\r\n}\r\nconst toPercentage = (value, dimension) =>\r\n  typeof value === 'string' && value.endsWith('%') ?\r\n    parseFloat(value) / 100\r\n    : value / dimension;\r\nconst toDimension = (value, dimension) =>\r\n  typeof value === 'string' && value.endsWith('%') ?\r\n    parseFloat(value) / 100 * dimension\r\n    : +value;\r\nfunction callback(fn, args, thisArg) {\r\n  if (fn && typeof fn.call === 'function') {\r\n    return fn.apply(thisArg, args);\r\n  }\r\n}\r\nfunction each(loopable, fn, thisArg, reverse) {\r\n  let i, len, keys;\r\n  if (isArray(loopable)) {\r\n    len = loopable.length;\r\n    if (reverse) {\r\n      for (i = len - 1; i >= 0; i--) {\r\n        fn.call(thisArg, loopable[i], i);\r\n      }\r\n    } else {\r\n      for (i = 0; i < len; i++) {\r\n        fn.call(thisArg, loopable[i], i);\r\n      }\r\n    }\r\n  } else if (isObject(loopable)) {\r\n    keys = Object.keys(loopable);\r\n    len = keys.length;\r\n    for (i = 0; i < len; i++) {\r\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\r\n    }\r\n  }\r\n}\r\nfunction _elementsEqual(a0, a1) {\r\n  let i, ilen, v0, v1;\r\n  if (!a0 || !a1 || a0.length !== a1.length) {\r\n    return false;\r\n  }\r\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n    v0 = a0[i];\r\n    v1 = a1[i];\r\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\nfunction clone(source) {\r\n  if (isArray(source)) {\r\n    return source.map(clone);\r\n  }\r\n  if (isObject(source)) {\r\n    const target = Object.create(null);\r\n    const keys = Object.keys(source);\r\n    const klen = keys.length;\r\n    let k = 0;\r\n    for (; k < klen; ++k) {\r\n      target[keys[k]] = clone(source[keys[k]]);\r\n    }\r\n    return target;\r\n  }\r\n  return source;\r\n}\r\nfunction isValidKey(key) {\r\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\r\n}\r\nfunction _merger(key, target, source, options) {\r\n  if (!isValidKey(key)) {\r\n    return;\r\n  }\r\n  const tval = target[key];\r\n  const sval = source[key];\r\n  if (isObject(tval) && isObject(sval)) {\r\n    merge(tval, sval, options);\r\n  } else {\r\n    target[key] = clone(sval);\r\n  }\r\n}\r\nfunction merge(target, source, options) {\r\n  const sources = isArray(source) ? source : [source];\r\n  const ilen = sources.length;\r\n  if (!isObject(target)) {\r\n    return target;\r\n  }\r\n  options = options || {};\r\n  const merger = options.merger || _merger;\r\n  for (let i = 0; i < ilen; ++i) {\r\n    source = sources[i];\r\n    if (!isObject(source)) {\r\n      continue;\r\n    }\r\n    const keys = Object.keys(source);\r\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\r\n      merger(keys[k], target, source, options);\r\n    }\r\n  }\r\n  return target;\r\n}\r\nfunction mergeIf(target, source) {\r\n  return merge(target, source, {merger: _mergerIf});\r\n}\r\nfunction _mergerIf(key, target, source) {\r\n  if (!isValidKey(key)) {\r\n    return;\r\n  }\r\n  const tval = target[key];\r\n  const sval = source[key];\r\n  if (isObject(tval) && isObject(sval)) {\r\n    mergeIf(tval, sval);\r\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\r\n    target[key] = clone(sval);\r\n  }\r\n}\r\nfunction _deprecated(scope, value, previous, current) {\r\n  if (value !== undefined) {\r\n    console.warn(scope + ': \"' + previous +\r\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\r\n  }\r\n}\r\nconst emptyString = '';\r\nconst dot = '.';\r\nfunction indexOfDotOrLength(key, start) {\r\n  const idx = key.indexOf(dot, start);\r\n  return idx === -1 ? key.length : idx;\r\n}\r\nfunction resolveObjectKey(obj, key) {\r\n  if (key === emptyString) {\r\n    return obj;\r\n  }\r\n  let pos = 0;\r\n  let idx = indexOfDotOrLength(key, pos);\r\n  while (obj && idx > pos) {\r\n    obj = obj[key.slice(pos, idx)];\r\n    pos = idx + 1;\r\n    idx = indexOfDotOrLength(key, pos);\r\n  }\r\n  return obj;\r\n}\r\nfunction _capitalize(str) {\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\nconst defined = (value) => typeof value !== 'undefined';\r\nconst isFunction = (value) => typeof value === 'function';\r\nconst setsEqual = (a, b) => {\r\n  if (a.size !== b.size) {\r\n    return false;\r\n  }\r\n  for (const item of a) {\r\n    if (!b.has(item)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\nfunction _isClickEvent(e) {\r\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\r\n}\r\n\r\nconst overrides = Object.create(null);\r\nconst descriptors = Object.create(null);\r\nfunction getScope$1(node, key) {\r\n  if (!key) {\r\n    return node;\r\n  }\r\n  const keys = key.split('.');\r\n  for (let i = 0, n = keys.length; i < n; ++i) {\r\n    const k = keys[i];\r\n    node = node[k] || (node[k] = Object.create(null));\r\n  }\r\n  return node;\r\n}\r\nfunction set(root, scope, values) {\r\n  if (typeof scope === 'string') {\r\n    return merge(getScope$1(root, scope), values);\r\n  }\r\n  return merge(getScope$1(root, ''), scope);\r\n}\r\nclass Defaults {\r\n  constructor(_descriptors) {\r\n    this.animation = undefined;\r\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\r\n    this.borderColor = 'rgba(0,0,0,0.1)';\r\n    this.color = '#666';\r\n    this.datasets = {};\r\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\r\n    this.elements = {};\r\n    this.events = [\r\n      'mousemove',\r\n      'mouseout',\r\n      'click',\r\n      'touchstart',\r\n      'touchmove'\r\n    ];\r\n    this.font = {\r\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n      size: 12,\r\n      style: 'normal',\r\n      lineHeight: 1.2,\r\n      weight: null\r\n    };\r\n    this.hover = {};\r\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\r\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\r\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\r\n    this.indexAxis = 'x';\r\n    this.interaction = {\r\n      mode: 'nearest',\r\n      intersect: true,\r\n      includeInvisible: false\r\n    };\r\n    this.maintainAspectRatio = true;\r\n    this.onHover = null;\r\n    this.onClick = null;\r\n    this.parsing = true;\r\n    this.plugins = {};\r\n    this.responsive = true;\r\n    this.scale = undefined;\r\n    this.scales = {};\r\n    this.showLine = true;\r\n    this.drawActiveElementsOnTop = true;\r\n    this.describe(_descriptors);\r\n  }\r\n  set(scope, values) {\r\n    return set(this, scope, values);\r\n  }\r\n  get(scope) {\r\n    return getScope$1(this, scope);\r\n  }\r\n  describe(scope, values) {\r\n    return set(descriptors, scope, values);\r\n  }\r\n  override(scope, values) {\r\n    return set(overrides, scope, values);\r\n  }\r\n  route(scope, name, targetScope, targetName) {\r\n    const scopeObject = getScope$1(this, scope);\r\n    const targetScopeObject = getScope$1(this, targetScope);\r\n    const privateName = '_' + name;\r\n    Object.defineProperties(scopeObject, {\r\n      [privateName]: {\r\n        value: scopeObject[name],\r\n        writable: true\r\n      },\r\n      [name]: {\r\n        enumerable: true,\r\n        get() {\r\n          const local = this[privateName];\r\n          const target = targetScopeObject[targetName];\r\n          if (isObject(local)) {\r\n            return Object.assign({}, target, local);\r\n          }\r\n          return valueOrDefault(local, target);\r\n        },\r\n        set(value) {\r\n          this[privateName] = value;\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\nvar defaults = new Defaults({\r\n  _scriptable: (name) => !name.startsWith('on'),\r\n  _indexable: (name) => name !== 'events',\r\n  hover: {\r\n    _fallback: 'interaction'\r\n  },\r\n  interaction: {\r\n    _scriptable: false,\r\n    _indexable: false,\r\n  }\r\n});\r\n\r\nfunction _lookup(table, value, cmp) {\r\n  cmp = cmp || ((index) => table[index] < value);\r\n  let hi = table.length - 1;\r\n  let lo = 0;\r\n  let mid;\r\n  while (hi - lo > 1) {\r\n    mid = (lo + hi) >> 1;\r\n    if (cmp(mid)) {\r\n      lo = mid;\r\n    } else {\r\n      hi = mid;\r\n    }\r\n  }\r\n  return {lo, hi};\r\n}\r\nconst _lookupByKey = (table, key, value) =>\r\n  _lookup(table, value, index => table[index][key] < value);\r\nconst _rlookupByKey = (table, key, value) =>\r\n  _lookup(table, value, index => table[index][key] >= value);\r\nfunction _filterBetween(values, min, max) {\r\n  let start = 0;\r\n  let end = values.length;\r\n  while (start < end && values[start] < min) {\r\n    start++;\r\n  }\r\n  while (end > start && values[end - 1] > max) {\r\n    end--;\r\n  }\r\n  return start > 0 || end < values.length\r\n    ? values.slice(start, end)\r\n    : values;\r\n}\r\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\r\nfunction listenArrayEvents(array, listener) {\r\n  if (array._chartjs) {\r\n    array._chartjs.listeners.push(listener);\r\n    return;\r\n  }\r\n  Object.defineProperty(array, '_chartjs', {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value: {\r\n      listeners: [listener]\r\n    }\r\n  });\r\n  arrayEvents.forEach((key) => {\r\n    const method = '_onData' + _capitalize(key);\r\n    const base = array[key];\r\n    Object.defineProperty(array, key, {\r\n      configurable: true,\r\n      enumerable: false,\r\n      value(...args) {\r\n        const res = base.apply(this, args);\r\n        array._chartjs.listeners.forEach((object) => {\r\n          if (typeof object[method] === 'function') {\r\n            object[method](...args);\r\n          }\r\n        });\r\n        return res;\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction unlistenArrayEvents(array, listener) {\r\n  const stub = array._chartjs;\r\n  if (!stub) {\r\n    return;\r\n  }\r\n  const listeners = stub.listeners;\r\n  const index = listeners.indexOf(listener);\r\n  if (index !== -1) {\r\n    listeners.splice(index, 1);\r\n  }\r\n  if (listeners.length > 0) {\r\n    return;\r\n  }\r\n  arrayEvents.forEach((key) => {\r\n    delete array[key];\r\n  });\r\n  delete array._chartjs;\r\n}\r\nfunction _arrayUnique(items) {\r\n  const set = new Set();\r\n  let i, ilen;\r\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n    set.add(items[i]);\r\n  }\r\n  if (set.size === ilen) {\r\n    return items;\r\n  }\r\n  return Array.from(set);\r\n}\r\n\r\nconst PI = Math.PI;\r\nconst TAU = 2 * PI;\r\nconst PITAU = TAU + PI;\r\nconst INFINITY = Number.POSITIVE_INFINITY;\r\nconst RAD_PER_DEG = PI / 180;\r\nconst HALF_PI = PI / 2;\r\nconst QUARTER_PI = PI / 4;\r\nconst TWO_THIRDS_PI = PI * 2 / 3;\r\nconst log10 = Math.log10;\r\nconst sign = Math.sign;\r\nfunction niceNum(range) {\r\n  const roundedRange = Math.round(range);\r\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\r\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\r\n  const fraction = range / niceRange;\r\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\r\n  return niceFraction * niceRange;\r\n}\r\nfunction _factorize(value) {\r\n  const result = [];\r\n  const sqrt = Math.sqrt(value);\r\n  let i;\r\n  for (i = 1; i < sqrt; i++) {\r\n    if (value % i === 0) {\r\n      result.push(i);\r\n      result.push(value / i);\r\n    }\r\n  }\r\n  if (sqrt === (sqrt | 0)) {\r\n    result.push(sqrt);\r\n  }\r\n  result.sort((a, b) => a - b).pop();\r\n  return result;\r\n}\r\nfunction isNumber(n) {\r\n  return !isNaN(parseFloat(n)) && isFinite(n);\r\n}\r\nfunction almostEquals(x, y, epsilon) {\r\n  return Math.abs(x - y) < epsilon;\r\n}\r\nfunction almostWhole(x, epsilon) {\r\n  const rounded = Math.round(x);\r\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\r\n}\r\nfunction _setMinAndMaxByKey(array, target, property) {\r\n  let i, ilen, value;\r\n  for (i = 0, ilen = array.length; i < ilen; i++) {\r\n    value = array[i][property];\r\n    if (!isNaN(value)) {\r\n      target.min = Math.min(target.min, value);\r\n      target.max = Math.max(target.max, value);\r\n    }\r\n  }\r\n}\r\nfunction toRadians(degrees) {\r\n  return degrees * (PI / 180);\r\n}\r\nfunction toDegrees(radians) {\r\n  return radians * (180 / PI);\r\n}\r\nfunction _decimalPlaces(x) {\r\n  if (!isNumberFinite(x)) {\r\n    return;\r\n  }\r\n  let e = 1;\r\n  let p = 0;\r\n  while (Math.round(x * e) / e !== x) {\r\n    e *= 10;\r\n    p++;\r\n  }\r\n  return p;\r\n}\r\nfunction getAngleFromPoint(centrePoint, anglePoint) {\r\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\r\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\r\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n  if (angle < (-0.5 * PI)) {\r\n    angle += TAU;\r\n  }\r\n  return {\r\n    angle,\r\n    distance: radialDistanceFromCenter\r\n  };\r\n}\r\nfunction distanceBetweenPoints(pt1, pt2) {\r\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n}\r\nfunction _angleDiff(a, b) {\r\n  return (a - b + PITAU) % TAU - PI;\r\n}\r\nfunction _normalizeAngle(a) {\r\n  return (a % TAU + TAU) % TAU;\r\n}\r\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\r\n  const a = _normalizeAngle(angle);\r\n  const s = _normalizeAngle(start);\r\n  const e = _normalizeAngle(end);\r\n  const angleToStart = _normalizeAngle(s - a);\r\n  const angleToEnd = _normalizeAngle(e - a);\r\n  const startToAngle = _normalizeAngle(a - s);\r\n  const endToAngle = _normalizeAngle(a - e);\r\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\r\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\r\n}\r\nfunction _limitValue(value, min, max) {\r\n  return Math.max(min, Math.min(max, value));\r\n}\r\nfunction _int16Range(value) {\r\n  return _limitValue(value, -32768, 32767);\r\n}\r\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\r\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\r\n}\r\n\r\nfunction _isDomSupported() {\r\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\r\n}\r\nfunction _getParentNode(domNode) {\r\n  let parent = domNode.parentNode;\r\n  if (parent && parent.toString() === '[object ShadowRoot]') {\r\n    parent = parent.host;\r\n  }\r\n  return parent;\r\n}\r\nfunction parseMaxStyle(styleValue, node, parentProperty) {\r\n  let valueInPixels;\r\n  if (typeof styleValue === 'string') {\r\n    valueInPixels = parseInt(styleValue, 10);\r\n    if (styleValue.indexOf('%') !== -1) {\r\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\r\n    }\r\n  } else {\r\n    valueInPixels = styleValue;\r\n  }\r\n  return valueInPixels;\r\n}\r\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\r\nfunction getStyle(el, property) {\r\n  return getComputedStyle(el).getPropertyValue(property);\r\n}\r\nconst positions = ['top', 'right', 'bottom', 'left'];\r\nfunction getPositionedStyle(styles, style, suffix) {\r\n  const result = {};\r\n  suffix = suffix ? '-' + suffix : '';\r\n  for (let i = 0; i < 4; i++) {\r\n    const pos = positions[i];\r\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\r\n  }\r\n  result.width = result.left + result.right;\r\n  result.height = result.top + result.bottom;\r\n  return result;\r\n}\r\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\r\nfunction getCanvasPosition(e, canvas) {\r\n  const touches = e.touches;\r\n  const source = touches && touches.length ? touches[0] : e;\r\n  const {offsetX, offsetY} = source;\r\n  let box = false;\r\n  let x, y;\r\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\r\n    x = offsetX;\r\n    y = offsetY;\r\n  } else {\r\n    const rect = canvas.getBoundingClientRect();\r\n    x = source.clientX - rect.left;\r\n    y = source.clientY - rect.top;\r\n    box = true;\r\n  }\r\n  return {x, y, box};\r\n}\r\nfunction getRelativePosition(evt, chart) {\r\n  if ('native' in evt) {\r\n    return evt;\r\n  }\r\n  const {canvas, currentDevicePixelRatio} = chart;\r\n  const style = getComputedStyle(canvas);\r\n  const borderBox = style.boxSizing === 'border-box';\r\n  const paddings = getPositionedStyle(style, 'padding');\r\n  const borders = getPositionedStyle(style, 'border', 'width');\r\n  const {x, y, box} = getCanvasPosition(evt, canvas);\r\n  const xOffset = paddings.left + (box && borders.left);\r\n  const yOffset = paddings.top + (box && borders.top);\r\n  let {width, height} = chart;\r\n  if (borderBox) {\r\n    width -= paddings.width + borders.width;\r\n    height -= paddings.height + borders.height;\r\n  }\r\n  return {\r\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\r\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\r\n  };\r\n}\r\nfunction getContainerSize(canvas, width, height) {\r\n  let maxWidth, maxHeight;\r\n  if (width === undefined || height === undefined) {\r\n    const container = _getParentNode(canvas);\r\n    if (!container) {\r\n      width = canvas.clientWidth;\r\n      height = canvas.clientHeight;\r\n    } else {\r\n      const rect = container.getBoundingClientRect();\r\n      const containerStyle = getComputedStyle(container);\r\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\r\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\r\n      width = rect.width - containerPadding.width - containerBorder.width;\r\n      height = rect.height - containerPadding.height - containerBorder.height;\r\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\r\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\r\n    }\r\n  }\r\n  return {\r\n    width,\r\n    height,\r\n    maxWidth: maxWidth || INFINITY,\r\n    maxHeight: maxHeight || INFINITY\r\n  };\r\n}\r\nconst round1 = v => Math.round(v * 10) / 10;\r\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\r\n  const style = getComputedStyle(canvas);\r\n  const margins = getPositionedStyle(style, 'margin');\r\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\r\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\r\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\r\n  let {width, height} = containerSize;\r\n  if (style.boxSizing === 'content-box') {\r\n    const borders = getPositionedStyle(style, 'border', 'width');\r\n    const paddings = getPositionedStyle(style, 'padding');\r\n    width -= paddings.width + borders.width;\r\n    height -= paddings.height + borders.height;\r\n  }\r\n  width = Math.max(0, width - margins.width);\r\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\r\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\r\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\r\n  if (width && !height) {\r\n    height = round1(width / 2);\r\n  }\r\n  return {\r\n    width,\r\n    height\r\n  };\r\n}\r\nfunction retinaScale(chart, forceRatio, forceStyle) {\r\n  const pixelRatio = forceRatio || 1;\r\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\r\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\r\n  chart.height = deviceHeight / pixelRatio;\r\n  chart.width = deviceWidth / pixelRatio;\r\n  const canvas = chart.canvas;\r\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\r\n    canvas.style.height = `${chart.height}px`;\r\n    canvas.style.width = `${chart.width}px`;\r\n  }\r\n  if (chart.currentDevicePixelRatio !== pixelRatio\r\n      || canvas.height !== deviceHeight\r\n      || canvas.width !== deviceWidth) {\r\n    chart.currentDevicePixelRatio = pixelRatio;\r\n    canvas.height = deviceHeight;\r\n    canvas.width = deviceWidth;\r\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nconst supportsEventListenerOptions = (function() {\r\n  let passiveSupported = false;\r\n  try {\r\n    const options = {\r\n      get passive() {\r\n        passiveSupported = true;\r\n        return false;\r\n      }\r\n    };\r\n    window.addEventListener('test', null, options);\r\n    window.removeEventListener('test', null, options);\r\n  } catch (e) {\r\n  }\r\n  return passiveSupported;\r\n}());\r\nfunction readUsedSize(element, property) {\r\n  const value = getStyle(element, property);\r\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\r\n  return matches ? +matches[1] : undefined;\r\n}\r\n\r\nfunction toFontString(font) {\r\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\r\n    return null;\r\n  }\r\n  return (font.style ? font.style + ' ' : '')\r\n\t\t+ (font.weight ? font.weight + ' ' : '')\r\n\t\t+ font.size + 'px '\r\n\t\t+ font.family;\r\n}\r\nfunction _measureText(ctx, data, gc, longest, string) {\r\n  let textWidth = data[string];\r\n  if (!textWidth) {\r\n    textWidth = data[string] = ctx.measureText(string).width;\r\n    gc.push(string);\r\n  }\r\n  if (textWidth > longest) {\r\n    longest = textWidth;\r\n  }\r\n  return longest;\r\n}\r\nfunction _longestText(ctx, font, arrayOfThings, cache) {\r\n  cache = cache || {};\r\n  let data = cache.data = cache.data || {};\r\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\r\n  if (cache.font !== font) {\r\n    data = cache.data = {};\r\n    gc = cache.garbageCollect = [];\r\n    cache.font = font;\r\n  }\r\n  ctx.save();\r\n  ctx.font = font;\r\n  let longest = 0;\r\n  const ilen = arrayOfThings.length;\r\n  let i, j, jlen, thing, nestedThing;\r\n  for (i = 0; i < ilen; i++) {\r\n    thing = arrayOfThings[i];\r\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\r\n      longest = _measureText(ctx, data, gc, longest, thing);\r\n    } else if (isArray(thing)) {\r\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\r\n        nestedThing = thing[j];\r\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\r\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  ctx.restore();\r\n  const gcLen = gc.length / 2;\r\n  if (gcLen > arrayOfThings.length) {\r\n    for (i = 0; i < gcLen; i++) {\r\n      delete data[gc[i]];\r\n    }\r\n    gc.splice(0, gcLen);\r\n  }\r\n  return longest;\r\n}\r\nfunction _alignPixel(chart, pixel, width) {\r\n  const devicePixelRatio = chart.currentDevicePixelRatio;\r\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\r\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\r\n}\r\nfunction clearCanvas(canvas, ctx) {\r\n  ctx = ctx || canvas.getContext('2d');\r\n  ctx.save();\r\n  ctx.resetTransform();\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  ctx.restore();\r\n}\r\nfunction drawPoint(ctx, options, x, y) {\r\n  let type, xOffset, yOffset, size, cornerRadius;\r\n  const style = options.pointStyle;\r\n  const rotation = options.rotation;\r\n  const radius = options.radius;\r\n  let rad = (rotation || 0) * RAD_PER_DEG;\r\n  if (style && typeof style === 'object') {\r\n    type = style.toString();\r\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n      ctx.save();\r\n      ctx.translate(x, y);\r\n      ctx.rotate(rad);\r\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\r\n      ctx.restore();\r\n      return;\r\n    }\r\n  }\r\n  if (isNaN(radius) || radius <= 0) {\r\n    return;\r\n  }\r\n  ctx.beginPath();\r\n  switch (style) {\r\n  default:\r\n    ctx.arc(x, y, radius, 0, TAU);\r\n    ctx.closePath();\r\n    break;\r\n  case 'triangle':\r\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    rad += TWO_THIRDS_PI;\r\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    rad += TWO_THIRDS_PI;\r\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\r\n    ctx.closePath();\r\n    break;\r\n  case 'rectRounded':\r\n    cornerRadius = radius * 0.516;\r\n    size = radius - cornerRadius;\r\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\r\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\r\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\r\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\r\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\r\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\r\n    ctx.closePath();\r\n    break;\r\n  case 'rect':\r\n    if (!rotation) {\r\n      size = Math.SQRT1_2 * radius;\r\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\r\n      break;\r\n    }\r\n    rad += QUARTER_PI;\r\n  case 'rectRot':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    ctx.closePath();\r\n    break;\r\n  case 'crossRot':\r\n    rad += QUARTER_PI;\r\n  case 'cross':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    break;\r\n  case 'star':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    rad += QUARTER_PI;\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    ctx.moveTo(x + yOffset, y - xOffset);\r\n    ctx.lineTo(x - yOffset, y + xOffset);\r\n    break;\r\n  case 'line':\r\n    xOffset = Math.cos(rad) * radius;\r\n    yOffset = Math.sin(rad) * radius;\r\n    ctx.moveTo(x - xOffset, y - yOffset);\r\n    ctx.lineTo(x + xOffset, y + yOffset);\r\n    break;\r\n  case 'dash':\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\r\n    break;\r\n  }\r\n  ctx.fill();\r\n  if (options.borderWidth > 0) {\r\n    ctx.stroke();\r\n  }\r\n}\r\nfunction _isPointInArea(point, area, margin) {\r\n  margin = margin || 0.5;\r\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\r\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\r\n}\r\nfunction clipArea(ctx, area) {\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n  ctx.clip();\r\n}\r\nfunction unclipArea(ctx) {\r\n  ctx.restore();\r\n}\r\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\r\n  if (!previous) {\r\n    return ctx.lineTo(target.x, target.y);\r\n  }\r\n  if (mode === 'middle') {\r\n    const midpoint = (previous.x + target.x) / 2.0;\r\n    ctx.lineTo(midpoint, previous.y);\r\n    ctx.lineTo(midpoint, target.y);\r\n  } else if (mode === 'after' !== !!flip) {\r\n    ctx.lineTo(previous.x, target.y);\r\n  } else {\r\n    ctx.lineTo(target.x, previous.y);\r\n  }\r\n  ctx.lineTo(target.x, target.y);\r\n}\r\nfunction _bezierCurveTo(ctx, previous, target, flip) {\r\n  if (!previous) {\r\n    return ctx.lineTo(target.x, target.y);\r\n  }\r\n  ctx.bezierCurveTo(\r\n    flip ? previous.cp1x : previous.cp2x,\r\n    flip ? previous.cp1y : previous.cp2y,\r\n    flip ? target.cp2x : target.cp1x,\r\n    flip ? target.cp2y : target.cp1y,\r\n    target.x,\r\n    target.y);\r\n}\r\nfunction renderText(ctx, text, x, y, font, opts = {}) {\r\n  const lines = isArray(text) ? text : [text];\r\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\r\n  let i, line;\r\n  ctx.save();\r\n  ctx.font = font.string;\r\n  setRenderOpts(ctx, opts);\r\n  for (i = 0; i < lines.length; ++i) {\r\n    line = lines[i];\r\n    if (stroke) {\r\n      if (opts.strokeColor) {\r\n        ctx.strokeStyle = opts.strokeColor;\r\n      }\r\n      if (!isNullOrUndef(opts.strokeWidth)) {\r\n        ctx.lineWidth = opts.strokeWidth;\r\n      }\r\n      ctx.strokeText(line, x, y, opts.maxWidth);\r\n    }\r\n    ctx.fillText(line, x, y, opts.maxWidth);\r\n    decorateText(ctx, x, y, line, opts);\r\n    y += font.lineHeight;\r\n  }\r\n  ctx.restore();\r\n}\r\nfunction setRenderOpts(ctx, opts) {\r\n  if (opts.translation) {\r\n    ctx.translate(opts.translation[0], opts.translation[1]);\r\n  }\r\n  if (!isNullOrUndef(opts.rotation)) {\r\n    ctx.rotate(opts.rotation);\r\n  }\r\n  if (opts.color) {\r\n    ctx.fillStyle = opts.color;\r\n  }\r\n  if (opts.textAlign) {\r\n    ctx.textAlign = opts.textAlign;\r\n  }\r\n  if (opts.textBaseline) {\r\n    ctx.textBaseline = opts.textBaseline;\r\n  }\r\n}\r\nfunction decorateText(ctx, x, y, line, opts) {\r\n  if (opts.strikethrough || opts.underline) {\r\n    const metrics = ctx.measureText(line);\r\n    const left = x - metrics.actualBoundingBoxLeft;\r\n    const right = x + metrics.actualBoundingBoxRight;\r\n    const top = y - metrics.actualBoundingBoxAscent;\r\n    const bottom = y + metrics.actualBoundingBoxDescent;\r\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\r\n    ctx.strokeStyle = ctx.fillStyle;\r\n    ctx.beginPath();\r\n    ctx.lineWidth = opts.decorationWidth || 2;\r\n    ctx.moveTo(left, yDecoration);\r\n    ctx.lineTo(right, yDecoration);\r\n    ctx.stroke();\r\n  }\r\n}\r\nfunction addRoundedRectPath(ctx, rect) {\r\n  const {x, y, w, h, radius} = rect;\r\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\r\n  ctx.lineTo(x, y + h - radius.bottomLeft);\r\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\r\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\r\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\r\n  ctx.lineTo(x + w, y + radius.topRight);\r\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\r\n  ctx.lineTo(x + radius.topLeft, y);\r\n}\r\n\r\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\r\n  if (!defined(fallback)) {\r\n    fallback = _resolve('_fallback', scopes);\r\n  }\r\n  const cache = {\r\n    [Symbol.toStringTag]: 'Object',\r\n    _cacheable: true,\r\n    _scopes: scopes,\r\n    _rootScopes: rootScopes,\r\n    _fallback: fallback,\r\n    _getTarget: getTarget,\r\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\r\n  };\r\n  return new Proxy(cache, {\r\n    deleteProperty(target, prop) {\r\n      delete target[prop];\r\n      delete target._keys;\r\n      delete scopes[0][prop];\r\n      return true;\r\n    },\r\n    get(target, prop) {\r\n      return _cached(target, prop,\r\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\r\n    },\r\n    getOwnPropertyDescriptor(target, prop) {\r\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\r\n    },\r\n    getPrototypeOf() {\r\n      return Reflect.getPrototypeOf(scopes[0]);\r\n    },\r\n    has(target, prop) {\r\n      return getKeysFromAllScopes(target).includes(prop);\r\n    },\r\n    ownKeys(target) {\r\n      return getKeysFromAllScopes(target);\r\n    },\r\n    set(target, prop, value) {\r\n      const storage = target._storage || (target._storage = getTarget());\r\n      target[prop] = storage[prop] = value;\r\n      delete target._keys;\r\n      return true;\r\n    }\r\n  });\r\n}\r\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\r\n  const cache = {\r\n    _cacheable: false,\r\n    _proxy: proxy,\r\n    _context: context,\r\n    _subProxy: subProxy,\r\n    _stack: new Set(),\r\n    _descriptors: _descriptors(proxy, descriptorDefaults),\r\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\r\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\r\n  };\r\n  return new Proxy(cache, {\r\n    deleteProperty(target, prop) {\r\n      delete target[prop];\r\n      delete proxy[prop];\r\n      return true;\r\n    },\r\n    get(target, prop, receiver) {\r\n      return _cached(target, prop,\r\n        () => _resolveWithContext(target, prop, receiver));\r\n    },\r\n    getOwnPropertyDescriptor(target, prop) {\r\n      return target._descriptors.allKeys\r\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\r\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\r\n    },\r\n    getPrototypeOf() {\r\n      return Reflect.getPrototypeOf(proxy);\r\n    },\r\n    has(target, prop) {\r\n      return Reflect.has(proxy, prop);\r\n    },\r\n    ownKeys() {\r\n      return Reflect.ownKeys(proxy);\r\n    },\r\n    set(target, prop, value) {\r\n      proxy[prop] = value;\r\n      delete target[prop];\r\n      return true;\r\n    }\r\n  });\r\n}\r\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\r\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\r\n  return {\r\n    allKeys: _allKeys,\r\n    scriptable: _scriptable,\r\n    indexable: _indexable,\r\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\r\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\r\n  };\r\n}\r\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\r\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\r\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\r\nfunction _cached(target, prop, resolve) {\r\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\r\n    return target[prop];\r\n  }\r\n  const value = resolve();\r\n  target[prop] = value;\r\n  return value;\r\n}\r\nfunction _resolveWithContext(target, prop, receiver) {\r\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n  let value = _proxy[prop];\r\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\r\n    value = _resolveScriptable(prop, value, target, receiver);\r\n  }\r\n  if (isArray(value) && value.length) {\r\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\r\n  }\r\n  if (needsSubResolver(prop, value)) {\r\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\r\n  }\r\n  return value;\r\n}\r\nfunction _resolveScriptable(prop, value, target, receiver) {\r\n  const {_proxy, _context, _subProxy, _stack} = target;\r\n  if (_stack.has(prop)) {\r\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\r\n  }\r\n  _stack.add(prop);\r\n  value = value(_context, _subProxy || receiver);\r\n  _stack.delete(prop);\r\n  if (needsSubResolver(prop, value)) {\r\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\r\n  }\r\n  return value;\r\n}\r\nfunction _resolveArray(prop, value, target, isIndexable) {\r\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\r\n  if (defined(_context.index) && isIndexable(prop)) {\r\n    value = value[_context.index % value.length];\r\n  } else if (isObject(value[0])) {\r\n    const arr = value;\r\n    const scopes = _proxy._scopes.filter(s => s !== arr);\r\n    value = [];\r\n    for (const item of arr) {\r\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\r\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\r\n    }\r\n  }\r\n  return value;\r\n}\r\nfunction resolveFallback(fallback, prop, value) {\r\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\r\n}\r\nconst getScope = (key, parent) => key === true ? parent\r\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\r\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\r\n  for (const parent of parentScopes) {\r\n    const scope = getScope(key, parent);\r\n    if (scope) {\r\n      set.add(scope);\r\n      const fallback = resolveFallback(scope._fallback, key, value);\r\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\r\n        return fallback;\r\n      }\r\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\r\n      return null;\r\n    }\r\n  }\r\n  return false;\r\n}\r\nfunction createSubResolver(parentScopes, resolver, prop, value) {\r\n  const rootScopes = resolver._rootScopes;\r\n  const fallback = resolveFallback(resolver._fallback, prop, value);\r\n  const allScopes = [...parentScopes, ...rootScopes];\r\n  const set = new Set();\r\n  set.add(value);\r\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\r\n  if (key === null) {\r\n    return false;\r\n  }\r\n  if (defined(fallback) && fallback !== prop) {\r\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\r\n    if (key === null) {\r\n      return false;\r\n    }\r\n  }\r\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\r\n    () => subGetTarget(resolver, prop, value));\r\n}\r\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\r\n  while (key) {\r\n    key = addScopes(set, allScopes, key, fallback, item);\r\n  }\r\n  return key;\r\n}\r\nfunction subGetTarget(resolver, prop, value) {\r\n  const parent = resolver._getTarget();\r\n  if (!(prop in parent)) {\r\n    parent[prop] = {};\r\n  }\r\n  const target = parent[prop];\r\n  if (isArray(target) && isObject(value)) {\r\n    return value;\r\n  }\r\n  return target;\r\n}\r\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\r\n  let value;\r\n  for (const prefix of prefixes) {\r\n    value = _resolve(readKey(prefix, prop), scopes);\r\n    if (defined(value)) {\r\n      return needsSubResolver(prop, value)\r\n        ? createSubResolver(scopes, proxy, prop, value)\r\n        : value;\r\n    }\r\n  }\r\n}\r\nfunction _resolve(key, scopes) {\r\n  for (const scope of scopes) {\r\n    if (!scope) {\r\n      continue;\r\n    }\r\n    const value = scope[key];\r\n    if (defined(value)) {\r\n      return value;\r\n    }\r\n  }\r\n}\r\nfunction getKeysFromAllScopes(target) {\r\n  let keys = target._keys;\r\n  if (!keys) {\r\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\r\n  }\r\n  return keys;\r\n}\r\nfunction resolveKeysFromAllScopes(scopes) {\r\n  const set = new Set();\r\n  for (const scope of scopes) {\r\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\r\n      set.add(key);\r\n    }\r\n  }\r\n  return Array.from(set);\r\n}\r\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\r\n  const {iScale} = meta;\r\n  const {key = 'r'} = this._parsing;\r\n  const parsed = new Array(count);\r\n  let i, ilen, index, item;\r\n  for (i = 0, ilen = count; i < ilen; ++i) {\r\n    index = i + start;\r\n    item = data[index];\r\n    parsed[i] = {\r\n      r: iScale.parse(resolveObjectKey(item, key), index)\r\n    };\r\n  }\r\n  return parsed;\r\n}\r\n\r\nconst EPSILON = Number.EPSILON || 1e-14;\r\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\r\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\r\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\r\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\r\n  const current = middlePoint;\r\n  const next = afterPoint.skip ? middlePoint : afterPoint;\r\n  const d01 = distanceBetweenPoints(current, previous);\r\n  const d12 = distanceBetweenPoints(next, current);\r\n  let s01 = d01 / (d01 + d12);\r\n  let s12 = d12 / (d01 + d12);\r\n  s01 = isNaN(s01) ? 0 : s01;\r\n  s12 = isNaN(s12) ? 0 : s12;\r\n  const fa = t * s01;\r\n  const fb = t * s12;\r\n  return {\r\n    previous: {\r\n      x: current.x - fa * (next.x - previous.x),\r\n      y: current.y - fa * (next.y - previous.y)\r\n    },\r\n    next: {\r\n      x: current.x + fb * (next.x - previous.x),\r\n      y: current.y + fb * (next.y - previous.y)\r\n    }\r\n  };\r\n}\r\nfunction monotoneAdjust(points, deltaK, mK) {\r\n  const pointsLen = points.length;\r\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\r\n  let pointAfter = getPoint(points, 0);\r\n  for (let i = 0; i < pointsLen - 1; ++i) {\r\n    pointCurrent = pointAfter;\r\n    pointAfter = getPoint(points, i + 1);\r\n    if (!pointCurrent || !pointAfter) {\r\n      continue;\r\n    }\r\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\r\n      mK[i] = mK[i + 1] = 0;\r\n      continue;\r\n    }\r\n    alphaK = mK[i] / deltaK[i];\r\n    betaK = mK[i + 1] / deltaK[i];\r\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n    if (squaredMagnitude <= 9) {\r\n      continue;\r\n    }\r\n    tauK = 3 / Math.sqrt(squaredMagnitude);\r\n    mK[i] = alphaK * tauK * deltaK[i];\r\n    mK[i + 1] = betaK * tauK * deltaK[i];\r\n  }\r\n}\r\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\r\n  const valueAxis = getValueAxis(indexAxis);\r\n  const pointsLen = points.length;\r\n  let delta, pointBefore, pointCurrent;\r\n  let pointAfter = getPoint(points, 0);\r\n  for (let i = 0; i < pointsLen; ++i) {\r\n    pointBefore = pointCurrent;\r\n    pointCurrent = pointAfter;\r\n    pointAfter = getPoint(points, i + 1);\r\n    if (!pointCurrent) {\r\n      continue;\r\n    }\r\n    const iPixel = pointCurrent[indexAxis];\r\n    const vPixel = pointCurrent[valueAxis];\r\n    if (pointBefore) {\r\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\r\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\r\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\r\n    }\r\n    if (pointAfter) {\r\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\r\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\r\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\r\n    }\r\n  }\r\n}\r\nfunction splineCurveMonotone(points, indexAxis = 'x') {\r\n  const valueAxis = getValueAxis(indexAxis);\r\n  const pointsLen = points.length;\r\n  const deltaK = Array(pointsLen).fill(0);\r\n  const mK = Array(pointsLen);\r\n  let i, pointBefore, pointCurrent;\r\n  let pointAfter = getPoint(points, 0);\r\n  for (i = 0; i < pointsLen; ++i) {\r\n    pointBefore = pointCurrent;\r\n    pointCurrent = pointAfter;\r\n    pointAfter = getPoint(points, i + 1);\r\n    if (!pointCurrent) {\r\n      continue;\r\n    }\r\n    if (pointAfter) {\r\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\r\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\r\n    }\r\n    mK[i] = !pointBefore ? deltaK[i]\r\n      : !pointAfter ? deltaK[i - 1]\r\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\r\n      : (deltaK[i - 1] + deltaK[i]) / 2;\r\n  }\r\n  monotoneAdjust(points, deltaK, mK);\r\n  monotoneCompute(points, mK, indexAxis);\r\n}\r\nfunction capControlPoint(pt, min, max) {\r\n  return Math.max(Math.min(pt, max), min);\r\n}\r\nfunction capBezierPoints(points, area) {\r\n  let i, ilen, point, inArea, inAreaPrev;\r\n  let inAreaNext = _isPointInArea(points[0], area);\r\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n    inAreaPrev = inArea;\r\n    inArea = inAreaNext;\r\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\r\n    if (!inArea) {\r\n      continue;\r\n    }\r\n    point = points[i];\r\n    if (inAreaPrev) {\r\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\r\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\r\n    }\r\n    if (inAreaNext) {\r\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\r\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\r\n    }\r\n  }\r\n}\r\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\r\n  let i, ilen, point, controlPoints;\r\n  if (options.spanGaps) {\r\n    points = points.filter((pt) => !pt.skip);\r\n  }\r\n  if (options.cubicInterpolationMode === 'monotone') {\r\n    splineCurveMonotone(points, indexAxis);\r\n  } else {\r\n    let prev = loop ? points[points.length - 1] : points[0];\r\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n      point = points[i];\r\n      controlPoints = splineCurve(\r\n        prev,\r\n        point,\r\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\r\n        options.tension\r\n      );\r\n      point.cp1x = controlPoints.previous.x;\r\n      point.cp1y = controlPoints.previous.y;\r\n      point.cp2x = controlPoints.next.x;\r\n      point.cp2y = controlPoints.next.y;\r\n      prev = point;\r\n    }\r\n  }\r\n  if (options.capBezierPoints) {\r\n    capBezierPoints(points, area);\r\n  }\r\n}\r\n\r\nconst atEdge = (t) => t === 0 || t === 1;\r\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\r\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\r\nconst effects = {\r\n  linear: t => t,\r\n  easeInQuad: t => t * t,\r\n  easeOutQuad: t => -t * (t - 2),\r\n  easeInOutQuad: t => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t\r\n    : -0.5 * ((--t) * (t - 2) - 1),\r\n  easeInCubic: t => t * t * t,\r\n  easeOutCubic: t => (t -= 1) * t * t + 1,\r\n  easeInOutCubic: t => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t * t\r\n    : 0.5 * ((t -= 2) * t * t + 2),\r\n  easeInQuart: t => t * t * t * t,\r\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\r\n  easeInOutQuart: t => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t * t * t\r\n    : -0.5 * ((t -= 2) * t * t * t - 2),\r\n  easeInQuint: t => t * t * t * t * t,\r\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\r\n  easeInOutQuint: t => ((t /= 0.5) < 1)\r\n    ? 0.5 * t * t * t * t * t\r\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\r\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\r\n  easeOutSine: t => Math.sin(t * HALF_PI),\r\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\r\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\r\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\r\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\r\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\r\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\r\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\r\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\r\n  easeInOutCirc: t => ((t /= 0.5) < 1)\r\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\r\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\r\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\r\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\r\n  easeInOutElastic(t) {\r\n    const s = 0.1125;\r\n    const p = 0.45;\r\n    return atEdge(t) ? t :\r\n      t < 0.5\r\n        ? 0.5 * elasticIn(t * 2, s, p)\r\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\r\n  },\r\n  easeInBack(t) {\r\n    const s = 1.70158;\r\n    return t * t * ((s + 1) * t - s);\r\n  },\r\n  easeOutBack(t) {\r\n    const s = 1.70158;\r\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\r\n  },\r\n  easeInOutBack(t) {\r\n    let s = 1.70158;\r\n    if ((t /= 0.5) < 1) {\r\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n    }\r\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n  },\r\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\r\n  easeOutBounce(t) {\r\n    const m = 7.5625;\r\n    const d = 2.75;\r\n    if (t < (1 / d)) {\r\n      return m * t * t;\r\n    }\r\n    if (t < (2 / d)) {\r\n      return m * (t -= (1.5 / d)) * t + 0.75;\r\n    }\r\n    if (t < (2.5 / d)) {\r\n      return m * (t -= (2.25 / d)) * t + 0.9375;\r\n    }\r\n    return m * (t -= (2.625 / d)) * t + 0.984375;\r\n  },\r\n  easeInOutBounce: t => (t < 0.5)\r\n    ? effects.easeInBounce(t * 2) * 0.5\r\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\r\n};\r\n\r\nfunction _pointInLine(p1, p2, t, mode) {\r\n  return {\r\n    x: p1.x + t * (p2.x - p1.x),\r\n    y: p1.y + t * (p2.y - p1.y)\r\n  };\r\n}\r\nfunction _steppedInterpolation(p1, p2, t, mode) {\r\n  return {\r\n    x: p1.x + t * (p2.x - p1.x),\r\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\r\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\r\n    : t > 0 ? p2.y : p1.y\r\n  };\r\n}\r\nfunction _bezierInterpolation(p1, p2, t, mode) {\r\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\r\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\r\n  const a = _pointInLine(p1, cp1, t);\r\n  const b = _pointInLine(cp1, cp2, t);\r\n  const c = _pointInLine(cp2, p2, t);\r\n  const d = _pointInLine(a, b, t);\r\n  const e = _pointInLine(b, c, t);\r\n  return _pointInLine(d, e, t);\r\n}\r\n\r\nconst intlCache = new Map();\r\nfunction getNumberFormat(locale, options) {\r\n  options = options || {};\r\n  const cacheKey = locale + JSON.stringify(options);\r\n  let formatter = intlCache.get(cacheKey);\r\n  if (!formatter) {\r\n    formatter = new Intl.NumberFormat(locale, options);\r\n    intlCache.set(cacheKey, formatter);\r\n  }\r\n  return formatter;\r\n}\r\nfunction formatNumber(num, locale, options) {\r\n  return getNumberFormat(locale, options).format(num);\r\n}\r\n\r\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\r\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\r\nfunction toLineHeight(value, size) {\r\n  const matches = ('' + value).match(LINE_HEIGHT);\r\n  if (!matches || matches[1] === 'normal') {\r\n    return size * 1.2;\r\n  }\r\n  value = +matches[2];\r\n  switch (matches[3]) {\r\n  case 'px':\r\n    return value;\r\n  case '%':\r\n    value /= 100;\r\n    break;\r\n  }\r\n  return size * value;\r\n}\r\nconst numberOrZero = v => +v || 0;\r\nfunction _readValueToProps(value, props) {\r\n  const ret = {};\r\n  const objProps = isObject(props);\r\n  const keys = objProps ? Object.keys(props) : props;\r\n  const read = isObject(value)\r\n    ? objProps\r\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\r\n      : prop => value[prop]\r\n    : () => value;\r\n  for (const prop of keys) {\r\n    ret[prop] = numberOrZero(read(prop));\r\n  }\r\n  return ret;\r\n}\r\nfunction toTRBL(value) {\r\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\r\n}\r\nfunction toTRBLCorners(value) {\r\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\r\n}\r\nfunction toPadding(value) {\r\n  const obj = toTRBL(value);\r\n  obj.width = obj.left + obj.right;\r\n  obj.height = obj.top + obj.bottom;\r\n  return obj;\r\n}\r\nfunction toFont(options, fallback) {\r\n  options = options || {};\r\n  fallback = fallback || defaults.font;\r\n  let size = valueOrDefault(options.size, fallback.size);\r\n  if (typeof size === 'string') {\r\n    size = parseInt(size, 10);\r\n  }\r\n  let style = valueOrDefault(options.style, fallback.style);\r\n  if (style && !('' + style).match(FONT_STYLE)) {\r\n    console.warn('Invalid font style specified: \"' + style + '\"');\r\n    style = '';\r\n  }\r\n  const font = {\r\n    family: valueOrDefault(options.family, fallback.family),\r\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\r\n    size,\r\n    style,\r\n    weight: valueOrDefault(options.weight, fallback.weight),\r\n    string: ''\r\n  };\r\n  font.string = toFontString(font);\r\n  return font;\r\n}\r\nfunction resolve(inputs, context, index, info) {\r\n  let cacheable = true;\r\n  let i, ilen, value;\r\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\r\n    value = inputs[i];\r\n    if (value === undefined) {\r\n      continue;\r\n    }\r\n    if (context !== undefined && typeof value === 'function') {\r\n      value = value(context);\r\n      cacheable = false;\r\n    }\r\n    if (index !== undefined && isArray(value)) {\r\n      value = value[index % value.length];\r\n      cacheable = false;\r\n    }\r\n    if (value !== undefined) {\r\n      if (info && !cacheable) {\r\n        info.cacheable = false;\r\n      }\r\n      return value;\r\n    }\r\n  }\r\n}\r\nfunction _addGrace(minmax, grace, beginAtZero) {\r\n  const {min, max} = minmax;\r\n  const change = toDimension(grace, (max - min) / 2);\r\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\r\n  return {\r\n    min: keepZero(min, -Math.abs(change)),\r\n    max: keepZero(max, change)\r\n  };\r\n}\r\nfunction createContext(parentContext, context) {\r\n  return Object.assign(Object.create(parentContext), context);\r\n}\r\n\r\nconst getRightToLeftAdapter = function(rectX, width) {\r\n  return {\r\n    x(x) {\r\n      return rectX + rectX + width - x;\r\n    },\r\n    setWidth(w) {\r\n      width = w;\r\n    },\r\n    textAlign(align) {\r\n      if (align === 'center') {\r\n        return align;\r\n      }\r\n      return align === 'right' ? 'left' : 'right';\r\n    },\r\n    xPlus(x, value) {\r\n      return x - value;\r\n    },\r\n    leftForLtr(x, itemWidth) {\r\n      return x - itemWidth;\r\n    },\r\n  };\r\n};\r\nconst getLeftToRightAdapter = function() {\r\n  return {\r\n    x(x) {\r\n      return x;\r\n    },\r\n    setWidth(w) {\r\n    },\r\n    textAlign(align) {\r\n      return align;\r\n    },\r\n    xPlus(x, value) {\r\n      return x + value;\r\n    },\r\n    leftForLtr(x, _itemWidth) {\r\n      return x;\r\n    },\r\n  };\r\n};\r\nfunction getRtlAdapter(rtl, rectX, width) {\r\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\r\n}\r\nfunction overrideTextDirection(ctx, direction) {\r\n  let style, original;\r\n  if (direction === 'ltr' || direction === 'rtl') {\r\n    style = ctx.canvas.style;\r\n    original = [\r\n      style.getPropertyValue('direction'),\r\n      style.getPropertyPriority('direction'),\r\n    ];\r\n    style.setProperty('direction', direction, 'important');\r\n    ctx.prevTextDirection = original;\r\n  }\r\n}\r\nfunction restoreTextDirection(ctx, original) {\r\n  if (original !== undefined) {\r\n    delete ctx.prevTextDirection;\r\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\r\n  }\r\n}\r\n\r\nfunction propertyFn(property) {\r\n  if (property === 'angle') {\r\n    return {\r\n      between: _angleBetween,\r\n      compare: _angleDiff,\r\n      normalize: _normalizeAngle,\r\n    };\r\n  }\r\n  return {\r\n    between: _isBetween,\r\n    compare: (a, b) => a - b,\r\n    normalize: x => x\r\n  };\r\n}\r\nfunction normalizeSegment({start, end, count, loop, style}) {\r\n  return {\r\n    start: start % count,\r\n    end: end % count,\r\n    loop: loop && (end - start + 1) % count === 0,\r\n    style\r\n  };\r\n}\r\nfunction getSegment(segment, points, bounds) {\r\n  const {property, start: startBound, end: endBound} = bounds;\r\n  const {between, normalize} = propertyFn(property);\r\n  const count = points.length;\r\n  let {start, end, loop} = segment;\r\n  let i, ilen;\r\n  if (loop) {\r\n    start += count;\r\n    end += count;\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\r\n        break;\r\n      }\r\n      start--;\r\n      end--;\r\n    }\r\n    start %= count;\r\n    end %= count;\r\n  }\r\n  if (end < start) {\r\n    end += count;\r\n  }\r\n  return {start, end, loop, style: segment.style};\r\n}\r\nfunction _boundSegment(segment, points, bounds) {\r\n  if (!bounds) {\r\n    return [segment];\r\n  }\r\n  const {property, start: startBound, end: endBound} = bounds;\r\n  const count = points.length;\r\n  const {compare, between, normalize} = propertyFn(property);\r\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\r\n  const result = [];\r\n  let inside = false;\r\n  let subStart = null;\r\n  let value, point, prevValue;\r\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\r\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\r\n  const shouldStart = () => inside || startIsBefore();\r\n  const shouldStop = () => !inside || endIsBefore();\r\n  for (let i = start, prev = start; i <= end; ++i) {\r\n    point = points[i % count];\r\n    if (point.skip) {\r\n      continue;\r\n    }\r\n    value = normalize(point[property]);\r\n    if (value === prevValue) {\r\n      continue;\r\n    }\r\n    inside = between(value, startBound, endBound);\r\n    if (subStart === null && shouldStart()) {\r\n      subStart = compare(value, startBound) === 0 ? i : prev;\r\n    }\r\n    if (subStart !== null && shouldStop()) {\r\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\r\n      subStart = null;\r\n    }\r\n    prev = i;\r\n    prevValue = value;\r\n  }\r\n  if (subStart !== null) {\r\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\r\n  }\r\n  return result;\r\n}\r\nfunction _boundSegments(line, bounds) {\r\n  const result = [];\r\n  const segments = line.segments;\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const sub = _boundSegment(segments[i], line.points, bounds);\r\n    if (sub.length) {\r\n      result.push(...sub);\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction findStartAndEnd(points, count, loop, spanGaps) {\r\n  let start = 0;\r\n  let end = count - 1;\r\n  if (loop && !spanGaps) {\r\n    while (start < count && !points[start].skip) {\r\n      start++;\r\n    }\r\n  }\r\n  while (start < count && points[start].skip) {\r\n    start++;\r\n  }\r\n  start %= count;\r\n  if (loop) {\r\n    end += start;\r\n  }\r\n  while (end > start && points[end % count].skip) {\r\n    end--;\r\n  }\r\n  end %= count;\r\n  return {start, end};\r\n}\r\nfunction solidSegments(points, start, max, loop) {\r\n  const count = points.length;\r\n  const result = [];\r\n  let last = start;\r\n  let prev = points[start];\r\n  let end;\r\n  for (end = start + 1; end <= max; ++end) {\r\n    const cur = points[end % count];\r\n    if (cur.skip || cur.stop) {\r\n      if (!prev.skip) {\r\n        loop = false;\r\n        result.push({start: start % count, end: (end - 1) % count, loop});\r\n        start = last = cur.stop ? end : null;\r\n      }\r\n    } else {\r\n      last = end;\r\n      if (prev.skip) {\r\n        start = end;\r\n      }\r\n    }\r\n    prev = cur;\r\n  }\r\n  if (last !== null) {\r\n    result.push({start: start % count, end: last % count, loop});\r\n  }\r\n  return result;\r\n}\r\nfunction _computeSegments(line, segmentOptions) {\r\n  const points = line.points;\r\n  const spanGaps = line.options.spanGaps;\r\n  const count = points.length;\r\n  if (!count) {\r\n    return [];\r\n  }\r\n  const loop = !!line._loop;\r\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\r\n  if (spanGaps === true) {\r\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\r\n  }\r\n  const max = end < start ? end + count : end;\r\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\r\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\r\n}\r\nfunction splitByStyles(line, segments, points, segmentOptions) {\r\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\r\n    return segments;\r\n  }\r\n  return doSplitByStyles(line, segments, points, segmentOptions);\r\n}\r\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\r\n  const chartContext = line._chart.getContext();\r\n  const baseStyle = readStyle(line.options);\r\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\r\n  const count = points.length;\r\n  const result = [];\r\n  let prevStyle = baseStyle;\r\n  let start = segments[0].start;\r\n  let i = start;\r\n  function addStyle(s, e, l, st) {\r\n    const dir = spanGaps ? -1 : 1;\r\n    if (s === e) {\r\n      return;\r\n    }\r\n    s += count;\r\n    while (points[s % count].skip) {\r\n      s -= dir;\r\n    }\r\n    while (points[e % count].skip) {\r\n      e += dir;\r\n    }\r\n    if (s % count !== e % count) {\r\n      result.push({start: s % count, end: e % count, loop: l, style: st});\r\n      prevStyle = st;\r\n      start = e % count;\r\n    }\r\n  }\r\n  for (const segment of segments) {\r\n    start = spanGaps ? start : segment.start;\r\n    let prev = points[start % count];\r\n    let style;\r\n    for (i = start + 1; i <= segment.end; i++) {\r\n      const pt = points[i % count];\r\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\r\n        type: 'segment',\r\n        p0: prev,\r\n        p1: pt,\r\n        p0DataIndex: (i - 1) % count,\r\n        p1DataIndex: i % count,\r\n        datasetIndex\r\n      })));\r\n      if (styleChanged(style, prevStyle)) {\r\n        addStyle(start, i - 1, segment.loop, prevStyle);\r\n      }\r\n      prev = pt;\r\n      prevStyle = style;\r\n    }\r\n    if (start < i - 1) {\r\n      addStyle(start, i - 1, segment.loop, prevStyle);\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction readStyle(options) {\r\n  return {\r\n    backgroundColor: options.backgroundColor,\r\n    borderCapStyle: options.borderCapStyle,\r\n    borderDash: options.borderDash,\r\n    borderDashOffset: options.borderDashOffset,\r\n    borderJoinStyle: options.borderJoinStyle,\r\n    borderWidth: options.borderWidth,\r\n    borderColor: options.borderColor\r\n  };\r\n}\r\nfunction styleChanged(style, prevStyle) {\r\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\r\n}\r\n\r\nvar helpers = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\neasingEffects: effects,\r\nisPatternOrGradient: isPatternOrGradient,\r\ncolor: color,\r\ngetHoverColor: getHoverColor,\r\nnoop: noop,\r\nuid: uid,\r\nisNullOrUndef: isNullOrUndef,\r\nisArray: isArray,\r\nisObject: isObject,\r\nisFinite: isNumberFinite,\r\nfiniteOrDefault: finiteOrDefault,\r\nvalueOrDefault: valueOrDefault,\r\ntoPercentage: toPercentage,\r\ntoDimension: toDimension,\r\ncallback: callback,\r\neach: each,\r\n_elementsEqual: _elementsEqual,\r\nclone: clone,\r\n_merger: _merger,\r\nmerge: merge,\r\nmergeIf: mergeIf,\r\n_mergerIf: _mergerIf,\r\n_deprecated: _deprecated,\r\nresolveObjectKey: resolveObjectKey,\r\n_capitalize: _capitalize,\r\ndefined: defined,\r\nisFunction: isFunction,\r\nsetsEqual: setsEqual,\r\n_isClickEvent: _isClickEvent,\r\ntoFontString: toFontString,\r\n_measureText: _measureText,\r\n_longestText: _longestText,\r\n_alignPixel: _alignPixel,\r\nclearCanvas: clearCanvas,\r\ndrawPoint: drawPoint,\r\n_isPointInArea: _isPointInArea,\r\nclipArea: clipArea,\r\nunclipArea: unclipArea,\r\n_steppedLineTo: _steppedLineTo,\r\n_bezierCurveTo: _bezierCurveTo,\r\nrenderText: renderText,\r\naddRoundedRectPath: addRoundedRectPath,\r\n_lookup: _lookup,\r\n_lookupByKey: _lookupByKey,\r\n_rlookupByKey: _rlookupByKey,\r\n_filterBetween: _filterBetween,\r\nlistenArrayEvents: listenArrayEvents,\r\nunlistenArrayEvents: unlistenArrayEvents,\r\n_arrayUnique: _arrayUnique,\r\n_createResolver: _createResolver,\r\n_attachContext: _attachContext,\r\n_descriptors: _descriptors,\r\n_parseObjectDataRadialScale: _parseObjectDataRadialScale,\r\nsplineCurve: splineCurve,\r\nsplineCurveMonotone: splineCurveMonotone,\r\n_updateBezierControlPoints: _updateBezierControlPoints,\r\n_isDomSupported: _isDomSupported,\r\n_getParentNode: _getParentNode,\r\ngetStyle: getStyle,\r\ngetRelativePosition: getRelativePosition,\r\ngetMaximumSize: getMaximumSize,\r\nretinaScale: retinaScale,\r\nsupportsEventListenerOptions: supportsEventListenerOptions,\r\nreadUsedSize: readUsedSize,\r\nfontString: fontString,\r\nrequestAnimFrame: requestAnimFrame,\r\nthrottled: throttled,\r\ndebounce: debounce,\r\n_toLeftRightCenter: _toLeftRightCenter,\r\n_alignStartEnd: _alignStartEnd,\r\n_textX: _textX,\r\n_pointInLine: _pointInLine,\r\n_steppedInterpolation: _steppedInterpolation,\r\n_bezierInterpolation: _bezierInterpolation,\r\nformatNumber: formatNumber,\r\ntoLineHeight: toLineHeight,\r\n_readValueToProps: _readValueToProps,\r\ntoTRBL: toTRBL,\r\ntoTRBLCorners: toTRBLCorners,\r\ntoPadding: toPadding,\r\ntoFont: toFont,\r\nresolve: resolve,\r\n_addGrace: _addGrace,\r\ncreateContext: createContext,\r\nPI: PI,\r\nTAU: TAU,\r\nPITAU: PITAU,\r\nINFINITY: INFINITY,\r\nRAD_PER_DEG: RAD_PER_DEG,\r\nHALF_PI: HALF_PI,\r\nQUARTER_PI: QUARTER_PI,\r\nTWO_THIRDS_PI: TWO_THIRDS_PI,\r\nlog10: log10,\r\nsign: sign,\r\nniceNum: niceNum,\r\n_factorize: _factorize,\r\nisNumber: isNumber,\r\nalmostEquals: almostEquals,\r\nalmostWhole: almostWhole,\r\n_setMinAndMaxByKey: _setMinAndMaxByKey,\r\ntoRadians: toRadians,\r\ntoDegrees: toDegrees,\r\n_decimalPlaces: _decimalPlaces,\r\ngetAngleFromPoint: getAngleFromPoint,\r\ndistanceBetweenPoints: distanceBetweenPoints,\r\n_angleDiff: _angleDiff,\r\n_normalizeAngle: _normalizeAngle,\r\n_angleBetween: _angleBetween,\r\n_limitValue: _limitValue,\r\n_int16Range: _int16Range,\r\n_isBetween: _isBetween,\r\ngetRtlAdapter: getRtlAdapter,\r\noverrideTextDirection: overrideTextDirection,\r\nrestoreTextDirection: restoreTextDirection,\r\n_boundSegment: _boundSegment,\r\n_boundSegments: _boundSegments,\r\n_computeSegments: _computeSegments\r\n});\r\n\r\nfunction binarySearch(metaset, axis, value, intersect) {\r\n  const {controller, data, _sorted} = metaset;\r\n  const iScale = controller._cachedMeta.iScale;\r\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\r\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\r\n    if (!intersect) {\r\n      return lookupMethod(data, axis, value);\r\n    } else if (controller._sharedOptions) {\r\n      const el = data[0];\r\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\r\n      if (range) {\r\n        const start = lookupMethod(data, axis, value - range);\r\n        const end = lookupMethod(data, axis, value + range);\r\n        return {lo: start.lo, hi: end.hi};\r\n      }\r\n    }\r\n  }\r\n  return {lo: 0, hi: data.length - 1};\r\n}\r\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\r\n  const metasets = chart.getSortedVisibleDatasetMetas();\r\n  const value = position[axis];\r\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n    const {index, data} = metasets[i];\r\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\r\n    for (let j = lo; j <= hi; ++j) {\r\n      const element = data[j];\r\n      if (!element.skip) {\r\n        handler(element, index, j);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction getDistanceMetricForAxis(axis) {\r\n  const useX = axis.indexOf('x') !== -1;\r\n  const useY = axis.indexOf('y') !== -1;\r\n  return function(pt1, pt2) {\r\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\r\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\r\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\r\n  };\r\n}\r\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\r\n  const items = [];\r\n  if (!includeInvisible && !chart.isPointInArea(position)) {\r\n    return items;\r\n  }\r\n  const evaluationFunc = function(element, datasetIndex, index) {\r\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\r\n      return;\r\n    }\r\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  };\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\r\n  return items;\r\n}\r\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\r\n  let items = [];\r\n  function evaluationFunc(element, datasetIndex, index) {\r\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\r\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\r\n    if (_angleBetween(angle, startAngle, endAngle)) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  }\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n  return items;\r\n}\r\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n  let items = [];\r\n  const distanceMetric = getDistanceMetricForAxis(axis);\r\n  let minDistance = Number.POSITIVE_INFINITY;\r\n  function evaluationFunc(element, datasetIndex, index) {\r\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\r\n    if (intersect && !inRange) {\r\n      return;\r\n    }\r\n    const center = element.getCenterPoint(useFinalPosition);\r\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\r\n    if (!pointInArea && !inRange) {\r\n      return;\r\n    }\r\n    const distance = distanceMetric(position, center);\r\n    if (distance < minDistance) {\r\n      items = [{element, datasetIndex, index}];\r\n      minDistance = distance;\r\n    } else if (distance === minDistance) {\r\n      items.push({element, datasetIndex, index});\r\n    }\r\n  }\r\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\r\n  return items;\r\n}\r\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\r\n  if (!includeInvisible && !chart.isPointInArea(position)) {\r\n    return [];\r\n  }\r\n  return axis === 'r' && !intersect\r\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\r\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\r\n}\r\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\r\n  const items = [];\r\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\r\n  let intersectsItem = false;\r\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\r\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\r\n      items.push({element, datasetIndex, index});\r\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\r\n    }\r\n  });\r\n  if (intersect && !intersectsItem) {\r\n    return [];\r\n  }\r\n  return items;\r\n}\r\nvar Interaction = {\r\n  evaluateInteractionItems,\r\n  modes: {\r\n    index(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'x';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      const items = options.intersect\r\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\r\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n      const elements = [];\r\n      if (!items.length) {\r\n        return [];\r\n      }\r\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\r\n        const index = items[0].index;\r\n        const element = meta.data[index];\r\n        if (element && !element.skip) {\r\n          elements.push({element, datasetIndex: meta.index, index});\r\n        }\r\n      });\r\n      return elements;\r\n    },\r\n    dataset(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      let items = options.intersect\r\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\r\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\r\n      if (items.length > 0) {\r\n        const datasetIndex = items[0].datasetIndex;\r\n        const data = chart.getDatasetMeta(datasetIndex).data;\r\n        items = [];\r\n        for (let i = 0; i < data.length; ++i) {\r\n          items.push({element: data[i], datasetIndex, index: i});\r\n        }\r\n      }\r\n      return items;\r\n    },\r\n    point(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\r\n    },\r\n    nearest(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      const axis = options.axis || 'xy';\r\n      const includeInvisible = options.includeInvisible || false;\r\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\r\n    },\r\n    x(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\r\n    },\r\n    y(chart, e, options, useFinalPosition) {\r\n      const position = getRelativePosition(e, chart);\r\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\r\n    }\r\n  }\r\n};\r\n\r\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\r\nfunction filterByPosition(array, position) {\r\n  return array.filter(v => v.pos === position);\r\n}\r\nfunction filterDynamicPositionByAxis(array, axis) {\r\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\r\n}\r\nfunction sortByWeight(array, reverse) {\r\n  return array.sort((a, b) => {\r\n    const v0 = reverse ? b : a;\r\n    const v1 = reverse ? a : b;\r\n    return v0.weight === v1.weight ?\r\n      v0.index - v1.index :\r\n      v0.weight - v1.weight;\r\n  });\r\n}\r\nfunction wrapBoxes(boxes) {\r\n  const layoutBoxes = [];\r\n  let i, ilen, box, pos, stack, stackWeight;\r\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\r\n    box = boxes[i];\r\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\r\n    layoutBoxes.push({\r\n      index: i,\r\n      box,\r\n      pos,\r\n      horizontal: box.isHorizontal(),\r\n      weight: box.weight,\r\n      stack: stack && (pos + stack),\r\n      stackWeight\r\n    });\r\n  }\r\n  return layoutBoxes;\r\n}\r\nfunction buildStacks(layouts) {\r\n  const stacks = {};\r\n  for (const wrap of layouts) {\r\n    const {stack, pos, stackWeight} = wrap;\r\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\r\n      continue;\r\n    }\r\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\r\n    _stack.count++;\r\n    _stack.weight += stackWeight;\r\n  }\r\n  return stacks;\r\n}\r\nfunction setLayoutDims(layouts, params) {\r\n  const stacks = buildStacks(layouts);\r\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\r\n  let i, ilen, layout;\r\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\r\n    layout = layouts[i];\r\n    const {fullSize} = layout.box;\r\n    const stack = stacks[layout.stack];\r\n    const factor = stack && layout.stackWeight / stack.weight;\r\n    if (layout.horizontal) {\r\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\r\n      layout.height = hBoxMaxHeight;\r\n    } else {\r\n      layout.width = vBoxMaxWidth;\r\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\r\n    }\r\n  }\r\n  return stacks;\r\n}\r\nfunction buildLayoutBoxes(boxes) {\r\n  const layoutBoxes = wrapBoxes(boxes);\r\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\r\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\r\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\r\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\r\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\r\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\r\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\r\n  return {\r\n    fullSize,\r\n    leftAndTop: left.concat(top),\r\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\r\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\r\n    vertical: left.concat(right).concat(centerVertical),\r\n    horizontal: top.concat(bottom).concat(centerHorizontal)\r\n  };\r\n}\r\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\r\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\r\n}\r\nfunction updateMaxPadding(maxPadding, boxPadding) {\r\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\r\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\r\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\r\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\r\n}\r\nfunction updateDims(chartArea, params, layout, stacks) {\r\n  const {pos, box} = layout;\r\n  const maxPadding = chartArea.maxPadding;\r\n  if (!isObject(pos)) {\r\n    if (layout.size) {\r\n      chartArea[pos] -= layout.size;\r\n    }\r\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\r\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\r\n    layout.size = stack.size / stack.count;\r\n    chartArea[pos] += layout.size;\r\n  }\r\n  if (box.getPadding) {\r\n    updateMaxPadding(maxPadding, box.getPadding());\r\n  }\r\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\r\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\r\n  const widthChanged = newWidth !== chartArea.w;\r\n  const heightChanged = newHeight !== chartArea.h;\r\n  chartArea.w = newWidth;\r\n  chartArea.h = newHeight;\r\n  return layout.horizontal\r\n    ? {same: widthChanged, other: heightChanged}\r\n    : {same: heightChanged, other: widthChanged};\r\n}\r\nfunction handleMaxPadding(chartArea) {\r\n  const maxPadding = chartArea.maxPadding;\r\n  function updatePos(pos) {\r\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\r\n    chartArea[pos] += change;\r\n    return change;\r\n  }\r\n  chartArea.y += updatePos('top');\r\n  chartArea.x += updatePos('left');\r\n  updatePos('right');\r\n  updatePos('bottom');\r\n}\r\nfunction getMargins(horizontal, chartArea) {\r\n  const maxPadding = chartArea.maxPadding;\r\n  function marginForPositions(positions) {\r\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\r\n    positions.forEach((pos) => {\r\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\r\n    });\r\n    return margin;\r\n  }\r\n  return horizontal\r\n    ? marginForPositions(['left', 'right'])\r\n    : marginForPositions(['top', 'bottom']);\r\n}\r\nfunction fitBoxes(boxes, chartArea, params, stacks) {\r\n  const refitBoxes = [];\r\n  let i, ilen, layout, box, refit, changed;\r\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\r\n    layout = boxes[i];\r\n    box = layout.box;\r\n    box.update(\r\n      layout.width || chartArea.w,\r\n      layout.height || chartArea.h,\r\n      getMargins(layout.horizontal, chartArea)\r\n    );\r\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\r\n    refit |= same && refitBoxes.length;\r\n    changed = changed || other;\r\n    if (!box.fullSize) {\r\n      refitBoxes.push(layout);\r\n    }\r\n  }\r\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\r\n}\r\nfunction setBoxDims(box, left, top, width, height) {\r\n  box.top = top;\r\n  box.left = left;\r\n  box.right = left + width;\r\n  box.bottom = top + height;\r\n  box.width = width;\r\n  box.height = height;\r\n}\r\nfunction placeBoxes(boxes, chartArea, params, stacks) {\r\n  const userPadding = params.padding;\r\n  let {x, y} = chartArea;\r\n  for (const layout of boxes) {\r\n    const box = layout.box;\r\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\r\n    const weight = (layout.stackWeight / stack.weight) || 1;\r\n    if (layout.horizontal) {\r\n      const width = chartArea.w * weight;\r\n      const height = stack.size || box.height;\r\n      if (defined(stack.start)) {\r\n        y = stack.start;\r\n      }\r\n      if (box.fullSize) {\r\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\r\n      } else {\r\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\r\n      }\r\n      stack.start = y;\r\n      stack.placed += width;\r\n      y = box.bottom;\r\n    } else {\r\n      const height = chartArea.h * weight;\r\n      const width = stack.size || box.width;\r\n      if (defined(stack.start)) {\r\n        x = stack.start;\r\n      }\r\n      if (box.fullSize) {\r\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\r\n      } else {\r\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\r\n      }\r\n      stack.start = x;\r\n      stack.placed += height;\r\n      x = box.right;\r\n    }\r\n  }\r\n  chartArea.x = x;\r\n  chartArea.y = y;\r\n}\r\ndefaults.set('layout', {\r\n  autoPadding: true,\r\n  padding: {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0\r\n  }\r\n});\r\nvar layouts = {\r\n  addBox(chart, item) {\r\n    if (!chart.boxes) {\r\n      chart.boxes = [];\r\n    }\r\n    item.fullSize = item.fullSize || false;\r\n    item.position = item.position || 'top';\r\n    item.weight = item.weight || 0;\r\n    item._layers = item._layers || function() {\r\n      return [{\r\n        z: 0,\r\n        draw(chartArea) {\r\n          item.draw(chartArea);\r\n        }\r\n      }];\r\n    };\r\n    chart.boxes.push(item);\r\n  },\r\n  removeBox(chart, layoutItem) {\r\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\r\n    if (index !== -1) {\r\n      chart.boxes.splice(index, 1);\r\n    }\r\n  },\r\n  configure(chart, item, options) {\r\n    item.fullSize = options.fullSize;\r\n    item.position = options.position;\r\n    item.weight = options.weight;\r\n  },\r\n  update(chart, width, height, minPadding) {\r\n    if (!chart) {\r\n      return;\r\n    }\r\n    const padding = toPadding(chart.options.layout.padding);\r\n    const availableWidth = Math.max(width - padding.width, 0);\r\n    const availableHeight = Math.max(height - padding.height, 0);\r\n    const boxes = buildLayoutBoxes(chart.boxes);\r\n    const verticalBoxes = boxes.vertical;\r\n    const horizontalBoxes = boxes.horizontal;\r\n    each(chart.boxes, box => {\r\n      if (typeof box.beforeLayout === 'function') {\r\n        box.beforeLayout();\r\n      }\r\n    });\r\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\r\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\r\n    const params = Object.freeze({\r\n      outerWidth: width,\r\n      outerHeight: height,\r\n      padding,\r\n      availableWidth,\r\n      availableHeight,\r\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\r\n      hBoxMaxHeight: availableHeight / 2\r\n    });\r\n    const maxPadding = Object.assign({}, padding);\r\n    updateMaxPadding(maxPadding, toPadding(minPadding));\r\n    const chartArea = Object.assign({\r\n      maxPadding,\r\n      w: availableWidth,\r\n      h: availableHeight,\r\n      x: padding.left,\r\n      y: padding.top\r\n    }, padding);\r\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\r\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\r\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\r\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\r\n    }\r\n    handleMaxPadding(chartArea);\r\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\r\n    chartArea.x += chartArea.w;\r\n    chartArea.y += chartArea.h;\r\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\r\n    chart.chartArea = {\r\n      left: chartArea.left,\r\n      top: chartArea.top,\r\n      right: chartArea.left + chartArea.w,\r\n      bottom: chartArea.top + chartArea.h,\r\n      height: chartArea.h,\r\n      width: chartArea.w,\r\n    };\r\n    each(boxes.chartArea, (layout) => {\r\n      const box = layout.box;\r\n      Object.assign(box, chart.chartArea);\r\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\r\n    });\r\n  }\r\n};\r\n\r\nclass BasePlatform {\r\n  acquireContext(canvas, aspectRatio) {}\r\n  releaseContext(context) {\r\n    return false;\r\n  }\r\n  addEventListener(chart, type, listener) {}\r\n  removeEventListener(chart, type, listener) {}\r\n  getDevicePixelRatio() {\r\n    return 1;\r\n  }\r\n  getMaximumSize(element, width, height, aspectRatio) {\r\n    width = Math.max(0, width || element.width);\r\n    height = height || element.height;\r\n    return {\r\n      width,\r\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\r\n    };\r\n  }\r\n  isAttached(canvas) {\r\n    return true;\r\n  }\r\n  updateConfig(config) {\r\n  }\r\n}\r\n\r\nclass BasicPlatform extends BasePlatform {\r\n  acquireContext(item) {\r\n    return item && item.getContext && item.getContext('2d') || null;\r\n  }\r\n  updateConfig(config) {\r\n    config.options.animation = false;\r\n  }\r\n}\r\n\r\nconst EXPANDO_KEY = '$chartjs';\r\nconst EVENT_TYPES = {\r\n  touchstart: 'mousedown',\r\n  touchmove: 'mousemove',\r\n  touchend: 'mouseup',\r\n  pointerenter: 'mouseenter',\r\n  pointerdown: 'mousedown',\r\n  pointermove: 'mousemove',\r\n  pointerup: 'mouseup',\r\n  pointerleave: 'mouseout',\r\n  pointerout: 'mouseout'\r\n};\r\nconst isNullOrEmpty = value => value === null || value === '';\r\nfunction initCanvas(canvas, aspectRatio) {\r\n  const style = canvas.style;\r\n  const renderHeight = canvas.getAttribute('height');\r\n  const renderWidth = canvas.getAttribute('width');\r\n  canvas[EXPANDO_KEY] = {\r\n    initial: {\r\n      height: renderHeight,\r\n      width: renderWidth,\r\n      style: {\r\n        display: style.display,\r\n        height: style.height,\r\n        width: style.width\r\n      }\r\n    }\r\n  };\r\n  style.display = style.display || 'block';\r\n  style.boxSizing = style.boxSizing || 'border-box';\r\n  if (isNullOrEmpty(renderWidth)) {\r\n    const displayWidth = readUsedSize(canvas, 'width');\r\n    if (displayWidth !== undefined) {\r\n      canvas.width = displayWidth;\r\n    }\r\n  }\r\n  if (isNullOrEmpty(renderHeight)) {\r\n    if (canvas.style.height === '') {\r\n      canvas.height = canvas.width / (aspectRatio || 2);\r\n    } else {\r\n      const displayHeight = readUsedSize(canvas, 'height');\r\n      if (displayHeight !== undefined) {\r\n        canvas.height = displayHeight;\r\n      }\r\n    }\r\n  }\r\n  return canvas;\r\n}\r\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\r\nfunction addListener(node, type, listener) {\r\n  node.addEventListener(type, listener, eventListenerOptions);\r\n}\r\nfunction removeListener(chart, type, listener) {\r\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\r\n}\r\nfunction fromNativeEvent(event, chart) {\r\n  const type = EVENT_TYPES[event.type] || event.type;\r\n  const {x, y} = getRelativePosition(event, chart);\r\n  return {\r\n    type,\r\n    chart,\r\n    native: event,\r\n    x: x !== undefined ? x : null,\r\n    y: y !== undefined ? y : null,\r\n  };\r\n}\r\nfunction nodeListContains(nodeList, canvas) {\r\n  for (const node of nodeList) {\r\n    if (node === canvas || node.contains(canvas)) {\r\n      return true;\r\n    }\r\n  }\r\n}\r\nfunction createAttachObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const observer = new MutationObserver(entries => {\r\n    let trigger = false;\r\n    for (const entry of entries) {\r\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\r\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\r\n    }\r\n    if (trigger) {\r\n      listener();\r\n    }\r\n  });\r\n  observer.observe(document, {childList: true, subtree: true});\r\n  return observer;\r\n}\r\nfunction createDetachObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const observer = new MutationObserver(entries => {\r\n    let trigger = false;\r\n    for (const entry of entries) {\r\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\r\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\r\n    }\r\n    if (trigger) {\r\n      listener();\r\n    }\r\n  });\r\n  observer.observe(document, {childList: true, subtree: true});\r\n  return observer;\r\n}\r\nconst drpListeningCharts = new Map();\r\nlet oldDevicePixelRatio = 0;\r\nfunction onWindowResize() {\r\n  const dpr = window.devicePixelRatio;\r\n  if (dpr === oldDevicePixelRatio) {\r\n    return;\r\n  }\r\n  oldDevicePixelRatio = dpr;\r\n  drpListeningCharts.forEach((resize, chart) => {\r\n    if (chart.currentDevicePixelRatio !== dpr) {\r\n      resize();\r\n    }\r\n  });\r\n}\r\nfunction listenDevicePixelRatioChanges(chart, resize) {\r\n  if (!drpListeningCharts.size) {\r\n    window.addEventListener('resize', onWindowResize);\r\n  }\r\n  drpListeningCharts.set(chart, resize);\r\n}\r\nfunction unlistenDevicePixelRatioChanges(chart) {\r\n  drpListeningCharts.delete(chart);\r\n  if (!drpListeningCharts.size) {\r\n    window.removeEventListener('resize', onWindowResize);\r\n  }\r\n}\r\nfunction createResizeObserver(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const container = canvas && _getParentNode(canvas);\r\n  if (!container) {\r\n    return;\r\n  }\r\n  const resize = throttled((width, height) => {\r\n    const w = container.clientWidth;\r\n    listener(width, height);\r\n    if (w < container.clientWidth) {\r\n      listener();\r\n    }\r\n  }, window);\r\n  const observer = new ResizeObserver(entries => {\r\n    const entry = entries[0];\r\n    const width = entry.contentRect.width;\r\n    const height = entry.contentRect.height;\r\n    if (width === 0 && height === 0) {\r\n      return;\r\n    }\r\n    resize(width, height);\r\n  });\r\n  observer.observe(container);\r\n  listenDevicePixelRatioChanges(chart, resize);\r\n  return observer;\r\n}\r\nfunction releaseObserver(chart, type, observer) {\r\n  if (observer) {\r\n    observer.disconnect();\r\n  }\r\n  if (type === 'resize') {\r\n    unlistenDevicePixelRatioChanges(chart);\r\n  }\r\n}\r\nfunction createProxyAndListen(chart, type, listener) {\r\n  const canvas = chart.canvas;\r\n  const proxy = throttled((event) => {\r\n    if (chart.ctx !== null) {\r\n      listener(fromNativeEvent(event, chart));\r\n    }\r\n  }, chart, (args) => {\r\n    const event = args[0];\r\n    return [event, event.offsetX, event.offsetY];\r\n  });\r\n  addListener(canvas, type, proxy);\r\n  return proxy;\r\n}\r\nclass DomPlatform extends BasePlatform {\r\n  acquireContext(canvas, aspectRatio) {\r\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\r\n    if (context && context.canvas === canvas) {\r\n      initCanvas(canvas, aspectRatio);\r\n      return context;\r\n    }\r\n    return null;\r\n  }\r\n  releaseContext(context) {\r\n    const canvas = context.canvas;\r\n    if (!canvas[EXPANDO_KEY]) {\r\n      return false;\r\n    }\r\n    const initial = canvas[EXPANDO_KEY].initial;\r\n    ['height', 'width'].forEach((prop) => {\r\n      const value = initial[prop];\r\n      if (isNullOrUndef(value)) {\r\n        canvas.removeAttribute(prop);\r\n      } else {\r\n        canvas.setAttribute(prop, value);\r\n      }\r\n    });\r\n    const style = initial.style || {};\r\n    Object.keys(style).forEach((key) => {\r\n      canvas.style[key] = style[key];\r\n    });\r\n    canvas.width = canvas.width;\r\n    delete canvas[EXPANDO_KEY];\r\n    return true;\r\n  }\r\n  addEventListener(chart, type, listener) {\r\n    this.removeEventListener(chart, type);\r\n    const proxies = chart.$proxies || (chart.$proxies = {});\r\n    const handlers = {\r\n      attach: createAttachObserver,\r\n      detach: createDetachObserver,\r\n      resize: createResizeObserver\r\n    };\r\n    const handler = handlers[type] || createProxyAndListen;\r\n    proxies[type] = handler(chart, type, listener);\r\n  }\r\n  removeEventListener(chart, type) {\r\n    const proxies = chart.$proxies || (chart.$proxies = {});\r\n    const proxy = proxies[type];\r\n    if (!proxy) {\r\n      return;\r\n    }\r\n    const handlers = {\r\n      attach: releaseObserver,\r\n      detach: releaseObserver,\r\n      resize: releaseObserver\r\n    };\r\n    const handler = handlers[type] || removeListener;\r\n    handler(chart, type, proxy);\r\n    proxies[type] = undefined;\r\n  }\r\n  getDevicePixelRatio() {\r\n    return window.devicePixelRatio;\r\n  }\r\n  getMaximumSize(canvas, width, height, aspectRatio) {\r\n    return getMaximumSize(canvas, width, height, aspectRatio);\r\n  }\r\n  isAttached(canvas) {\r\n    const container = _getParentNode(canvas);\r\n    return !!(container && container.isConnected);\r\n  }\r\n}\r\n\r\nfunction _detectPlatform(canvas) {\r\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\r\n    return BasicPlatform;\r\n  }\r\n  return DomPlatform;\r\n}\r\n\r\nvar platforms = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\n_detectPlatform: _detectPlatform,\r\nBasePlatform: BasePlatform,\r\nBasicPlatform: BasicPlatform,\r\nDomPlatform: DomPlatform\r\n});\r\n\r\nconst transparent = 'transparent';\r\nconst interpolators = {\r\n  boolean(from, to, factor) {\r\n    return factor > 0.5 ? to : from;\r\n  },\r\n  color(from, to, factor) {\r\n    const c0 = color(from || transparent);\r\n    const c1 = c0.valid && color(to || transparent);\r\n    return c1 && c1.valid\r\n      ? c1.mix(c0, factor).hexString()\r\n      : to;\r\n  },\r\n  number(from, to, factor) {\r\n    return from + (to - from) * factor;\r\n  }\r\n};\r\nclass Animation {\r\n  constructor(cfg, target, prop, to) {\r\n    const currentValue = target[prop];\r\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n    const from = resolve([cfg.from, currentValue, to]);\r\n    this._active = true;\r\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\r\n    this._easing = effects[cfg.easing] || effects.linear;\r\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\r\n    this._duration = this._total = Math.floor(cfg.duration);\r\n    this._loop = !!cfg.loop;\r\n    this._target = target;\r\n    this._prop = prop;\r\n    this._from = from;\r\n    this._to = to;\r\n    this._promises = undefined;\r\n  }\r\n  active() {\r\n    return this._active;\r\n  }\r\n  update(cfg, to, date) {\r\n    if (this._active) {\r\n      this._notify(false);\r\n      const currentValue = this._target[this._prop];\r\n      const elapsed = date - this._start;\r\n      const remain = this._duration - elapsed;\r\n      this._start = date;\r\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\r\n      this._total += elapsed;\r\n      this._loop = !!cfg.loop;\r\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\r\n      this._from = resolve([cfg.from, currentValue, to]);\r\n    }\r\n  }\r\n  cancel() {\r\n    if (this._active) {\r\n      this.tick(Date.now());\r\n      this._active = false;\r\n      this._notify(false);\r\n    }\r\n  }\r\n  tick(date) {\r\n    const elapsed = date - this._start;\r\n    const duration = this._duration;\r\n    const prop = this._prop;\r\n    const from = this._from;\r\n    const loop = this._loop;\r\n    const to = this._to;\r\n    let factor;\r\n    this._active = from !== to && (loop || (elapsed < duration));\r\n    if (!this._active) {\r\n      this._target[prop] = to;\r\n      this._notify(true);\r\n      return;\r\n    }\r\n    if (elapsed < 0) {\r\n      this._target[prop] = from;\r\n      return;\r\n    }\r\n    factor = (elapsed / duration) % 2;\r\n    factor = loop && factor > 1 ? 2 - factor : factor;\r\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\r\n    this._target[prop] = this._fn(from, to, factor);\r\n  }\r\n  wait() {\r\n    const promises = this._promises || (this._promises = []);\r\n    return new Promise((res, rej) => {\r\n      promises.push({res, rej});\r\n    });\r\n  }\r\n  _notify(resolved) {\r\n    const method = resolved ? 'res' : 'rej';\r\n    const promises = this._promises || [];\r\n    for (let i = 0; i < promises.length; i++) {\r\n      promises[i][method]();\r\n    }\r\n  }\r\n}\r\n\r\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\r\nconst colors = ['color', 'borderColor', 'backgroundColor'];\r\ndefaults.set('animation', {\r\n  delay: undefined,\r\n  duration: 1000,\r\n  easing: 'easeOutQuart',\r\n  fn: undefined,\r\n  from: undefined,\r\n  loop: undefined,\r\n  to: undefined,\r\n  type: undefined,\r\n});\r\nconst animationOptions = Object.keys(defaults.animation);\r\ndefaults.describe('animation', {\r\n  _fallback: false,\r\n  _indexable: false,\r\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\r\n});\r\ndefaults.set('animations', {\r\n  colors: {\r\n    type: 'color',\r\n    properties: colors\r\n  },\r\n  numbers: {\r\n    type: 'number',\r\n    properties: numbers\r\n  },\r\n});\r\ndefaults.describe('animations', {\r\n  _fallback: 'animation',\r\n});\r\ndefaults.set('transitions', {\r\n  active: {\r\n    animation: {\r\n      duration: 400\r\n    }\r\n  },\r\n  resize: {\r\n    animation: {\r\n      duration: 0\r\n    }\r\n  },\r\n  show: {\r\n    animations: {\r\n      colors: {\r\n        from: 'transparent'\r\n      },\r\n      visible: {\r\n        type: 'boolean',\r\n        duration: 0\r\n      },\r\n    }\r\n  },\r\n  hide: {\r\n    animations: {\r\n      colors: {\r\n        to: 'transparent'\r\n      },\r\n      visible: {\r\n        type: 'boolean',\r\n        easing: 'linear',\r\n        fn: v => v | 0\r\n      },\r\n    }\r\n  }\r\n});\r\nclass Animations {\r\n  constructor(chart, config) {\r\n    this._chart = chart;\r\n    this._properties = new Map();\r\n    this.configure(config);\r\n  }\r\n  configure(config) {\r\n    if (!isObject(config)) {\r\n      return;\r\n    }\r\n    const animatedProps = this._properties;\r\n    Object.getOwnPropertyNames(config).forEach(key => {\r\n      const cfg = config[key];\r\n      if (!isObject(cfg)) {\r\n        return;\r\n      }\r\n      const resolved = {};\r\n      for (const option of animationOptions) {\r\n        resolved[option] = cfg[option];\r\n      }\r\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\r\n        if (prop === key || !animatedProps.has(prop)) {\r\n          animatedProps.set(prop, resolved);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  _animateOptions(target, values) {\r\n    const newOptions = values.options;\r\n    const options = resolveTargetOptions(target, newOptions);\r\n    if (!options) {\r\n      return [];\r\n    }\r\n    const animations = this._createAnimations(options, newOptions);\r\n    if (newOptions.$shared) {\r\n      awaitAll(target.options.$animations, newOptions).then(() => {\r\n        target.options = newOptions;\r\n      }, () => {\r\n      });\r\n    }\r\n    return animations;\r\n  }\r\n  _createAnimations(target, values) {\r\n    const animatedProps = this._properties;\r\n    const animations = [];\r\n    const running = target.$animations || (target.$animations = {});\r\n    const props = Object.keys(values);\r\n    const date = Date.now();\r\n    let i;\r\n    for (i = props.length - 1; i >= 0; --i) {\r\n      const prop = props[i];\r\n      if (prop.charAt(0) === '$') {\r\n        continue;\r\n      }\r\n      if (prop === 'options') {\r\n        animations.push(...this._animateOptions(target, values));\r\n        continue;\r\n      }\r\n      const value = values[prop];\r\n      let animation = running[prop];\r\n      const cfg = animatedProps.get(prop);\r\n      if (animation) {\r\n        if (cfg && animation.active()) {\r\n          animation.update(cfg, value, date);\r\n          continue;\r\n        } else {\r\n          animation.cancel();\r\n        }\r\n      }\r\n      if (!cfg || !cfg.duration) {\r\n        target[prop] = value;\r\n        continue;\r\n      }\r\n      running[prop] = animation = new Animation(cfg, target, prop, value);\r\n      animations.push(animation);\r\n    }\r\n    return animations;\r\n  }\r\n  update(target, values) {\r\n    if (this._properties.size === 0) {\r\n      Object.assign(target, values);\r\n      return;\r\n    }\r\n    const animations = this._createAnimations(target, values);\r\n    if (animations.length) {\r\n      animator.add(this._chart, animations);\r\n      return true;\r\n    }\r\n  }\r\n}\r\nfunction awaitAll(animations, properties) {\r\n  const running = [];\r\n  const keys = Object.keys(properties);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    const anim = animations[keys[i]];\r\n    if (anim && anim.active()) {\r\n      running.push(anim.wait());\r\n    }\r\n  }\r\n  return Promise.all(running);\r\n}\r\nfunction resolveTargetOptions(target, newOptions) {\r\n  if (!newOptions) {\r\n    return;\r\n  }\r\n  let options = target.options;\r\n  if (!options) {\r\n    target.options = newOptions;\r\n    return;\r\n  }\r\n  if (options.$shared) {\r\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\r\n  }\r\n  return options;\r\n}\r\n\r\nfunction scaleClip(scale, allowedOverflow) {\r\n  const opts = scale && scale.options || {};\r\n  const reverse = opts.reverse;\r\n  const min = opts.min === undefined ? allowedOverflow : 0;\r\n  const max = opts.max === undefined ? allowedOverflow : 0;\r\n  return {\r\n    start: reverse ? max : min,\r\n    end: reverse ? min : max\r\n  };\r\n}\r\nfunction defaultClip(xScale, yScale, allowedOverflow) {\r\n  if (allowedOverflow === false) {\r\n    return false;\r\n  }\r\n  const x = scaleClip(xScale, allowedOverflow);\r\n  const y = scaleClip(yScale, allowedOverflow);\r\n  return {\r\n    top: y.end,\r\n    right: x.end,\r\n    bottom: y.start,\r\n    left: x.start\r\n  };\r\n}\r\nfunction toClip(value) {\r\n  let t, r, b, l;\r\n  if (isObject(value)) {\r\n    t = value.top;\r\n    r = value.right;\r\n    b = value.bottom;\r\n    l = value.left;\r\n  } else {\r\n    t = r = b = l = value;\r\n  }\r\n  return {\r\n    top: t,\r\n    right: r,\r\n    bottom: b,\r\n    left: l,\r\n    disabled: value === false\r\n  };\r\n}\r\nfunction getSortedDatasetIndices(chart, filterVisible) {\r\n  const keys = [];\r\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\r\n  let i, ilen;\r\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n    keys.push(metasets[i].index);\r\n  }\r\n  return keys;\r\n}\r\nfunction applyStack(stack, value, dsIndex, options = {}) {\r\n  const keys = stack.keys;\r\n  const singleMode = options.mode === 'single';\r\n  let i, ilen, datasetIndex, otherValue;\r\n  if (value === null) {\r\n    return;\r\n  }\r\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n    datasetIndex = +keys[i];\r\n    if (datasetIndex === dsIndex) {\r\n      if (options.all) {\r\n        continue;\r\n      }\r\n      break;\r\n    }\r\n    otherValue = stack.values[datasetIndex];\r\n    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\r\n      value += otherValue;\r\n    }\r\n  }\r\n  return value;\r\n}\r\nfunction convertObjectDataToArray(data) {\r\n  const keys = Object.keys(data);\r\n  const adata = new Array(keys.length);\r\n  let i, ilen, key;\r\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\r\n    key = keys[i];\r\n    adata[i] = {\r\n      x: key,\r\n      y: data[key]\r\n    };\r\n  }\r\n  return adata;\r\n}\r\nfunction isStacked(scale, meta) {\r\n  const stacked = scale && scale.options.stacked;\r\n  return stacked || (stacked === undefined && meta.stack !== undefined);\r\n}\r\nfunction getStackKey(indexScale, valueScale, meta) {\r\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\r\n}\r\nfunction getUserBounds(scale) {\r\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\r\n  return {\r\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\r\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\r\n  };\r\n}\r\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\r\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\r\n  return subStack[indexValue] || (subStack[indexValue] = {});\r\n}\r\nfunction getLastIndexInStack(stack, vScale, positive, type) {\r\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\r\n    const value = stack[meta.index];\r\n    if ((positive && value > 0) || (!positive && value < 0)) {\r\n      return meta.index;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction updateStacks(controller, parsed) {\r\n  const {chart, _cachedMeta: meta} = controller;\r\n  const stacks = chart._stacks || (chart._stacks = {});\r\n  const {iScale, vScale, index: datasetIndex} = meta;\r\n  const iAxis = iScale.axis;\r\n  const vAxis = vScale.axis;\r\n  const key = getStackKey(iScale, vScale, meta);\r\n  const ilen = parsed.length;\r\n  let stack;\r\n  for (let i = 0; i < ilen; ++i) {\r\n    const item = parsed[i];\r\n    const {[iAxis]: index, [vAxis]: value} = item;\r\n    const itemStacks = item._stacks || (item._stacks = {});\r\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\r\n    stack[datasetIndex] = value;\r\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\r\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\r\n  }\r\n}\r\nfunction getFirstScaleId(chart, axis) {\r\n  const scales = chart.scales;\r\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\r\n}\r\nfunction createDatasetContext(parent, index) {\r\n  return createContext(parent,\r\n    {\r\n      active: false,\r\n      dataset: undefined,\r\n      datasetIndex: index,\r\n      index,\r\n      mode: 'default',\r\n      type: 'dataset'\r\n    }\r\n  );\r\n}\r\nfunction createDataContext(parent, index, element) {\r\n  return createContext(parent, {\r\n    active: false,\r\n    dataIndex: index,\r\n    parsed: undefined,\r\n    raw: undefined,\r\n    element,\r\n    index,\r\n    mode: 'default',\r\n    type: 'data'\r\n  });\r\n}\r\nfunction clearStacks(meta, items) {\r\n  const datasetIndex = meta.controller.index;\r\n  const axis = meta.vScale && meta.vScale.axis;\r\n  if (!axis) {\r\n    return;\r\n  }\r\n  items = items || meta._parsed;\r\n  for (const parsed of items) {\r\n    const stacks = parsed._stacks;\r\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\r\n      return;\r\n    }\r\n    delete stacks[axis][datasetIndex];\r\n  }\r\n}\r\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\r\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\r\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\r\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\r\nclass DatasetController {\r\n  constructor(chart, datasetIndex) {\r\n    this.chart = chart;\r\n    this._ctx = chart.ctx;\r\n    this.index = datasetIndex;\r\n    this._cachedDataOpts = {};\r\n    this._cachedMeta = this.getMeta();\r\n    this._type = this._cachedMeta.type;\r\n    this.options = undefined;\r\n    this._parsing = false;\r\n    this._data = undefined;\r\n    this._objectData = undefined;\r\n    this._sharedOptions = undefined;\r\n    this._drawStart = undefined;\r\n    this._drawCount = undefined;\r\n    this.enableOptionSharing = false;\r\n    this.supportsDecimation = false;\r\n    this.$context = undefined;\r\n    this._syncList = [];\r\n    this.initialize();\r\n  }\r\n  initialize() {\r\n    const meta = this._cachedMeta;\r\n    this.configure();\r\n    this.linkScales();\r\n    meta._stacked = isStacked(meta.vScale, meta);\r\n    this.addElements();\r\n  }\r\n  updateIndex(datasetIndex) {\r\n    if (this.index !== datasetIndex) {\r\n      clearStacks(this._cachedMeta);\r\n    }\r\n    this.index = datasetIndex;\r\n  }\r\n  linkScales() {\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const dataset = this.getDataset();\r\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\r\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\r\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\r\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\r\n    const indexAxis = meta.indexAxis;\r\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\r\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\r\n    meta.xScale = this.getScaleForId(xid);\r\n    meta.yScale = this.getScaleForId(yid);\r\n    meta.rScale = this.getScaleForId(rid);\r\n    meta.iScale = this.getScaleForId(iid);\r\n    meta.vScale = this.getScaleForId(vid);\r\n  }\r\n  getDataset() {\r\n    return this.chart.data.datasets[this.index];\r\n  }\r\n  getMeta() {\r\n    return this.chart.getDatasetMeta(this.index);\r\n  }\r\n  getScaleForId(scaleID) {\r\n    return this.chart.scales[scaleID];\r\n  }\r\n  _getOtherScale(scale) {\r\n    const meta = this._cachedMeta;\r\n    return scale === meta.iScale\r\n      ? meta.vScale\r\n      : meta.iScale;\r\n  }\r\n  reset() {\r\n    this._update('reset');\r\n  }\r\n  _destroy() {\r\n    const meta = this._cachedMeta;\r\n    if (this._data) {\r\n      unlistenArrayEvents(this._data, this);\r\n    }\r\n    if (meta._stacked) {\r\n      clearStacks(meta);\r\n    }\r\n  }\r\n  _dataCheck() {\r\n    const dataset = this.getDataset();\r\n    const data = dataset.data || (dataset.data = []);\r\n    const _data = this._data;\r\n    if (isObject(data)) {\r\n      this._data = convertObjectDataToArray(data);\r\n    } else if (_data !== data) {\r\n      if (_data) {\r\n        unlistenArrayEvents(_data, this);\r\n        const meta = this._cachedMeta;\r\n        clearStacks(meta);\r\n        meta._parsed = [];\r\n      }\r\n      if (data && Object.isExtensible(data)) {\r\n        listenArrayEvents(data, this);\r\n      }\r\n      this._syncList = [];\r\n      this._data = data;\r\n    }\r\n  }\r\n  addElements() {\r\n    const meta = this._cachedMeta;\r\n    this._dataCheck();\r\n    if (this.datasetElementType) {\r\n      meta.dataset = new this.datasetElementType();\r\n    }\r\n  }\r\n  buildOrUpdateElements(resetNewElements) {\r\n    const meta = this._cachedMeta;\r\n    const dataset = this.getDataset();\r\n    let stackChanged = false;\r\n    this._dataCheck();\r\n    const oldStacked = meta._stacked;\r\n    meta._stacked = isStacked(meta.vScale, meta);\r\n    if (meta.stack !== dataset.stack) {\r\n      stackChanged = true;\r\n      clearStacks(meta);\r\n      meta.stack = dataset.stack;\r\n    }\r\n    this._resyncElements(resetNewElements);\r\n    if (stackChanged || oldStacked !== meta._stacked) {\r\n      updateStacks(this, meta._parsed);\r\n    }\r\n  }\r\n  configure() {\r\n    const config = this.chart.config;\r\n    const scopeKeys = config.datasetScopeKeys(this._type);\r\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\r\n    this.options = config.createResolver(scopes, this.getContext());\r\n    this._parsing = this.options.parsing;\r\n    this._cachedDataOpts = {};\r\n  }\r\n  parse(start, count) {\r\n    const {_cachedMeta: meta, _data: data} = this;\r\n    const {iScale, _stacked} = meta;\r\n    const iAxis = iScale.axis;\r\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\r\n    let prev = start > 0 && meta._parsed[start - 1];\r\n    let i, cur, parsed;\r\n    if (this._parsing === false) {\r\n      meta._parsed = data;\r\n      meta._sorted = true;\r\n      parsed = data;\r\n    } else {\r\n      if (isArray(data[start])) {\r\n        parsed = this.parseArrayData(meta, data, start, count);\r\n      } else if (isObject(data[start])) {\r\n        parsed = this.parseObjectData(meta, data, start, count);\r\n      } else {\r\n        parsed = this.parsePrimitiveData(meta, data, start, count);\r\n      }\r\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\r\n      for (i = 0; i < count; ++i) {\r\n        meta._parsed[i + start] = cur = parsed[i];\r\n        if (sorted) {\r\n          if (isNotInOrderComparedToPrev()) {\r\n            sorted = false;\r\n          }\r\n          prev = cur;\r\n        }\r\n      }\r\n      meta._sorted = sorted;\r\n    }\r\n    if (_stacked) {\r\n      updateStacks(this, parsed);\r\n    }\r\n  }\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    const {iScale, vScale} = meta;\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const labels = iScale.getLabels();\r\n    const singleScale = iScale === vScale;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index;\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      parsed[i] = {\r\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\r\n        [vAxis]: vScale.parse(data[index], index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n  parseArrayData(meta, data, start, count) {\r\n    const {xScale, yScale} = meta;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      item = data[index];\r\n      parsed[i] = {\r\n        x: xScale.parse(item[0], index),\r\n        y: yScale.parse(item[1], index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n  parseObjectData(meta, data, start, count) {\r\n    const {xScale, yScale} = meta;\r\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n    const parsed = new Array(count);\r\n    let i, ilen, index, item;\r\n    for (i = 0, ilen = count; i < ilen; ++i) {\r\n      index = i + start;\r\n      item = data[index];\r\n      parsed[i] = {\r\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\r\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\r\n      };\r\n    }\r\n    return parsed;\r\n  }\r\n  getParsed(index) {\r\n    return this._cachedMeta._parsed[index];\r\n  }\r\n  getDataElement(index) {\r\n    return this._cachedMeta.data[index];\r\n  }\r\n  applyStack(scale, parsed, mode) {\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const value = parsed[scale.axis];\r\n    const stack = {\r\n      keys: getSortedDatasetIndices(chart, true),\r\n      values: parsed._stacks[scale.axis]\r\n    };\r\n    return applyStack(stack, value, meta.index, {mode});\r\n  }\r\n  updateRangeFromParsed(range, scale, parsed, stack) {\r\n    const parsedValue = parsed[scale.axis];\r\n    let value = parsedValue === null ? NaN : parsedValue;\r\n    const values = stack && parsed._stacks[scale.axis];\r\n    if (stack && values) {\r\n      stack.values = values;\r\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\r\n    }\r\n    range.min = Math.min(range.min, value);\r\n    range.max = Math.max(range.max, value);\r\n  }\r\n  getMinMax(scale, canStack) {\r\n    const meta = this._cachedMeta;\r\n    const _parsed = meta._parsed;\r\n    const sorted = meta._sorted && scale === meta.iScale;\r\n    const ilen = _parsed.length;\r\n    const otherScale = this._getOtherScale(scale);\r\n    const stack = createStack(canStack, meta, this.chart);\r\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\r\n    let i, parsed;\r\n    function _skip() {\r\n      parsed = _parsed[i];\r\n      const otherValue = parsed[otherScale.axis];\r\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\r\n    }\r\n    for (i = 0; i < ilen; ++i) {\r\n      if (_skip()) {\r\n        continue;\r\n      }\r\n      this.updateRangeFromParsed(range, scale, parsed, stack);\r\n      if (sorted) {\r\n        break;\r\n      }\r\n    }\r\n    if (sorted) {\r\n      for (i = ilen - 1; i >= 0; --i) {\r\n        if (_skip()) {\r\n          continue;\r\n        }\r\n        this.updateRangeFromParsed(range, scale, parsed, stack);\r\n        break;\r\n      }\r\n    }\r\n    return range;\r\n  }\r\n  getAllParsedValues(scale) {\r\n    const parsed = this._cachedMeta._parsed;\r\n    const values = [];\r\n    let i, ilen, value;\r\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\r\n      value = parsed[i][scale.axis];\r\n      if (isNumberFinite(value)) {\r\n        values.push(value);\r\n      }\r\n    }\r\n    return values;\r\n  }\r\n  getMaxOverflow() {\r\n    return false;\r\n  }\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const vScale = meta.vScale;\r\n    const parsed = this.getParsed(index);\r\n    return {\r\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\r\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\r\n    };\r\n  }\r\n  _update(mode) {\r\n    const meta = this._cachedMeta;\r\n    this.update(mode || 'default');\r\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\r\n  }\r\n  update(mode) {}\r\n  draw() {\r\n    const ctx = this._ctx;\r\n    const chart = this.chart;\r\n    const meta = this._cachedMeta;\r\n    const elements = meta.data || [];\r\n    const area = chart.chartArea;\r\n    const active = [];\r\n    const start = this._drawStart || 0;\r\n    const count = this._drawCount || (elements.length - start);\r\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\r\n    let i;\r\n    if (meta.dataset) {\r\n      meta.dataset.draw(ctx, area, start, count);\r\n    }\r\n    for (i = start; i < start + count; ++i) {\r\n      const element = elements[i];\r\n      if (element.hidden) {\r\n        continue;\r\n      }\r\n      if (element.active && drawActiveElementsOnTop) {\r\n        active.push(element);\r\n      } else {\r\n        element.draw(ctx, area);\r\n      }\r\n    }\r\n    for (i = 0; i < active.length; ++i) {\r\n      active[i].draw(ctx, area);\r\n    }\r\n  }\r\n  getStyle(index, active) {\r\n    const mode = active ? 'active' : 'default';\r\n    return index === undefined && this._cachedMeta.dataset\r\n      ? this.resolveDatasetElementOptions(mode)\r\n      : this.resolveDataElementOptions(index || 0, mode);\r\n  }\r\n  getContext(index, active, mode) {\r\n    const dataset = this.getDataset();\r\n    let context;\r\n    if (index >= 0 && index < this._cachedMeta.data.length) {\r\n      const element = this._cachedMeta.data[index];\r\n      context = element.$context ||\r\n        (element.$context = createDataContext(this.getContext(), index, element));\r\n      context.parsed = this.getParsed(index);\r\n      context.raw = dataset.data[index];\r\n      context.index = context.dataIndex = index;\r\n    } else {\r\n      context = this.$context ||\r\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\r\n      context.dataset = dataset;\r\n      context.index = context.datasetIndex = this.index;\r\n    }\r\n    context.active = !!active;\r\n    context.mode = mode;\r\n    return context;\r\n  }\r\n  resolveDatasetElementOptions(mode) {\r\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\r\n  }\r\n  resolveDataElementOptions(index, mode) {\r\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\r\n  }\r\n  _resolveElementOptions(elementType, mode = 'default', index) {\r\n    const active = mode === 'active';\r\n    const cache = this._cachedDataOpts;\r\n    const cacheKey = elementType + '-' + mode;\r\n    const cached = cache[cacheKey];\r\n    const sharing = this.enableOptionSharing && defined(index);\r\n    if (cached) {\r\n      return cloneIfNotShared(cached, sharing);\r\n    }\r\n    const config = this.chart.config;\r\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\r\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\r\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n    const names = Object.keys(defaults.elements[elementType]);\r\n    const context = () => this.getContext(index, active);\r\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\r\n    if (values.$shared) {\r\n      values.$shared = sharing;\r\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\r\n    }\r\n    return values;\r\n  }\r\n  _resolveAnimations(index, transition, active) {\r\n    const chart = this.chart;\r\n    const cache = this._cachedDataOpts;\r\n    const cacheKey = `animation-${transition}`;\r\n    const cached = cache[cacheKey];\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    let options;\r\n    if (chart.options.animation !== false) {\r\n      const config = this.chart.config;\r\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\r\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\r\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\r\n    }\r\n    const animations = new Animations(chart, options && options.animations);\r\n    if (options && options._cacheable) {\r\n      cache[cacheKey] = Object.freeze(animations);\r\n    }\r\n    return animations;\r\n  }\r\n  getSharedOptions(options) {\r\n    if (!options.$shared) {\r\n      return;\r\n    }\r\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\r\n  }\r\n  includeOptions(mode, sharedOptions) {\r\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\r\n  }\r\n  updateElement(element, index, properties, mode) {\r\n    if (isDirectUpdateMode(mode)) {\r\n      Object.assign(element, properties);\r\n    } else {\r\n      this._resolveAnimations(index, mode).update(element, properties);\r\n    }\r\n  }\r\n  updateSharedOptions(sharedOptions, mode, newOptions) {\r\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\r\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\r\n    }\r\n  }\r\n  _setStyle(element, index, mode, active) {\r\n    element.active = active;\r\n    const options = this.getStyle(index, active);\r\n    this._resolveAnimations(index, mode, active).update(element, {\r\n      options: (!active && this.getSharedOptions(options)) || options\r\n    });\r\n  }\r\n  removeHoverStyle(element, datasetIndex, index) {\r\n    this._setStyle(element, index, 'active', false);\r\n  }\r\n  setHoverStyle(element, datasetIndex, index) {\r\n    this._setStyle(element, index, 'active', true);\r\n  }\r\n  _removeDatasetHoverStyle() {\r\n    const element = this._cachedMeta.dataset;\r\n    if (element) {\r\n      this._setStyle(element, undefined, 'active', false);\r\n    }\r\n  }\r\n  _setDatasetHoverStyle() {\r\n    const element = this._cachedMeta.dataset;\r\n    if (element) {\r\n      this._setStyle(element, undefined, 'active', true);\r\n    }\r\n  }\r\n  _resyncElements(resetNewElements) {\r\n    const data = this._data;\r\n    const elements = this._cachedMeta.data;\r\n    for (const [method, arg1, arg2] of this._syncList) {\r\n      this[method](arg1, arg2);\r\n    }\r\n    this._syncList = [];\r\n    const numMeta = elements.length;\r\n    const numData = data.length;\r\n    const count = Math.min(numData, numMeta);\r\n    if (count) {\r\n      this.parse(0, count);\r\n    }\r\n    if (numData > numMeta) {\r\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\r\n    } else if (numData < numMeta) {\r\n      this._removeElements(numData, numMeta - numData);\r\n    }\r\n  }\r\n  _insertElements(start, count, resetNewElements = true) {\r\n    const meta = this._cachedMeta;\r\n    const data = meta.data;\r\n    const end = start + count;\r\n    let i;\r\n    const move = (arr) => {\r\n      arr.length += count;\r\n      for (i = arr.length - 1; i >= end; i--) {\r\n        arr[i] = arr[i - count];\r\n      }\r\n    };\r\n    move(data);\r\n    for (i = start; i < end; ++i) {\r\n      data[i] = new this.dataElementType();\r\n    }\r\n    if (this._parsing) {\r\n      move(meta._parsed);\r\n    }\r\n    this.parse(start, count);\r\n    if (resetNewElements) {\r\n      this.updateElements(data, start, count, 'reset');\r\n    }\r\n  }\r\n  updateElements(element, start, count, mode) {}\r\n  _removeElements(start, count) {\r\n    const meta = this._cachedMeta;\r\n    if (this._parsing) {\r\n      const removed = meta._parsed.splice(start, count);\r\n      if (meta._stacked) {\r\n        clearStacks(meta, removed);\r\n      }\r\n    }\r\n    meta.data.splice(start, count);\r\n  }\r\n  _sync(args) {\r\n    if (this._parsing) {\r\n      this._syncList.push(args);\r\n    } else {\r\n      const [method, arg1, arg2] = args;\r\n      this[method](arg1, arg2);\r\n    }\r\n    this.chart._dataChanges.push([this.index, ...args]);\r\n  }\r\n  _onDataPush() {\r\n    const count = arguments.length;\r\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\r\n  }\r\n  _onDataPop() {\r\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\r\n  }\r\n  _onDataShift() {\r\n    this._sync(['_removeElements', 0, 1]);\r\n  }\r\n  _onDataSplice(start, count) {\r\n    if (count) {\r\n      this._sync(['_removeElements', start, count]);\r\n    }\r\n    const newCount = arguments.length - 2;\r\n    if (newCount) {\r\n      this._sync(['_insertElements', start, newCount]);\r\n    }\r\n  }\r\n  _onDataUnshift() {\r\n    this._sync(['_insertElements', 0, arguments.length]);\r\n  }\r\n}\r\nDatasetController.defaults = {};\r\nDatasetController.prototype.datasetElementType = null;\r\nDatasetController.prototype.dataElementType = null;\r\n\r\nclass Element {\r\n  constructor() {\r\n    this.x = undefined;\r\n    this.y = undefined;\r\n    this.active = false;\r\n    this.options = undefined;\r\n    this.$animations = undefined;\r\n  }\r\n  tooltipPosition(useFinalPosition) {\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return {x, y};\r\n  }\r\n  hasValue() {\r\n    return isNumber(this.x) && isNumber(this.y);\r\n  }\r\n  getProps(props, final) {\r\n    const anims = this.$animations;\r\n    if (!final || !anims) {\r\n      return this;\r\n    }\r\n    const ret = {};\r\n    props.forEach(prop => {\r\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\r\n    });\r\n    return ret;\r\n  }\r\n}\r\nElement.defaults = {};\r\nElement.defaultRoutes = undefined;\r\n\r\nconst formatters = {\r\n  values(value) {\r\n    return isArray(value) ? value : '' + value;\r\n  },\r\n  numeric(tickValue, index, ticks) {\r\n    if (tickValue === 0) {\r\n      return '0';\r\n    }\r\n    const locale = this.chart.options.locale;\r\n    let notation;\r\n    let delta = tickValue;\r\n    if (ticks.length > 1) {\r\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\r\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\r\n        notation = 'scientific';\r\n      }\r\n      delta = calculateDelta(tickValue, ticks);\r\n    }\r\n    const logDelta = log10(Math.abs(delta));\r\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\r\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\r\n    Object.assign(options, this.options.ticks.format);\r\n    return formatNumber(tickValue, locale, options);\r\n  },\r\n  logarithmic(tickValue, index, ticks) {\r\n    if (tickValue === 0) {\r\n      return '0';\r\n    }\r\n    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\r\n    if (remain === 1 || remain === 2 || remain === 5) {\r\n      return formatters.numeric.call(this, tickValue, index, ticks);\r\n    }\r\n    return '';\r\n  }\r\n};\r\nfunction calculateDelta(tickValue, ticks) {\r\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\r\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\r\n    delta = tickValue - Math.floor(tickValue);\r\n  }\r\n  return delta;\r\n}\r\nvar Ticks = {formatters};\r\n\r\ndefaults.set('scale', {\r\n  display: true,\r\n  offset: false,\r\n  reverse: false,\r\n  beginAtZero: false,\r\n  bounds: 'ticks',\r\n  grace: 0,\r\n  grid: {\r\n    display: true,\r\n    lineWidth: 1,\r\n    drawBorder: true,\r\n    drawOnChartArea: true,\r\n    drawTicks: true,\r\n    tickLength: 8,\r\n    tickWidth: (_ctx, options) => options.lineWidth,\r\n    tickColor: (_ctx, options) => options.color,\r\n    offset: false,\r\n    borderDash: [],\r\n    borderDashOffset: 0.0,\r\n    borderWidth: 1\r\n  },\r\n  title: {\r\n    display: false,\r\n    text: '',\r\n    padding: {\r\n      top: 4,\r\n      bottom: 4\r\n    }\r\n  },\r\n  ticks: {\r\n    minRotation: 0,\r\n    maxRotation: 50,\r\n    mirror: false,\r\n    textStrokeWidth: 0,\r\n    textStrokeColor: '',\r\n    padding: 3,\r\n    display: true,\r\n    autoSkip: true,\r\n    autoSkipPadding: 3,\r\n    labelOffset: 0,\r\n    callback: Ticks.formatters.values,\r\n    minor: {},\r\n    major: {},\r\n    align: 'center',\r\n    crossAlign: 'near',\r\n    showLabelBackdrop: false,\r\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\r\n    backdropPadding: 2,\r\n  }\r\n});\r\ndefaults.route('scale.ticks', 'color', '', 'color');\r\ndefaults.route('scale.grid', 'color', '', 'borderColor');\r\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\r\ndefaults.route('scale.title', 'color', '', 'color');\r\ndefaults.describe('scale', {\r\n  _fallback: false,\r\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\r\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\r\n});\r\ndefaults.describe('scales', {\r\n  _fallback: 'scale',\r\n});\r\ndefaults.describe('scale.ticks', {\r\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\r\n  _indexable: (name) => name !== 'backdropPadding',\r\n});\r\n\r\nfunction autoSkip(scale, ticks) {\r\n  const tickOpts = scale.options.ticks;\r\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\r\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\r\n  const numMajorIndices = majorIndices.length;\r\n  const first = majorIndices[0];\r\n  const last = majorIndices[numMajorIndices - 1];\r\n  const newTicks = [];\r\n  if (numMajorIndices > ticksLimit) {\r\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\r\n    return newTicks;\r\n  }\r\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\r\n  if (numMajorIndices > 0) {\r\n    let i, ilen;\r\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\r\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\r\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\r\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\r\n    }\r\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\r\n    return newTicks;\r\n  }\r\n  skip(ticks, newTicks, spacing);\r\n  return newTicks;\r\n}\r\nfunction determineMaxTicks(scale) {\r\n  const offset = scale.options.offset;\r\n  const tickLength = scale._tickSize();\r\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\r\n  const maxChart = scale._maxLength / tickLength;\r\n  return Math.floor(Math.min(maxScale, maxChart));\r\n}\r\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\r\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\r\n  const spacing = ticks.length / ticksLimit;\r\n  if (!evenMajorSpacing) {\r\n    return Math.max(spacing, 1);\r\n  }\r\n  const factors = _factorize(evenMajorSpacing);\r\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\r\n    const factor = factors[i];\r\n    if (factor > spacing) {\r\n      return factor;\r\n    }\r\n  }\r\n  return Math.max(spacing, 1);\r\n}\r\nfunction getMajorIndices(ticks) {\r\n  const result = [];\r\n  let i, ilen;\r\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n    if (ticks[i].major) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\r\n  let count = 0;\r\n  let next = majorIndices[0];\r\n  let i;\r\n  spacing = Math.ceil(spacing);\r\n  for (i = 0; i < ticks.length; i++) {\r\n    if (i === next) {\r\n      newTicks.push(ticks[i]);\r\n      count++;\r\n      next = majorIndices[count * spacing];\r\n    }\r\n  }\r\n}\r\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\r\n  const start = valueOrDefault(majorStart, 0);\r\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\r\n  let count = 0;\r\n  let length, i, next;\r\n  spacing = Math.ceil(spacing);\r\n  if (majorEnd) {\r\n    length = majorEnd - majorStart;\r\n    spacing = length / Math.floor(length / spacing);\r\n  }\r\n  next = start;\r\n  while (next < 0) {\r\n    count++;\r\n    next = Math.round(start + count * spacing);\r\n  }\r\n  for (i = Math.max(start, 0); i < end; i++) {\r\n    if (i === next) {\r\n      newTicks.push(ticks[i]);\r\n      count++;\r\n      next = Math.round(start + count * spacing);\r\n    }\r\n  }\r\n}\r\nfunction getEvenSpacing(arr) {\r\n  const len = arr.length;\r\n  let i, diff;\r\n  if (len < 2) {\r\n    return false;\r\n  }\r\n  for (diff = arr[0], i = 1; i < len; ++i) {\r\n    if (arr[i] - arr[i - 1] !== diff) {\r\n      return false;\r\n    }\r\n  }\r\n  return diff;\r\n}\r\n\r\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\r\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\r\nfunction sample(arr, numItems) {\r\n  const result = [];\r\n  const increment = arr.length / numItems;\r\n  const len = arr.length;\r\n  let i = 0;\r\n  for (; i < len; i += increment) {\r\n    result.push(arr[Math.floor(i)]);\r\n  }\r\n  return result;\r\n}\r\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\r\n  const length = scale.ticks.length;\r\n  const validIndex = Math.min(index, length - 1);\r\n  const start = scale._startPixel;\r\n  const end = scale._endPixel;\r\n  const epsilon = 1e-6;\r\n  let lineValue = scale.getPixelForTick(validIndex);\r\n  let offset;\r\n  if (offsetGridLines) {\r\n    if (length === 1) {\r\n      offset = Math.max(lineValue - start, end - lineValue);\r\n    } else if (index === 0) {\r\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\r\n    } else {\r\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\r\n    }\r\n    lineValue += validIndex < index ? offset : -offset;\r\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\r\n      return;\r\n    }\r\n  }\r\n  return lineValue;\r\n}\r\nfunction garbageCollect(caches, length) {\r\n  each(caches, (cache) => {\r\n    const gc = cache.gc;\r\n    const gcLen = gc.length / 2;\r\n    let i;\r\n    if (gcLen > length) {\r\n      for (i = 0; i < gcLen; ++i) {\r\n        delete cache.data[gc[i]];\r\n      }\r\n      gc.splice(0, gcLen);\r\n    }\r\n  });\r\n}\r\nfunction getTickMarkLength(options) {\r\n  return options.drawTicks ? options.tickLength : 0;\r\n}\r\nfunction getTitleHeight(options, fallback) {\r\n  if (!options.display) {\r\n    return 0;\r\n  }\r\n  const font = toFont(options.font, fallback);\r\n  const padding = toPadding(options.padding);\r\n  const lines = isArray(options.text) ? options.text.length : 1;\r\n  return (lines * font.lineHeight) + padding.height;\r\n}\r\nfunction createScaleContext(parent, scale) {\r\n  return createContext(parent, {\r\n    scale,\r\n    type: 'scale'\r\n  });\r\n}\r\nfunction createTickContext(parent, index, tick) {\r\n  return createContext(parent, {\r\n    tick,\r\n    index,\r\n    type: 'tick'\r\n  });\r\n}\r\nfunction titleAlign(align, position, reverse) {\r\n  let ret = _toLeftRightCenter(align);\r\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\r\n    ret = reverseAlign(ret);\r\n  }\r\n  return ret;\r\n}\r\nfunction titleArgs(scale, offset, position, align) {\r\n  const {top, left, bottom, right, chart} = scale;\r\n  const {chartArea, scales} = chart;\r\n  let rotation = 0;\r\n  let maxWidth, titleX, titleY;\r\n  const height = bottom - top;\r\n  const width = right - left;\r\n  if (scale.isHorizontal()) {\r\n    titleX = _alignStartEnd(align, left, right);\r\n    if (isObject(position)) {\r\n      const positionAxisID = Object.keys(position)[0];\r\n      const value = position[positionAxisID];\r\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\r\n    } else if (position === 'center') {\r\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\r\n    } else {\r\n      titleY = offsetFromEdge(scale, position, offset);\r\n    }\r\n    maxWidth = right - left;\r\n  } else {\r\n    if (isObject(position)) {\r\n      const positionAxisID = Object.keys(position)[0];\r\n      const value = position[positionAxisID];\r\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\r\n    } else if (position === 'center') {\r\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\r\n    } else {\r\n      titleX = offsetFromEdge(scale, position, offset);\r\n    }\r\n    titleY = _alignStartEnd(align, bottom, top);\r\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\r\n  }\r\n  return {titleX, titleY, maxWidth, rotation};\r\n}\r\nclass Scale extends Element {\r\n  constructor(cfg) {\r\n    super();\r\n    this.id = cfg.id;\r\n    this.type = cfg.type;\r\n    this.options = undefined;\r\n    this.ctx = cfg.ctx;\r\n    this.chart = cfg.chart;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this._margins = {\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    };\r\n    this.maxWidth = undefined;\r\n    this.maxHeight = undefined;\r\n    this.paddingTop = undefined;\r\n    this.paddingBottom = undefined;\r\n    this.paddingLeft = undefined;\r\n    this.paddingRight = undefined;\r\n    this.axis = undefined;\r\n    this.labelRotation = undefined;\r\n    this.min = undefined;\r\n    this.max = undefined;\r\n    this._range = undefined;\r\n    this.ticks = [];\r\n    this._gridLineItems = null;\r\n    this._labelItems = null;\r\n    this._labelSizes = null;\r\n    this._length = 0;\r\n    this._maxLength = 0;\r\n    this._longestTextCache = {};\r\n    this._startPixel = undefined;\r\n    this._endPixel = undefined;\r\n    this._reversePixels = false;\r\n    this._userMax = undefined;\r\n    this._userMin = undefined;\r\n    this._suggestedMax = undefined;\r\n    this._suggestedMin = undefined;\r\n    this._ticksLength = 0;\r\n    this._borderValue = 0;\r\n    this._cache = {};\r\n    this._dataLimitsCached = false;\r\n    this.$context = undefined;\r\n  }\r\n  init(options) {\r\n    this.options = options.setContext(this.getContext());\r\n    this.axis = options.axis;\r\n    this._userMin = this.parse(options.min);\r\n    this._userMax = this.parse(options.max);\r\n    this._suggestedMin = this.parse(options.suggestedMin);\r\n    this._suggestedMax = this.parse(options.suggestedMax);\r\n  }\r\n  parse(raw, index) {\r\n    return raw;\r\n  }\r\n  getUserBounds() {\r\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\r\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\r\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\r\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\r\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\r\n    return {\r\n      min: finiteOrDefault(_userMin, _suggestedMin),\r\n      max: finiteOrDefault(_userMax, _suggestedMax),\r\n      minDefined: isNumberFinite(_userMin),\r\n      maxDefined: isNumberFinite(_userMax)\r\n    };\r\n  }\r\n  getMinMax(canStack) {\r\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\r\n    let range;\r\n    if (minDefined && maxDefined) {\r\n      return {min, max};\r\n    }\r\n    const metas = this.getMatchingVisibleMetas();\r\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      range = metas[i].controller.getMinMax(this, canStack);\r\n      if (!minDefined) {\r\n        min = Math.min(min, range.min);\r\n      }\r\n      if (!maxDefined) {\r\n        max = Math.max(max, range.max);\r\n      }\r\n    }\r\n    min = maxDefined && min > max ? max : min;\r\n    max = minDefined && min > max ? min : max;\r\n    return {\r\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\r\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\r\n    };\r\n  }\r\n  getPadding() {\r\n    return {\r\n      left: this.paddingLeft || 0,\r\n      top: this.paddingTop || 0,\r\n      right: this.paddingRight || 0,\r\n      bottom: this.paddingBottom || 0\r\n    };\r\n  }\r\n  getTicks() {\r\n    return this.ticks;\r\n  }\r\n  getLabels() {\r\n    const data = this.chart.data;\r\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\r\n  }\r\n  beforeLayout() {\r\n    this._cache = {};\r\n    this._dataLimitsCached = false;\r\n  }\r\n  beforeUpdate() {\r\n    callback(this.options.beforeUpdate, [this]);\r\n  }\r\n  update(maxWidth, maxHeight, margins) {\r\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\r\n    const sampleSize = tickOpts.sampleSize;\r\n    this.beforeUpdate();\r\n    this.maxWidth = maxWidth;\r\n    this.maxHeight = maxHeight;\r\n    this._margins = margins = Object.assign({\r\n      left: 0,\r\n      right: 0,\r\n      top: 0,\r\n      bottom: 0\r\n    }, margins);\r\n    this.ticks = null;\r\n    this._labelSizes = null;\r\n    this._gridLineItems = null;\r\n    this._labelItems = null;\r\n    this.beforeSetDimensions();\r\n    this.setDimensions();\r\n    this.afterSetDimensions();\r\n    this._maxLength = this.isHorizontal()\r\n      ? this.width + margins.left + margins.right\r\n      : this.height + margins.top + margins.bottom;\r\n    if (!this._dataLimitsCached) {\r\n      this.beforeDataLimits();\r\n      this.determineDataLimits();\r\n      this.afterDataLimits();\r\n      this._range = _addGrace(this, grace, beginAtZero);\r\n      this._dataLimitsCached = true;\r\n    }\r\n    this.beforeBuildTicks();\r\n    this.ticks = this.buildTicks() || [];\r\n    this.afterBuildTicks();\r\n    const samplingEnabled = sampleSize < this.ticks.length;\r\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\r\n    this.configure();\r\n    this.beforeCalculateLabelRotation();\r\n    this.calculateLabelRotation();\r\n    this.afterCalculateLabelRotation();\r\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\r\n      this.ticks = autoSkip(this, this.ticks);\r\n      this._labelSizes = null;\r\n      this.afterAutoSkip();\r\n    }\r\n    if (samplingEnabled) {\r\n      this._convertTicksToLabels(this.ticks);\r\n    }\r\n    this.beforeFit();\r\n    this.fit();\r\n    this.afterFit();\r\n    this.afterUpdate();\r\n  }\r\n  configure() {\r\n    let reversePixels = this.options.reverse;\r\n    let startPixel, endPixel;\r\n    if (this.isHorizontal()) {\r\n      startPixel = this.left;\r\n      endPixel = this.right;\r\n    } else {\r\n      startPixel = this.top;\r\n      endPixel = this.bottom;\r\n      reversePixels = !reversePixels;\r\n    }\r\n    this._startPixel = startPixel;\r\n    this._endPixel = endPixel;\r\n    this._reversePixels = reversePixels;\r\n    this._length = endPixel - startPixel;\r\n    this._alignToPixels = this.options.alignToPixels;\r\n  }\r\n  afterUpdate() {\r\n    callback(this.options.afterUpdate, [this]);\r\n  }\r\n  beforeSetDimensions() {\r\n    callback(this.options.beforeSetDimensions, [this]);\r\n  }\r\n  setDimensions() {\r\n    if (this.isHorizontal()) {\r\n      this.width = this.maxWidth;\r\n      this.left = 0;\r\n      this.right = this.width;\r\n    } else {\r\n      this.height = this.maxHeight;\r\n      this.top = 0;\r\n      this.bottom = this.height;\r\n    }\r\n    this.paddingLeft = 0;\r\n    this.paddingTop = 0;\r\n    this.paddingRight = 0;\r\n    this.paddingBottom = 0;\r\n  }\r\n  afterSetDimensions() {\r\n    callback(this.options.afterSetDimensions, [this]);\r\n  }\r\n  _callHooks(name) {\r\n    this.chart.notifyPlugins(name, this.getContext());\r\n    callback(this.options[name], [this]);\r\n  }\r\n  beforeDataLimits() {\r\n    this._callHooks('beforeDataLimits');\r\n  }\r\n  determineDataLimits() {}\r\n  afterDataLimits() {\r\n    this._callHooks('afterDataLimits');\r\n  }\r\n  beforeBuildTicks() {\r\n    this._callHooks('beforeBuildTicks');\r\n  }\r\n  buildTicks() {\r\n    return [];\r\n  }\r\n  afterBuildTicks() {\r\n    this._callHooks('afterBuildTicks');\r\n  }\r\n  beforeTickToLabelConversion() {\r\n    callback(this.options.beforeTickToLabelConversion, [this]);\r\n  }\r\n  generateTickLabels(ticks) {\r\n    const tickOpts = this.options.ticks;\r\n    let i, ilen, tick;\r\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n      tick = ticks[i];\r\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\r\n    }\r\n  }\r\n  afterTickToLabelConversion() {\r\n    callback(this.options.afterTickToLabelConversion, [this]);\r\n  }\r\n  beforeCalculateLabelRotation() {\r\n    callback(this.options.beforeCalculateLabelRotation, [this]);\r\n  }\r\n  calculateLabelRotation() {\r\n    const options = this.options;\r\n    const tickOpts = options.ticks;\r\n    const numTicks = this.ticks.length;\r\n    const minRotation = tickOpts.minRotation || 0;\r\n    const maxRotation = tickOpts.maxRotation;\r\n    let labelRotation = minRotation;\r\n    let tickWidth, maxHeight, maxLabelDiagonal;\r\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\r\n      this.labelRotation = minRotation;\r\n      return;\r\n    }\r\n    const labelSizes = this._getLabelSizes();\r\n    const maxLabelWidth = labelSizes.widest.width;\r\n    const maxLabelHeight = labelSizes.highest.height;\r\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\r\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\r\n    if (maxLabelWidth + 6 > tickWidth) {\r\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\r\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\r\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\r\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\r\n      labelRotation = toDegrees(Math.min(\r\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\r\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\r\n      ));\r\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\r\n    }\r\n    this.labelRotation = labelRotation;\r\n  }\r\n  afterCalculateLabelRotation() {\r\n    callback(this.options.afterCalculateLabelRotation, [this]);\r\n  }\r\n  afterAutoSkip() {}\r\n  beforeFit() {\r\n    callback(this.options.beforeFit, [this]);\r\n  }\r\n  fit() {\r\n    const minSize = {\r\n      width: 0,\r\n      height: 0\r\n    };\r\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\r\n    const display = this._isVisible();\r\n    const isHorizontal = this.isHorizontal();\r\n    if (display) {\r\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\r\n      if (isHorizontal) {\r\n        minSize.width = this.maxWidth;\r\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\r\n      } else {\r\n        minSize.height = this.maxHeight;\r\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\r\n      }\r\n      if (tickOpts.display && this.ticks.length) {\r\n        const {first, last, widest, highest} = this._getLabelSizes();\r\n        const tickPadding = tickOpts.padding * 2;\r\n        const angleRadians = toRadians(this.labelRotation);\r\n        const cos = Math.cos(angleRadians);\r\n        const sin = Math.sin(angleRadians);\r\n        if (isHorizontal) {\r\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\r\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\r\n        } else {\r\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\r\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\r\n        }\r\n        this._calculatePadding(first, last, sin, cos);\r\n      }\r\n    }\r\n    this._handleMargins();\r\n    if (isHorizontal) {\r\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\r\n      this.height = minSize.height;\r\n    } else {\r\n      this.width = minSize.width;\r\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\r\n    }\r\n  }\r\n  _calculatePadding(first, last, sin, cos) {\r\n    const {ticks: {align, padding}, position} = this.options;\r\n    const isRotated = this.labelRotation !== 0;\r\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\r\n    if (this.isHorizontal()) {\r\n      const offsetLeft = this.getPixelForTick(0) - this.left;\r\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\r\n      let paddingLeft = 0;\r\n      let paddingRight = 0;\r\n      if (isRotated) {\r\n        if (labelsBelowTicks) {\r\n          paddingLeft = cos * first.width;\r\n          paddingRight = sin * last.height;\r\n        } else {\r\n          paddingLeft = sin * first.height;\r\n          paddingRight = cos * last.width;\r\n        }\r\n      } else if (align === 'start') {\r\n        paddingRight = last.width;\r\n      } else if (align === 'end') {\r\n        paddingLeft = first.width;\r\n      } else if (align !== 'inner') {\r\n        paddingLeft = first.width / 2;\r\n        paddingRight = last.width / 2;\r\n      }\r\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\r\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\r\n    } else {\r\n      let paddingTop = last.height / 2;\r\n      let paddingBottom = first.height / 2;\r\n      if (align === 'start') {\r\n        paddingTop = 0;\r\n        paddingBottom = first.height;\r\n      } else if (align === 'end') {\r\n        paddingTop = last.height;\r\n        paddingBottom = 0;\r\n      }\r\n      this.paddingTop = paddingTop + padding;\r\n      this.paddingBottom = paddingBottom + padding;\r\n    }\r\n  }\r\n  _handleMargins() {\r\n    if (this._margins) {\r\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\r\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\r\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\r\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\r\n    }\r\n  }\r\n  afterFit() {\r\n    callback(this.options.afterFit, [this]);\r\n  }\r\n  isHorizontal() {\r\n    const {axis, position} = this.options;\r\n    return position === 'top' || position === 'bottom' || axis === 'x';\r\n  }\r\n  isFullSize() {\r\n    return this.options.fullSize;\r\n  }\r\n  _convertTicksToLabels(ticks) {\r\n    this.beforeTickToLabelConversion();\r\n    this.generateTickLabels(ticks);\r\n    let i, ilen;\r\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\r\n      if (isNullOrUndef(ticks[i].label)) {\r\n        ticks.splice(i, 1);\r\n        ilen--;\r\n        i--;\r\n      }\r\n    }\r\n    this.afterTickToLabelConversion();\r\n  }\r\n  _getLabelSizes() {\r\n    let labelSizes = this._labelSizes;\r\n    if (!labelSizes) {\r\n      const sampleSize = this.options.ticks.sampleSize;\r\n      let ticks = this.ticks;\r\n      if (sampleSize < ticks.length) {\r\n        ticks = sample(ticks, sampleSize);\r\n      }\r\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\r\n    }\r\n    return labelSizes;\r\n  }\r\n  _computeLabelSizes(ticks, length) {\r\n    const {ctx, _longestTextCache: caches} = this;\r\n    const widths = [];\r\n    const heights = [];\r\n    let widestLabelSize = 0;\r\n    let highestLabelSize = 0;\r\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\r\n    for (i = 0; i < length; ++i) {\r\n      label = ticks[i].label;\r\n      tickFont = this._resolveTickFontOptions(i);\r\n      ctx.font = fontString = tickFont.string;\r\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\r\n      lineHeight = tickFont.lineHeight;\r\n      width = height = 0;\r\n      if (!isNullOrUndef(label) && !isArray(label)) {\r\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\r\n        height = lineHeight;\r\n      } else if (isArray(label)) {\r\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\r\n          nestedLabel = label[j];\r\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\r\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\r\n            height += lineHeight;\r\n          }\r\n        }\r\n      }\r\n      widths.push(width);\r\n      heights.push(height);\r\n      widestLabelSize = Math.max(width, widestLabelSize);\r\n      highestLabelSize = Math.max(height, highestLabelSize);\r\n    }\r\n    garbageCollect(caches, length);\r\n    const widest = widths.indexOf(widestLabelSize);\r\n    const highest = heights.indexOf(highestLabelSize);\r\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\r\n    return {\r\n      first: valueAt(0),\r\n      last: valueAt(length - 1),\r\n      widest: valueAt(widest),\r\n      highest: valueAt(highest),\r\n      widths,\r\n      heights,\r\n    };\r\n  }\r\n  getLabelForValue(value) {\r\n    return value;\r\n  }\r\n  getPixelForValue(value, index) {\r\n    return NaN;\r\n  }\r\n  getValueForPixel(pixel) {}\r\n  getPixelForTick(index) {\r\n    const ticks = this.ticks;\r\n    if (index < 0 || index > ticks.length - 1) {\r\n      return null;\r\n    }\r\n    return this.getPixelForValue(ticks[index].value);\r\n  }\r\n  getPixelForDecimal(decimal) {\r\n    if (this._reversePixels) {\r\n      decimal = 1 - decimal;\r\n    }\r\n    const pixel = this._startPixel + decimal * this._length;\r\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\r\n  }\r\n  getDecimalForPixel(pixel) {\r\n    const decimal = (pixel - this._startPixel) / this._length;\r\n    return this._reversePixels ? 1 - decimal : decimal;\r\n  }\r\n  getBasePixel() {\r\n    return this.getPixelForValue(this.getBaseValue());\r\n  }\r\n  getBaseValue() {\r\n    const {min, max} = this;\r\n    return min < 0 && max < 0 ? max :\r\n      min > 0 && max > 0 ? min :\r\n      0;\r\n  }\r\n  getContext(index) {\r\n    const ticks = this.ticks || [];\r\n    if (index >= 0 && index < ticks.length) {\r\n      const tick = ticks[index];\r\n      return tick.$context ||\r\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\r\n    }\r\n    return this.$context ||\r\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\r\n  }\r\n  _tickSize() {\r\n    const optionTicks = this.options.ticks;\r\n    const rot = toRadians(this.labelRotation);\r\n    const cos = Math.abs(Math.cos(rot));\r\n    const sin = Math.abs(Math.sin(rot));\r\n    const labelSizes = this._getLabelSizes();\r\n    const padding = optionTicks.autoSkipPadding || 0;\r\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\r\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\r\n    return this.isHorizontal()\r\n      ? h * cos > w * sin ? w / cos : h / sin\r\n      : h * sin < w * cos ? h / cos : w / sin;\r\n  }\r\n  _isVisible() {\r\n    const display = this.options.display;\r\n    if (display !== 'auto') {\r\n      return !!display;\r\n    }\r\n    return this.getMatchingVisibleMetas().length > 0;\r\n  }\r\n  _computeGridLineItems(chartArea) {\r\n    const axis = this.axis;\r\n    const chart = this.chart;\r\n    const options = this.options;\r\n    const {grid, position} = options;\r\n    const offset = grid.offset;\r\n    const isHorizontal = this.isHorizontal();\r\n    const ticks = this.ticks;\r\n    const ticksLength = ticks.length + (offset ? 1 : 0);\r\n    const tl = getTickMarkLength(grid);\r\n    const items = [];\r\n    const borderOpts = grid.setContext(this.getContext());\r\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\r\n    const axisHalfWidth = axisWidth / 2;\r\n    const alignBorderValue = function(pixel) {\r\n      return _alignPixel(chart, pixel, axisWidth);\r\n    };\r\n    let borderValue, i, lineValue, alignedLineValue;\r\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\r\n    if (position === 'top') {\r\n      borderValue = alignBorderValue(this.bottom);\r\n      ty1 = this.bottom - tl;\r\n      ty2 = borderValue - axisHalfWidth;\r\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\r\n      y2 = chartArea.bottom;\r\n    } else if (position === 'bottom') {\r\n      borderValue = alignBorderValue(this.top);\r\n      y1 = chartArea.top;\r\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\r\n      ty1 = borderValue + axisHalfWidth;\r\n      ty2 = this.top + tl;\r\n    } else if (position === 'left') {\r\n      borderValue = alignBorderValue(this.right);\r\n      tx1 = this.right - tl;\r\n      tx2 = borderValue - axisHalfWidth;\r\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\r\n      x2 = chartArea.right;\r\n    } else if (position === 'right') {\r\n      borderValue = alignBorderValue(this.left);\r\n      x1 = chartArea.left;\r\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\r\n      tx1 = borderValue + axisHalfWidth;\r\n      tx2 = this.left + tl;\r\n    } else if (axis === 'x') {\r\n      if (position === 'center') {\r\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n      }\r\n      y1 = chartArea.top;\r\n      y2 = chartArea.bottom;\r\n      ty1 = borderValue + axisHalfWidth;\r\n      ty2 = ty1 + tl;\r\n    } else if (axis === 'y') {\r\n      if (position === 'center') {\r\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\r\n      }\r\n      tx1 = borderValue - axisHalfWidth;\r\n      tx2 = tx1 - tl;\r\n      x1 = chartArea.left;\r\n      x2 = chartArea.right;\r\n    }\r\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\r\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\r\n    for (i = 0; i < ticksLength; i += step) {\r\n      const optsAtIndex = grid.setContext(this.getContext(i));\r\n      const lineWidth = optsAtIndex.lineWidth;\r\n      const lineColor = optsAtIndex.color;\r\n      const borderDash = grid.borderDash || [];\r\n      const borderDashOffset = optsAtIndex.borderDashOffset;\r\n      const tickWidth = optsAtIndex.tickWidth;\r\n      const tickColor = optsAtIndex.tickColor;\r\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\r\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\r\n      lineValue = getPixelForGridLine(this, i, offset);\r\n      if (lineValue === undefined) {\r\n        continue;\r\n      }\r\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\r\n      if (isHorizontal) {\r\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\r\n      } else {\r\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\r\n      }\r\n      items.push({\r\n        tx1,\r\n        ty1,\r\n        tx2,\r\n        ty2,\r\n        x1,\r\n        y1,\r\n        x2,\r\n        y2,\r\n        width: lineWidth,\r\n        color: lineColor,\r\n        borderDash,\r\n        borderDashOffset,\r\n        tickWidth,\r\n        tickColor,\r\n        tickBorderDash,\r\n        tickBorderDashOffset,\r\n      });\r\n    }\r\n    this._ticksLength = ticksLength;\r\n    this._borderValue = borderValue;\r\n    return items;\r\n  }\r\n  _computeLabelItems(chartArea) {\r\n    const axis = this.axis;\r\n    const options = this.options;\r\n    const {position, ticks: optionTicks} = options;\r\n    const isHorizontal = this.isHorizontal();\r\n    const ticks = this.ticks;\r\n    const {align, crossAlign, padding, mirror} = optionTicks;\r\n    const tl = getTickMarkLength(options.grid);\r\n    const tickAndPadding = tl + padding;\r\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\r\n    const rotation = -toRadians(this.labelRotation);\r\n    const items = [];\r\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\r\n    let textBaseline = 'middle';\r\n    if (position === 'top') {\r\n      y = this.bottom - hTickAndPadding;\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (position === 'bottom') {\r\n      y = this.top + hTickAndPadding;\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (position === 'left') {\r\n      const ret = this._getYAxisLabelAlignment(tl);\r\n      textAlign = ret.textAlign;\r\n      x = ret.x;\r\n    } else if (position === 'right') {\r\n      const ret = this._getYAxisLabelAlignment(tl);\r\n      textAlign = ret.textAlign;\r\n      x = ret.x;\r\n    } else if (axis === 'x') {\r\n      if (position === 'center') {\r\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\r\n      }\r\n      textAlign = this._getXAxisLabelAlignment();\r\n    } else if (axis === 'y') {\r\n      if (position === 'center') {\r\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\r\n      } else if (isObject(position)) {\r\n        const positionAxisID = Object.keys(position)[0];\r\n        const value = position[positionAxisID];\r\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\r\n      }\r\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\r\n    }\r\n    if (axis === 'y') {\r\n      if (align === 'start') {\r\n        textBaseline = 'top';\r\n      } else if (align === 'end') {\r\n        textBaseline = 'bottom';\r\n      }\r\n    }\r\n    const labelSizes = this._getLabelSizes();\r\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n      tick = ticks[i];\r\n      label = tick.label;\r\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\r\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\r\n      font = this._resolveTickFontOptions(i);\r\n      lineHeight = font.lineHeight;\r\n      lineCount = isArray(label) ? label.length : 1;\r\n      const halfCount = lineCount / 2;\r\n      const color = optsAtIndex.color;\r\n      const strokeColor = optsAtIndex.textStrokeColor;\r\n      const strokeWidth = optsAtIndex.textStrokeWidth;\r\n      let tickTextAlign = textAlign;\r\n      if (isHorizontal) {\r\n        x = pixel;\r\n        if (textAlign === 'inner') {\r\n          if (i === ilen - 1) {\r\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\r\n          } else if (i === 0) {\r\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\r\n          } else {\r\n            tickTextAlign = 'center';\r\n          }\r\n        }\r\n        if (position === 'top') {\r\n          if (crossAlign === 'near' || rotation !== 0) {\r\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\r\n          } else if (crossAlign === 'center') {\r\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\r\n          } else {\r\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\r\n          }\r\n        } else {\r\n          if (crossAlign === 'near' || rotation !== 0) {\r\n            textOffset = lineHeight / 2;\r\n          } else if (crossAlign === 'center') {\r\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\r\n          } else {\r\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\r\n          }\r\n        }\r\n        if (mirror) {\r\n          textOffset *= -1;\r\n        }\r\n      } else {\r\n        y = pixel;\r\n        textOffset = (1 - lineCount) * lineHeight / 2;\r\n      }\r\n      let backdrop;\r\n      if (optsAtIndex.showLabelBackdrop) {\r\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\r\n        const height = labelSizes.heights[i];\r\n        const width = labelSizes.widths[i];\r\n        let top = y + textOffset - labelPadding.top;\r\n        let left = x - labelPadding.left;\r\n        switch (textBaseline) {\r\n        case 'middle':\r\n          top -= height / 2;\r\n          break;\r\n        case 'bottom':\r\n          top -= height;\r\n          break;\r\n        }\r\n        switch (textAlign) {\r\n        case 'center':\r\n          left -= width / 2;\r\n          break;\r\n        case 'right':\r\n          left -= width;\r\n          break;\r\n        }\r\n        backdrop = {\r\n          left,\r\n          top,\r\n          width: width + labelPadding.width,\r\n          height: height + labelPadding.height,\r\n          color: optsAtIndex.backdropColor,\r\n        };\r\n      }\r\n      items.push({\r\n        rotation,\r\n        label,\r\n        font,\r\n        color,\r\n        strokeColor,\r\n        strokeWidth,\r\n        textOffset,\r\n        textAlign: tickTextAlign,\r\n        textBaseline,\r\n        translation: [x, y],\r\n        backdrop,\r\n      });\r\n    }\r\n    return items;\r\n  }\r\n  _getXAxisLabelAlignment() {\r\n    const {position, ticks} = this.options;\r\n    const rotation = -toRadians(this.labelRotation);\r\n    if (rotation) {\r\n      return position === 'top' ? 'left' : 'right';\r\n    }\r\n    let align = 'center';\r\n    if (ticks.align === 'start') {\r\n      align = 'left';\r\n    } else if (ticks.align === 'end') {\r\n      align = 'right';\r\n    } else if (ticks.align === 'inner') {\r\n      align = 'inner';\r\n    }\r\n    return align;\r\n  }\r\n  _getYAxisLabelAlignment(tl) {\r\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\r\n    const labelSizes = this._getLabelSizes();\r\n    const tickAndPadding = tl + padding;\r\n    const widest = labelSizes.widest.width;\r\n    let textAlign;\r\n    let x;\r\n    if (position === 'left') {\r\n      if (mirror) {\r\n        x = this.right + padding;\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'left';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x += (widest / 2);\r\n        } else {\r\n          textAlign = 'right';\r\n          x += widest;\r\n        }\r\n      } else {\r\n        x = this.right - tickAndPadding;\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'right';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x -= (widest / 2);\r\n        } else {\r\n          textAlign = 'left';\r\n          x = this.left;\r\n        }\r\n      }\r\n    } else if (position === 'right') {\r\n      if (mirror) {\r\n        x = this.left + padding;\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'right';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x -= (widest / 2);\r\n        } else {\r\n          textAlign = 'left';\r\n          x -= widest;\r\n        }\r\n      } else {\r\n        x = this.left + tickAndPadding;\r\n        if (crossAlign === 'near') {\r\n          textAlign = 'left';\r\n        } else if (crossAlign === 'center') {\r\n          textAlign = 'center';\r\n          x += widest / 2;\r\n        } else {\r\n          textAlign = 'right';\r\n          x = this.right;\r\n        }\r\n      }\r\n    } else {\r\n      textAlign = 'right';\r\n    }\r\n    return {textAlign, x};\r\n  }\r\n  _computeLabelArea() {\r\n    if (this.options.ticks.mirror) {\r\n      return;\r\n    }\r\n    const chart = this.chart;\r\n    const position = this.options.position;\r\n    if (position === 'left' || position === 'right') {\r\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\r\n    } if (position === 'top' || position === 'bottom') {\r\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\r\n    }\r\n  }\r\n  drawBackground() {\r\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\r\n    if (backgroundColor) {\r\n      ctx.save();\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fillRect(left, top, width, height);\r\n      ctx.restore();\r\n    }\r\n  }\r\n  getLineWidthForValue(value) {\r\n    const grid = this.options.grid;\r\n    if (!this._isVisible() || !grid.display) {\r\n      return 0;\r\n    }\r\n    const ticks = this.ticks;\r\n    const index = ticks.findIndex(t => t.value === value);\r\n    if (index >= 0) {\r\n      const opts = grid.setContext(this.getContext(index));\r\n      return opts.lineWidth;\r\n    }\r\n    return 0;\r\n  }\r\n  drawGrid(chartArea) {\r\n    const grid = this.options.grid;\r\n    const ctx = this.ctx;\r\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\r\n    let i, ilen;\r\n    const drawLine = (p1, p2, style) => {\r\n      if (!style.width || !style.color) {\r\n        return;\r\n      }\r\n      ctx.save();\r\n      ctx.lineWidth = style.width;\r\n      ctx.strokeStyle = style.color;\r\n      ctx.setLineDash(style.borderDash || []);\r\n      ctx.lineDashOffset = style.borderDashOffset;\r\n      ctx.beginPath();\r\n      ctx.moveTo(p1.x, p1.y);\r\n      ctx.lineTo(p2.x, p2.y);\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    };\r\n    if (grid.display) {\r\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n        const item = items[i];\r\n        if (grid.drawOnChartArea) {\r\n          drawLine(\r\n            {x: item.x1, y: item.y1},\r\n            {x: item.x2, y: item.y2},\r\n            item\r\n          );\r\n        }\r\n        if (grid.drawTicks) {\r\n          drawLine(\r\n            {x: item.tx1, y: item.ty1},\r\n            {x: item.tx2, y: item.ty2},\r\n            {\r\n              color: item.tickColor,\r\n              width: item.tickWidth,\r\n              borderDash: item.tickBorderDash,\r\n              borderDashOffset: item.tickBorderDashOffset\r\n            }\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  drawBorder() {\r\n    const {chart, ctx, options: {grid}} = this;\r\n    const borderOpts = grid.setContext(this.getContext());\r\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\r\n    if (!axisWidth) {\r\n      return;\r\n    }\r\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\r\n    const borderValue = this._borderValue;\r\n    let x1, x2, y1, y2;\r\n    if (this.isHorizontal()) {\r\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\r\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\r\n      y1 = y2 = borderValue;\r\n    } else {\r\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\r\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\r\n      x1 = x2 = borderValue;\r\n    }\r\n    ctx.save();\r\n    ctx.lineWidth = borderOpts.borderWidth;\r\n    ctx.strokeStyle = borderOpts.borderColor;\r\n    ctx.beginPath();\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineTo(x2, y2);\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n  drawLabels(chartArea) {\r\n    const optionTicks = this.options.ticks;\r\n    if (!optionTicks.display) {\r\n      return;\r\n    }\r\n    const ctx = this.ctx;\r\n    const area = this._computeLabelArea();\r\n    if (area) {\r\n      clipArea(ctx, area);\r\n    }\r\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\r\n    let i, ilen;\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      const item = items[i];\r\n      const tickFont = item.font;\r\n      const label = item.label;\r\n      if (item.backdrop) {\r\n        ctx.fillStyle = item.backdrop.color;\r\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\r\n      }\r\n      let y = item.textOffset;\r\n      renderText(ctx, label, 0, y, tickFont, item);\r\n    }\r\n    if (area) {\r\n      unclipArea(ctx);\r\n    }\r\n  }\r\n  drawTitle() {\r\n    const {ctx, options: {position, title, reverse}} = this;\r\n    if (!title.display) {\r\n      return;\r\n    }\r\n    const font = toFont(title.font);\r\n    const padding = toPadding(title.padding);\r\n    const align = title.align;\r\n    let offset = font.lineHeight / 2;\r\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\r\n      offset += padding.bottom;\r\n      if (isArray(title.text)) {\r\n        offset += font.lineHeight * (title.text.length - 1);\r\n      }\r\n    } else {\r\n      offset += padding.top;\r\n    }\r\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\r\n    renderText(ctx, title.text, 0, 0, font, {\r\n      color: title.color,\r\n      maxWidth,\r\n      rotation,\r\n      textAlign: titleAlign(align, position, reverse),\r\n      textBaseline: 'middle',\r\n      translation: [titleX, titleY],\r\n    });\r\n  }\r\n  draw(chartArea) {\r\n    if (!this._isVisible()) {\r\n      return;\r\n    }\r\n    this.drawBackground();\r\n    this.drawGrid(chartArea);\r\n    this.drawBorder();\r\n    this.drawTitle();\r\n    this.drawLabels(chartArea);\r\n  }\r\n  _layers() {\r\n    const opts = this.options;\r\n    const tz = opts.ticks && opts.ticks.z || 0;\r\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\r\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\r\n      return [{\r\n        z: tz,\r\n        draw: (chartArea) => {\r\n          this.draw(chartArea);\r\n        }\r\n      }];\r\n    }\r\n    return [{\r\n      z: gz,\r\n      draw: (chartArea) => {\r\n        this.drawBackground();\r\n        this.drawGrid(chartArea);\r\n        this.drawTitle();\r\n      }\r\n    }, {\r\n      z: gz + 1,\r\n      draw: () => {\r\n        this.drawBorder();\r\n      }\r\n    }, {\r\n      z: tz,\r\n      draw: (chartArea) => {\r\n        this.drawLabels(chartArea);\r\n      }\r\n    }];\r\n  }\r\n  getMatchingVisibleMetas(type) {\r\n    const metas = this.chart.getSortedVisibleDatasetMetas();\r\n    const axisID = this.axis + 'AxisID';\r\n    const result = [];\r\n    let i, ilen;\r\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      const meta = metas[i];\r\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  _resolveTickFontOptions(index) {\r\n    const opts = this.options.ticks.setContext(this.getContext(index));\r\n    return toFont(opts.font);\r\n  }\r\n  _maxDigits() {\r\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\r\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\r\n  }\r\n}\r\n\r\nclass TypedRegistry {\r\n  constructor(type, scope, override) {\r\n    this.type = type;\r\n    this.scope = scope;\r\n    this.override = override;\r\n    this.items = Object.create(null);\r\n  }\r\n  isForType(type) {\r\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\r\n  }\r\n  register(item) {\r\n    const proto = Object.getPrototypeOf(item);\r\n    let parentScope;\r\n    if (isIChartComponent(proto)) {\r\n      parentScope = this.register(proto);\r\n    }\r\n    const items = this.items;\r\n    const id = item.id;\r\n    const scope = this.scope + '.' + id;\r\n    if (!id) {\r\n      throw new Error('class does not have id: ' + item);\r\n    }\r\n    if (id in items) {\r\n      return scope;\r\n    }\r\n    items[id] = item;\r\n    registerDefaults(item, scope, parentScope);\r\n    if (this.override) {\r\n      defaults.override(item.id, item.overrides);\r\n    }\r\n    return scope;\r\n  }\r\n  get(id) {\r\n    return this.items[id];\r\n  }\r\n  unregister(item) {\r\n    const items = this.items;\r\n    const id = item.id;\r\n    const scope = this.scope;\r\n    if (id in items) {\r\n      delete items[id];\r\n    }\r\n    if (scope && id in defaults[scope]) {\r\n      delete defaults[scope][id];\r\n      if (this.override) {\r\n        delete overrides[id];\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction registerDefaults(item, scope, parentScope) {\r\n  const itemDefaults = merge(Object.create(null), [\r\n    parentScope ? defaults.get(parentScope) : {},\r\n    defaults.get(scope),\r\n    item.defaults\r\n  ]);\r\n  defaults.set(scope, itemDefaults);\r\n  if (item.defaultRoutes) {\r\n    routeDefaults(scope, item.defaultRoutes);\r\n  }\r\n  if (item.descriptors) {\r\n    defaults.describe(scope, item.descriptors);\r\n  }\r\n}\r\nfunction routeDefaults(scope, routes) {\r\n  Object.keys(routes).forEach(property => {\r\n    const propertyParts = property.split('.');\r\n    const sourceName = propertyParts.pop();\r\n    const sourceScope = [scope].concat(propertyParts).join('.');\r\n    const parts = routes[property].split('.');\r\n    const targetName = parts.pop();\r\n    const targetScope = parts.join('.');\r\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\r\n  });\r\n}\r\nfunction isIChartComponent(proto) {\r\n  return 'id' in proto && 'defaults' in proto;\r\n}\r\n\r\nclass Registry {\r\n  constructor() {\r\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\r\n    this.elements = new TypedRegistry(Element, 'elements');\r\n    this.plugins = new TypedRegistry(Object, 'plugins');\r\n    this.scales = new TypedRegistry(Scale, 'scales');\r\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\r\n  }\r\n  add(...args) {\r\n    this._each('register', args);\r\n  }\r\n  remove(...args) {\r\n    this._each('unregister', args);\r\n  }\r\n  addControllers(...args) {\r\n    this._each('register', args, this.controllers);\r\n  }\r\n  addElements(...args) {\r\n    this._each('register', args, this.elements);\r\n  }\r\n  addPlugins(...args) {\r\n    this._each('register', args, this.plugins);\r\n  }\r\n  addScales(...args) {\r\n    this._each('register', args, this.scales);\r\n  }\r\n  getController(id) {\r\n    return this._get(id, this.controllers, 'controller');\r\n  }\r\n  getElement(id) {\r\n    return this._get(id, this.elements, 'element');\r\n  }\r\n  getPlugin(id) {\r\n    return this._get(id, this.plugins, 'plugin');\r\n  }\r\n  getScale(id) {\r\n    return this._get(id, this.scales, 'scale');\r\n  }\r\n  removeControllers(...args) {\r\n    this._each('unregister', args, this.controllers);\r\n  }\r\n  removeElements(...args) {\r\n    this._each('unregister', args, this.elements);\r\n  }\r\n  removePlugins(...args) {\r\n    this._each('unregister', args, this.plugins);\r\n  }\r\n  removeScales(...args) {\r\n    this._each('unregister', args, this.scales);\r\n  }\r\n  _each(method, args, typedRegistry) {\r\n    [...args].forEach(arg => {\r\n      const reg = typedRegistry || this._getRegistryForType(arg);\r\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\r\n        this._exec(method, reg, arg);\r\n      } else {\r\n        each(arg, item => {\r\n          const itemReg = typedRegistry || this._getRegistryForType(item);\r\n          this._exec(method, itemReg, item);\r\n        });\r\n      }\r\n    });\r\n  }\r\n  _exec(method, registry, component) {\r\n    const camelMethod = _capitalize(method);\r\n    callback(component['before' + camelMethod], [], component);\r\n    registry[method](component);\r\n    callback(component['after' + camelMethod], [], component);\r\n  }\r\n  _getRegistryForType(type) {\r\n    for (let i = 0; i < this._typedRegistries.length; i++) {\r\n      const reg = this._typedRegistries[i];\r\n      if (reg.isForType(type)) {\r\n        return reg;\r\n      }\r\n    }\r\n    return this.plugins;\r\n  }\r\n  _get(id, typedRegistry, type) {\r\n    const item = typedRegistry.get(id);\r\n    if (item === undefined) {\r\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\r\n    }\r\n    return item;\r\n  }\r\n}\r\nvar registry = new Registry();\r\n\r\nclass PluginService {\r\n  constructor() {\r\n    this._init = [];\r\n  }\r\n  notify(chart, hook, args, filter) {\r\n    if (hook === 'beforeInit') {\r\n      this._init = this._createDescriptors(chart, true);\r\n      this._notify(this._init, chart, 'install');\r\n    }\r\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\r\n    const result = this._notify(descriptors, chart, hook, args);\r\n    if (hook === 'afterDestroy') {\r\n      this._notify(descriptors, chart, 'stop');\r\n      this._notify(this._init, chart, 'uninstall');\r\n    }\r\n    return result;\r\n  }\r\n  _notify(descriptors, chart, hook, args) {\r\n    args = args || {};\r\n    for (const descriptor of descriptors) {\r\n      const plugin = descriptor.plugin;\r\n      const method = plugin[hook];\r\n      const params = [chart, args, descriptor.options];\r\n      if (callback(method, params, plugin) === false && args.cancelable) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  invalidate() {\r\n    if (!isNullOrUndef(this._cache)) {\r\n      this._oldCache = this._cache;\r\n      this._cache = undefined;\r\n    }\r\n  }\r\n  _descriptors(chart) {\r\n    if (this._cache) {\r\n      return this._cache;\r\n    }\r\n    const descriptors = this._cache = this._createDescriptors(chart);\r\n    this._notifyStateChanges(chart);\r\n    return descriptors;\r\n  }\r\n  _createDescriptors(chart, all) {\r\n    const config = chart && chart.config;\r\n    const options = valueOrDefault(config.options && config.options.plugins, {});\r\n    const plugins = allPlugins(config);\r\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\r\n  }\r\n  _notifyStateChanges(chart) {\r\n    const previousDescriptors = this._oldCache || [];\r\n    const descriptors = this._cache;\r\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\r\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\r\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\r\n  }\r\n}\r\nfunction allPlugins(config) {\r\n  const plugins = [];\r\n  const keys = Object.keys(registry.plugins.items);\r\n  for (let i = 0; i < keys.length; i++) {\r\n    plugins.push(registry.getPlugin(keys[i]));\r\n  }\r\n  const local = config.plugins || [];\r\n  for (let i = 0; i < local.length; i++) {\r\n    const plugin = local[i];\r\n    if (plugins.indexOf(plugin) === -1) {\r\n      plugins.push(plugin);\r\n    }\r\n  }\r\n  return plugins;\r\n}\r\nfunction getOpts(options, all) {\r\n  if (!all && options === false) {\r\n    return null;\r\n  }\r\n  if (options === true) {\r\n    return {};\r\n  }\r\n  return options;\r\n}\r\nfunction createDescriptors(chart, plugins, options, all) {\r\n  const result = [];\r\n  const context = chart.getContext();\r\n  for (let i = 0; i < plugins.length; i++) {\r\n    const plugin = plugins[i];\r\n    const id = plugin.id;\r\n    const opts = getOpts(options[id], all);\r\n    if (opts === null) {\r\n      continue;\r\n    }\r\n    result.push({\r\n      plugin,\r\n      options: pluginOpts(chart.config, plugin, opts, context)\r\n    });\r\n  }\r\n  return result;\r\n}\r\nfunction pluginOpts(config, plugin, opts, context) {\r\n  const keys = config.pluginScopeKeys(plugin);\r\n  const scopes = config.getOptionScopes(opts, keys);\r\n  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});\r\n}\r\n\r\nfunction getIndexAxis(type, options) {\r\n  const datasetDefaults = defaults.datasets[type] || {};\r\n  const datasetOptions = (options.datasets || {})[type] || {};\r\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\r\n}\r\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\r\n  let axis = id;\r\n  if (id === '_index_') {\r\n    axis = indexAxis;\r\n  } else if (id === '_value_') {\r\n    axis = indexAxis === 'x' ? 'y' : 'x';\r\n  }\r\n  return axis;\r\n}\r\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\r\n  return axis === indexAxis ? '_index_' : '_value_';\r\n}\r\nfunction axisFromPosition(position) {\r\n  if (position === 'top' || position === 'bottom') {\r\n    return 'x';\r\n  }\r\n  if (position === 'left' || position === 'right') {\r\n    return 'y';\r\n  }\r\n}\r\nfunction determineAxis(id, scaleOptions) {\r\n  if (id === 'x' || id === 'y') {\r\n    return id;\r\n  }\r\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\r\n}\r\nfunction mergeScaleConfig(config, options) {\r\n  const chartDefaults = overrides[config.type] || {scales: {}};\r\n  const configScales = options.scales || {};\r\n  const chartIndexAxis = getIndexAxis(config.type, options);\r\n  const firstIDs = Object.create(null);\r\n  const scales = Object.create(null);\r\n  Object.keys(configScales).forEach(id => {\r\n    const scaleConf = configScales[id];\r\n    if (!isObject(scaleConf)) {\r\n      return console.error(`Invalid scale configuration for scale: ${id}`);\r\n    }\r\n    if (scaleConf._proxy) {\r\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\r\n    }\r\n    const axis = determineAxis(id, scaleConf);\r\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\r\n    const defaultScaleOptions = chartDefaults.scales || {};\r\n    firstIDs[axis] = firstIDs[axis] || id;\r\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\r\n  });\r\n  config.data.datasets.forEach(dataset => {\r\n    const type = dataset.type || config.type;\r\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\r\n    const datasetDefaults = overrides[type] || {};\r\n    const defaultScaleOptions = datasetDefaults.scales || {};\r\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\r\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\r\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\r\n      scales[id] = scales[id] || Object.create(null);\r\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\r\n    });\r\n  });\r\n  Object.keys(scales).forEach(key => {\r\n    const scale = scales[key];\r\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\r\n  });\r\n  return scales;\r\n}\r\nfunction initOptions(config) {\r\n  const options = config.options || (config.options = {});\r\n  options.plugins = valueOrDefault(options.plugins, {});\r\n  options.scales = mergeScaleConfig(config, options);\r\n}\r\nfunction initData(data) {\r\n  data = data || {};\r\n  data.datasets = data.datasets || [];\r\n  data.labels = data.labels || [];\r\n  return data;\r\n}\r\nfunction initConfig(config) {\r\n  config = config || {};\r\n  config.data = initData(config.data);\r\n  initOptions(config);\r\n  return config;\r\n}\r\nconst keyCache = new Map();\r\nconst keysCached = new Set();\r\nfunction cachedKeys(cacheKey, generate) {\r\n  let keys = keyCache.get(cacheKey);\r\n  if (!keys) {\r\n    keys = generate();\r\n    keyCache.set(cacheKey, keys);\r\n    keysCached.add(keys);\r\n  }\r\n  return keys;\r\n}\r\nconst addIfFound = (set, obj, key) => {\r\n  const opts = resolveObjectKey(obj, key);\r\n  if (opts !== undefined) {\r\n    set.add(opts);\r\n  }\r\n};\r\nclass Config {\r\n  constructor(config) {\r\n    this._config = initConfig(config);\r\n    this._scopeCache = new Map();\r\n    this._resolverCache = new Map();\r\n  }\r\n  get platform() {\r\n    return this._config.platform;\r\n  }\r\n  get type() {\r\n    return this._config.type;\r\n  }\r\n  set type(type) {\r\n    this._config.type = type;\r\n  }\r\n  get data() {\r\n    return this._config.data;\r\n  }\r\n  set data(data) {\r\n    this._config.data = initData(data);\r\n  }\r\n  get options() {\r\n    return this._config.options;\r\n  }\r\n  set options(options) {\r\n    this._config.options = options;\r\n  }\r\n  get plugins() {\r\n    return this._config.plugins;\r\n  }\r\n  update() {\r\n    const config = this._config;\r\n    this.clearCache();\r\n    initOptions(config);\r\n  }\r\n  clearCache() {\r\n    this._scopeCache.clear();\r\n    this._resolverCache.clear();\r\n  }\r\n  datasetScopeKeys(datasetType) {\r\n    return cachedKeys(datasetType,\r\n      () => [[\r\n        `datasets.${datasetType}`,\r\n        ''\r\n      ]]);\r\n  }\r\n  datasetAnimationScopeKeys(datasetType, transition) {\r\n    return cachedKeys(`${datasetType}.transition.${transition}`,\r\n      () => [\r\n        [\r\n          `datasets.${datasetType}.transitions.${transition}`,\r\n          `transitions.${transition}`,\r\n        ],\r\n        [\r\n          `datasets.${datasetType}`,\r\n          ''\r\n        ]\r\n      ]);\r\n  }\r\n  datasetElementScopeKeys(datasetType, elementType) {\r\n    return cachedKeys(`${datasetType}-${elementType}`,\r\n      () => [[\r\n        `datasets.${datasetType}.elements.${elementType}`,\r\n        `datasets.${datasetType}`,\r\n        `elements.${elementType}`,\r\n        ''\r\n      ]]);\r\n  }\r\n  pluginScopeKeys(plugin) {\r\n    const id = plugin.id;\r\n    const type = this.type;\r\n    return cachedKeys(`${type}-plugin-${id}`,\r\n      () => [[\r\n        `plugins.${id}`,\r\n        ...plugin.additionalOptionScopes || [],\r\n      ]]);\r\n  }\r\n  _cachedScopes(mainScope, resetCache) {\r\n    const _scopeCache = this._scopeCache;\r\n    let cache = _scopeCache.get(mainScope);\r\n    if (!cache || resetCache) {\r\n      cache = new Map();\r\n      _scopeCache.set(mainScope, cache);\r\n    }\r\n    return cache;\r\n  }\r\n  getOptionScopes(mainScope, keyLists, resetCache) {\r\n    const {options, type} = this;\r\n    const cache = this._cachedScopes(mainScope, resetCache);\r\n    const cached = cache.get(keyLists);\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    const scopes = new Set();\r\n    keyLists.forEach(keys => {\r\n      if (mainScope) {\r\n        scopes.add(mainScope);\r\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\r\n      }\r\n      keys.forEach(key => addIfFound(scopes, options, key));\r\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\r\n      keys.forEach(key => addIfFound(scopes, defaults, key));\r\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\r\n    });\r\n    const array = Array.from(scopes);\r\n    if (array.length === 0) {\r\n      array.push(Object.create(null));\r\n    }\r\n    if (keysCached.has(keyLists)) {\r\n      cache.set(keyLists, array);\r\n    }\r\n    return array;\r\n  }\r\n  chartOptionScopes() {\r\n    const {options, type} = this;\r\n    return [\r\n      options,\r\n      overrides[type] || {},\r\n      defaults.datasets[type] || {},\r\n      {type},\r\n      defaults,\r\n      descriptors\r\n    ];\r\n  }\r\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\r\n    const result = {$shared: true};\r\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\r\n    let options = resolver;\r\n    if (needContext(resolver, names)) {\r\n      result.$shared = false;\r\n      context = isFunction(context) ? context() : context;\r\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\r\n      options = _attachContext(resolver, context, subResolver);\r\n    }\r\n    for (const prop of names) {\r\n      result[prop] = options[prop];\r\n    }\r\n    return result;\r\n  }\r\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\r\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\r\n    return isObject(context)\r\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\r\n      : resolver;\r\n  }\r\n}\r\nfunction getResolver(resolverCache, scopes, prefixes) {\r\n  let cache = resolverCache.get(scopes);\r\n  if (!cache) {\r\n    cache = new Map();\r\n    resolverCache.set(scopes, cache);\r\n  }\r\n  const cacheKey = prefixes.join();\r\n  let cached = cache.get(cacheKey);\r\n  if (!cached) {\r\n    const resolver = _createResolver(scopes, prefixes);\r\n    cached = {\r\n      resolver,\r\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\r\n    };\r\n    cache.set(cacheKey, cached);\r\n  }\r\n  return cached;\r\n}\r\nconst hasFunction = value => isObject(value)\r\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\r\nfunction needContext(proxy, names) {\r\n  const {isScriptable, isIndexable} = _descriptors(proxy);\r\n  for (const prop of names) {\r\n    const scriptable = isScriptable(prop);\r\n    const indexable = isIndexable(prop);\r\n    const value = (indexable || scriptable) && proxy[prop];\r\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\r\n      || (indexable && isArray(value))) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nvar version = \"3.8.0\";\r\n\r\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\r\nfunction positionIsHorizontal(position, axis) {\r\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\r\n}\r\nfunction compare2Level(l1, l2) {\r\n  return function(a, b) {\r\n    return a[l1] === b[l1]\r\n      ? a[l2] - b[l2]\r\n      : a[l1] - b[l1];\r\n  };\r\n}\r\nfunction onAnimationsComplete(context) {\r\n  const chart = context.chart;\r\n  const animationOptions = chart.options.animation;\r\n  chart.notifyPlugins('afterRender');\r\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\r\n}\r\nfunction onAnimationProgress(context) {\r\n  const chart = context.chart;\r\n  const animationOptions = chart.options.animation;\r\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\r\n}\r\nfunction getCanvas(item) {\r\n  if (_isDomSupported() && typeof item === 'string') {\r\n    item = document.getElementById(item);\r\n  } else if (item && item.length) {\r\n    item = item[0];\r\n  }\r\n  if (item && item.canvas) {\r\n    item = item.canvas;\r\n  }\r\n  return item;\r\n}\r\nconst instances = {};\r\nconst getChart = (key) => {\r\n  const canvas = getCanvas(key);\r\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\r\n};\r\nfunction moveNumericKeys(obj, start, move) {\r\n  const keys = Object.keys(obj);\r\n  for (const key of keys) {\r\n    const intKey = +key;\r\n    if (intKey >= start) {\r\n      const value = obj[key];\r\n      delete obj[key];\r\n      if (move > 0 || intKey > start) {\r\n        obj[intKey + move] = value;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\r\n  if (!inChartArea || e.type === 'mouseout') {\r\n    return null;\r\n  }\r\n  if (isClick) {\r\n    return lastEvent;\r\n  }\r\n  return e;\r\n}\r\nclass Chart {\r\n  constructor(item, userConfig) {\r\n    const config = this.config = new Config(userConfig);\r\n    const initialCanvas = getCanvas(item);\r\n    const existingChart = getChart(initialCanvas);\r\n    if (existingChart) {\r\n      throw new Error(\r\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\r\n\t\t\t\t' must be destroyed before the canvas can be reused.'\r\n      );\r\n    }\r\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\r\n    this.platform.updateConfig(config);\r\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\r\n    const canvas = context && context.canvas;\r\n    const height = canvas && canvas.height;\r\n    const width = canvas && canvas.width;\r\n    this.id = uid();\r\n    this.ctx = context;\r\n    this.canvas = canvas;\r\n    this.width = width;\r\n    this.height = height;\r\n    this._options = options;\r\n    this._aspectRatio = this.aspectRatio;\r\n    this._layers = [];\r\n    this._metasets = [];\r\n    this._stacks = undefined;\r\n    this.boxes = [];\r\n    this.currentDevicePixelRatio = undefined;\r\n    this.chartArea = undefined;\r\n    this._active = [];\r\n    this._lastEvent = undefined;\r\n    this._listeners = {};\r\n    this._responsiveListeners = undefined;\r\n    this._sortedMetasets = [];\r\n    this.scales = {};\r\n    this._plugins = new PluginService();\r\n    this.$proxies = {};\r\n    this._hiddenIndices = {};\r\n    this.attached = false;\r\n    this._animationsDisabled = undefined;\r\n    this.$context = undefined;\r\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\r\n    this._dataChanges = [];\r\n    instances[this.id] = this;\r\n    if (!context || !canvas) {\r\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n      return;\r\n    }\r\n    animator.listen(this, 'complete', onAnimationsComplete);\r\n    animator.listen(this, 'progress', onAnimationProgress);\r\n    this._initialize();\r\n    if (this.attached) {\r\n      this.update();\r\n    }\r\n  }\r\n  get aspectRatio() {\r\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\r\n    if (!isNullOrUndef(aspectRatio)) {\r\n      return aspectRatio;\r\n    }\r\n    if (maintainAspectRatio && _aspectRatio) {\r\n      return _aspectRatio;\r\n    }\r\n    return height ? width / height : null;\r\n  }\r\n  get data() {\r\n    return this.config.data;\r\n  }\r\n  set data(data) {\r\n    this.config.data = data;\r\n  }\r\n  get options() {\r\n    return this._options;\r\n  }\r\n  set options(options) {\r\n    this.config.options = options;\r\n  }\r\n  _initialize() {\r\n    this.notifyPlugins('beforeInit');\r\n    if (this.options.responsive) {\r\n      this.resize();\r\n    } else {\r\n      retinaScale(this, this.options.devicePixelRatio);\r\n    }\r\n    this.bindEvents();\r\n    this.notifyPlugins('afterInit');\r\n    return this;\r\n  }\r\n  clear() {\r\n    clearCanvas(this.canvas, this.ctx);\r\n    return this;\r\n  }\r\n  stop() {\r\n    animator.stop(this);\r\n    return this;\r\n  }\r\n  resize(width, height) {\r\n    if (!animator.running(this)) {\r\n      this._resize(width, height);\r\n    } else {\r\n      this._resizeBeforeDraw = {width, height};\r\n    }\r\n  }\r\n  _resize(width, height) {\r\n    const options = this.options;\r\n    const canvas = this.canvas;\r\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\r\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\r\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\r\n    const mode = this.width ? 'resize' : 'attach';\r\n    this.width = newSize.width;\r\n    this.height = newSize.height;\r\n    this._aspectRatio = this.aspectRatio;\r\n    if (!retinaScale(this, newRatio, true)) {\r\n      return;\r\n    }\r\n    this.notifyPlugins('resize', {size: newSize});\r\n    callback(options.onResize, [this, newSize], this);\r\n    if (this.attached) {\r\n      if (this._doResize(mode)) {\r\n        this.render();\r\n      }\r\n    }\r\n  }\r\n  ensureScalesHaveIDs() {\r\n    const options = this.options;\r\n    const scalesOptions = options.scales || {};\r\n    each(scalesOptions, (axisOptions, axisID) => {\r\n      axisOptions.id = axisID;\r\n    });\r\n  }\r\n  buildOrUpdateScales() {\r\n    const options = this.options;\r\n    const scaleOpts = options.scales;\r\n    const scales = this.scales;\r\n    const updated = Object.keys(scales).reduce((obj, id) => {\r\n      obj[id] = false;\r\n      return obj;\r\n    }, {});\r\n    let items = [];\r\n    if (scaleOpts) {\r\n      items = items.concat(\r\n        Object.keys(scaleOpts).map((id) => {\r\n          const scaleOptions = scaleOpts[id];\r\n          const axis = determineAxis(id, scaleOptions);\r\n          const isRadial = axis === 'r';\r\n          const isHorizontal = axis === 'x';\r\n          return {\r\n            options: scaleOptions,\r\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\r\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\r\n          };\r\n        })\r\n      );\r\n    }\r\n    each(items, (item) => {\r\n      const scaleOptions = item.options;\r\n      const id = scaleOptions.id;\r\n      const axis = determineAxis(id, scaleOptions);\r\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\r\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\r\n        scaleOptions.position = item.dposition;\r\n      }\r\n      updated[id] = true;\r\n      let scale = null;\r\n      if (id in scales && scales[id].type === scaleType) {\r\n        scale = scales[id];\r\n      } else {\r\n        const scaleClass = registry.getScale(scaleType);\r\n        scale = new scaleClass({\r\n          id,\r\n          type: scaleType,\r\n          ctx: this.ctx,\r\n          chart: this\r\n        });\r\n        scales[scale.id] = scale;\r\n      }\r\n      scale.init(scaleOptions, options);\r\n    });\r\n    each(updated, (hasUpdated, id) => {\r\n      if (!hasUpdated) {\r\n        delete scales[id];\r\n      }\r\n    });\r\n    each(scales, (scale) => {\r\n      layouts.configure(this, scale, scale.options);\r\n      layouts.addBox(this, scale);\r\n    });\r\n  }\r\n  _updateMetasets() {\r\n    const metasets = this._metasets;\r\n    const numData = this.data.datasets.length;\r\n    const numMeta = metasets.length;\r\n    metasets.sort((a, b) => a.index - b.index);\r\n    if (numMeta > numData) {\r\n      for (let i = numData; i < numMeta; ++i) {\r\n        this._destroyDatasetMeta(i);\r\n      }\r\n      metasets.splice(numData, numMeta - numData);\r\n    }\r\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\r\n  }\r\n  _removeUnreferencedMetasets() {\r\n    const {_metasets: metasets, data: {datasets}} = this;\r\n    if (metasets.length > datasets.length) {\r\n      delete this._stacks;\r\n    }\r\n    metasets.forEach((meta, index) => {\r\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\r\n        this._destroyDatasetMeta(index);\r\n      }\r\n    });\r\n  }\r\n  buildOrUpdateControllers() {\r\n    const newControllers = [];\r\n    const datasets = this.data.datasets;\r\n    let i, ilen;\r\n    this._removeUnreferencedMetasets();\r\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\r\n      const dataset = datasets[i];\r\n      let meta = this.getDatasetMeta(i);\r\n      const type = dataset.type || this.config.type;\r\n      if (meta.type && meta.type !== type) {\r\n        this._destroyDatasetMeta(i);\r\n        meta = this.getDatasetMeta(i);\r\n      }\r\n      meta.type = type;\r\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\r\n      meta.order = dataset.order || 0;\r\n      meta.index = i;\r\n      meta.label = '' + dataset.label;\r\n      meta.visible = this.isDatasetVisible(i);\r\n      if (meta.controller) {\r\n        meta.controller.updateIndex(i);\r\n        meta.controller.linkScales();\r\n      } else {\r\n        const ControllerClass = registry.getController(type);\r\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\r\n        Object.assign(ControllerClass.prototype, {\r\n          dataElementType: registry.getElement(dataElementType),\r\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\r\n        });\r\n        meta.controller = new ControllerClass(this, i);\r\n        newControllers.push(meta.controller);\r\n      }\r\n    }\r\n    this._updateMetasets();\r\n    return newControllers;\r\n  }\r\n  _resetElements() {\r\n    each(this.data.datasets, (dataset, datasetIndex) => {\r\n      this.getDatasetMeta(datasetIndex).controller.reset();\r\n    }, this);\r\n  }\r\n  reset() {\r\n    this._resetElements();\r\n    this.notifyPlugins('reset');\r\n  }\r\n  update(mode) {\r\n    const config = this.config;\r\n    config.update();\r\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\r\n    const animsDisabled = this._animationsDisabled = !options.animation;\r\n    this._updateScales();\r\n    this._checkEventBindings();\r\n    this._updateHiddenIndices();\r\n    this._plugins.invalidate();\r\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\r\n      return;\r\n    }\r\n    const newControllers = this.buildOrUpdateControllers();\r\n    this.notifyPlugins('beforeElementsUpdate');\r\n    let minPadding = 0;\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\r\n      const {controller} = this.getDatasetMeta(i);\r\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\r\n      controller.buildOrUpdateElements(reset);\r\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\r\n    }\r\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\r\n    this._updateLayout(minPadding);\r\n    if (!animsDisabled) {\r\n      each(newControllers, (controller) => {\r\n        controller.reset();\r\n      });\r\n    }\r\n    this._updateDatasets(mode);\r\n    this.notifyPlugins('afterUpdate', {mode});\r\n    this._layers.sort(compare2Level('z', '_idx'));\r\n    const {_active, _lastEvent} = this;\r\n    if (_lastEvent) {\r\n      this._eventHandler(_lastEvent, true);\r\n    } else if (_active.length) {\r\n      this._updateHoverStyles(_active, _active, true);\r\n    }\r\n    this.render();\r\n  }\r\n  _updateScales() {\r\n    each(this.scales, (scale) => {\r\n      layouts.removeBox(this, scale);\r\n    });\r\n    this.ensureScalesHaveIDs();\r\n    this.buildOrUpdateScales();\r\n  }\r\n  _checkEventBindings() {\r\n    const options = this.options;\r\n    const existingEvents = new Set(Object.keys(this._listeners));\r\n    const newEvents = new Set(options.events);\r\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\r\n      this.unbindEvents();\r\n      this.bindEvents();\r\n    }\r\n  }\r\n  _updateHiddenIndices() {\r\n    const {_hiddenIndices} = this;\r\n    const changes = this._getUniformDataChanges() || [];\r\n    for (const {method, start, count} of changes) {\r\n      const move = method === '_removeElements' ? -count : count;\r\n      moveNumericKeys(_hiddenIndices, start, move);\r\n    }\r\n  }\r\n  _getUniformDataChanges() {\r\n    const _dataChanges = this._dataChanges;\r\n    if (!_dataChanges || !_dataChanges.length) {\r\n      return;\r\n    }\r\n    this._dataChanges = [];\r\n    const datasetCount = this.data.datasets.length;\r\n    const makeSet = (idx) => new Set(\r\n      _dataChanges\r\n        .filter(c => c[0] === idx)\r\n        .map((c, i) => i + ',' + c.splice(1).join(','))\r\n    );\r\n    const changeSet = makeSet(0);\r\n    for (let i = 1; i < datasetCount; i++) {\r\n      if (!setsEqual(changeSet, makeSet(i))) {\r\n        return;\r\n      }\r\n    }\r\n    return Array.from(changeSet)\r\n      .map(c => c.split(','))\r\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\r\n  }\r\n  _updateLayout(minPadding) {\r\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n    layouts.update(this, this.width, this.height, minPadding);\r\n    const area = this.chartArea;\r\n    const noArea = area.width <= 0 || area.height <= 0;\r\n    this._layers = [];\r\n    each(this.boxes, (box) => {\r\n      if (noArea && box.position === 'chartArea') {\r\n        return;\r\n      }\r\n      if (box.configure) {\r\n        box.configure();\r\n      }\r\n      this._layers.push(...box._layers());\r\n    }, this);\r\n    this._layers.forEach((item, index) => {\r\n      item._idx = index;\r\n    });\r\n    this.notifyPlugins('afterLayout');\r\n  }\r\n  _updateDatasets(mode) {\r\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\r\n      return;\r\n    }\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this.getDatasetMeta(i).controller.configure();\r\n    }\r\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\r\n    }\r\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\r\n  }\r\n  _updateDataset(index, mode) {\r\n    const meta = this.getDatasetMeta(index);\r\n    const args = {meta, index, mode, cancelable: true};\r\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\r\n      return;\r\n    }\r\n    meta.controller._update(mode);\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterDatasetUpdate', args);\r\n  }\r\n  render() {\r\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n    if (animator.has(this)) {\r\n      if (this.attached && !animator.running(this)) {\r\n        animator.start(this);\r\n      }\r\n    } else {\r\n      this.draw();\r\n      onAnimationsComplete({chart: this});\r\n    }\r\n  }\r\n  draw() {\r\n    let i;\r\n    if (this._resizeBeforeDraw) {\r\n      const {width, height} = this._resizeBeforeDraw;\r\n      this._resize(width, height);\r\n      this._resizeBeforeDraw = null;\r\n    }\r\n    this.clear();\r\n    if (this.width <= 0 || this.height <= 0) {\r\n      return;\r\n    }\r\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n    const layers = this._layers;\r\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\r\n      layers[i].draw(this.chartArea);\r\n    }\r\n    this._drawDatasets();\r\n    for (; i < layers.length; ++i) {\r\n      layers[i].draw(this.chartArea);\r\n    }\r\n    this.notifyPlugins('afterDraw');\r\n  }\r\n  _getSortedDatasetMetas(filterVisible) {\r\n    const metasets = this._sortedMetasets;\r\n    const result = [];\r\n    let i, ilen;\r\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\r\n      const meta = metasets[i];\r\n      if (!filterVisible || meta.visible) {\r\n        result.push(meta);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  getSortedVisibleDatasetMetas() {\r\n    return this._getSortedDatasetMetas(true);\r\n  }\r\n  _drawDatasets() {\r\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\r\n      return;\r\n    }\r\n    const metasets = this.getSortedVisibleDatasetMetas();\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      this._drawDataset(metasets[i]);\r\n    }\r\n    this.notifyPlugins('afterDatasetsDraw');\r\n  }\r\n  _drawDataset(meta) {\r\n    const ctx = this.ctx;\r\n    const clip = meta._clip;\r\n    const useClip = !clip.disabled;\r\n    const area = this.chartArea;\r\n    const args = {\r\n      meta,\r\n      index: meta.index,\r\n      cancelable: true\r\n    };\r\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\r\n      return;\r\n    }\r\n    if (useClip) {\r\n      clipArea(ctx, {\r\n        left: clip.left === false ? 0 : area.left - clip.left,\r\n        right: clip.right === false ? this.width : area.right + clip.right,\r\n        top: clip.top === false ? 0 : area.top - clip.top,\r\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\r\n      });\r\n    }\r\n    meta.controller.draw();\r\n    if (useClip) {\r\n      unclipArea(ctx);\r\n    }\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterDatasetDraw', args);\r\n  }\r\n  isPointInArea(point) {\r\n    return _isPointInArea(point, this.chartArea, this._minPadding);\r\n  }\r\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\r\n    const method = Interaction.modes[mode];\r\n    if (typeof method === 'function') {\r\n      return method(this, e, options, useFinalPosition);\r\n    }\r\n    return [];\r\n  }\r\n  getDatasetMeta(datasetIndex) {\r\n    const dataset = this.data.datasets[datasetIndex];\r\n    const metasets = this._metasets;\r\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\r\n    if (!meta) {\r\n      meta = {\r\n        type: null,\r\n        data: [],\r\n        dataset: null,\r\n        controller: null,\r\n        hidden: null,\r\n        xAxisID: null,\r\n        yAxisID: null,\r\n        order: dataset && dataset.order || 0,\r\n        index: datasetIndex,\r\n        _dataset: dataset,\r\n        _parsed: [],\r\n        _sorted: false\r\n      };\r\n      metasets.push(meta);\r\n    }\r\n    return meta;\r\n  }\r\n  getContext() {\r\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\r\n  }\r\n  getVisibleDatasetCount() {\r\n    return this.getSortedVisibleDatasetMetas().length;\r\n  }\r\n  isDatasetVisible(datasetIndex) {\r\n    const dataset = this.data.datasets[datasetIndex];\r\n    if (!dataset) {\r\n      return false;\r\n    }\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\r\n  }\r\n  setDatasetVisibility(datasetIndex, visible) {\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    meta.hidden = !visible;\r\n  }\r\n  toggleDataVisibility(index) {\r\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\r\n  }\r\n  getDataVisibility(index) {\r\n    return !this._hiddenIndices[index];\r\n  }\r\n  _updateVisibility(datasetIndex, dataIndex, visible) {\r\n    const mode = visible ? 'show' : 'hide';\r\n    const meta = this.getDatasetMeta(datasetIndex);\r\n    const anims = meta.controller._resolveAnimations(undefined, mode);\r\n    if (defined(dataIndex)) {\r\n      meta.data[dataIndex].hidden = !visible;\r\n      this.update();\r\n    } else {\r\n      this.setDatasetVisibility(datasetIndex, visible);\r\n      anims.update(meta, {visible});\r\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\r\n    }\r\n  }\r\n  hide(datasetIndex, dataIndex) {\r\n    this._updateVisibility(datasetIndex, dataIndex, false);\r\n  }\r\n  show(datasetIndex, dataIndex) {\r\n    this._updateVisibility(datasetIndex, dataIndex, true);\r\n  }\r\n  _destroyDatasetMeta(datasetIndex) {\r\n    const meta = this._metasets[datasetIndex];\r\n    if (meta && meta.controller) {\r\n      meta.controller._destroy();\r\n    }\r\n    delete this._metasets[datasetIndex];\r\n  }\r\n  _stop() {\r\n    let i, ilen;\r\n    this.stop();\r\n    animator.remove(this);\r\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\r\n      this._destroyDatasetMeta(i);\r\n    }\r\n  }\r\n  destroy() {\r\n    this.notifyPlugins('beforeDestroy');\r\n    const {canvas, ctx} = this;\r\n    this._stop();\r\n    this.config.clearCache();\r\n    if (canvas) {\r\n      this.unbindEvents();\r\n      clearCanvas(canvas, ctx);\r\n      this.platform.releaseContext(ctx);\r\n      this.canvas = null;\r\n      this.ctx = null;\r\n    }\r\n    this.notifyPlugins('destroy');\r\n    delete instances[this.id];\r\n    this.notifyPlugins('afterDestroy');\r\n  }\r\n  toBase64Image(...args) {\r\n    return this.canvas.toDataURL(...args);\r\n  }\r\n  bindEvents() {\r\n    this.bindUserEvents();\r\n    if (this.options.responsive) {\r\n      this.bindResponsiveEvents();\r\n    } else {\r\n      this.attached = true;\r\n    }\r\n  }\r\n  bindUserEvents() {\r\n    const listeners = this._listeners;\r\n    const platform = this.platform;\r\n    const _add = (type, listener) => {\r\n      platform.addEventListener(this, type, listener);\r\n      listeners[type] = listener;\r\n    };\r\n    const listener = (e, x, y) => {\r\n      e.offsetX = x;\r\n      e.offsetY = y;\r\n      this._eventHandler(e);\r\n    };\r\n    each(this.options.events, (type) => _add(type, listener));\r\n  }\r\n  bindResponsiveEvents() {\r\n    if (!this._responsiveListeners) {\r\n      this._responsiveListeners = {};\r\n    }\r\n    const listeners = this._responsiveListeners;\r\n    const platform = this.platform;\r\n    const _add = (type, listener) => {\r\n      platform.addEventListener(this, type, listener);\r\n      listeners[type] = listener;\r\n    };\r\n    const _remove = (type, listener) => {\r\n      if (listeners[type]) {\r\n        platform.removeEventListener(this, type, listener);\r\n        delete listeners[type];\r\n      }\r\n    };\r\n    const listener = (width, height) => {\r\n      if (this.canvas) {\r\n        this.resize(width, height);\r\n      }\r\n    };\r\n    let detached;\r\n    const attached = () => {\r\n      _remove('attach', attached);\r\n      this.attached = true;\r\n      this.resize();\r\n      _add('resize', listener);\r\n      _add('detach', detached);\r\n    };\r\n    detached = () => {\r\n      this.attached = false;\r\n      _remove('resize', listener);\r\n      this._stop();\r\n      this._resize(0, 0);\r\n      _add('attach', attached);\r\n    };\r\n    if (platform.isAttached(this.canvas)) {\r\n      attached();\r\n    } else {\r\n      detached();\r\n    }\r\n  }\r\n  unbindEvents() {\r\n    each(this._listeners, (listener, type) => {\r\n      this.platform.removeEventListener(this, type, listener);\r\n    });\r\n    this._listeners = {};\r\n    each(this._responsiveListeners, (listener, type) => {\r\n      this.platform.removeEventListener(this, type, listener);\r\n    });\r\n    this._responsiveListeners = undefined;\r\n  }\r\n  updateHoverStyle(items, mode, enabled) {\r\n    const prefix = enabled ? 'set' : 'remove';\r\n    let meta, item, i, ilen;\r\n    if (mode === 'dataset') {\r\n      meta = this.getDatasetMeta(items[0].datasetIndex);\r\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\r\n    }\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      item = items[i];\r\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\r\n      if (controller) {\r\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\r\n      }\r\n    }\r\n  }\r\n  getActiveElements() {\r\n    return this._active || [];\r\n  }\r\n  setActiveElements(activeElements) {\r\n    const lastActive = this._active || [];\r\n    const active = activeElements.map(({datasetIndex, index}) => {\r\n      const meta = this.getDatasetMeta(datasetIndex);\r\n      if (!meta) {\r\n        throw new Error('No dataset found at index ' + datasetIndex);\r\n      }\r\n      return {\r\n        datasetIndex,\r\n        element: meta.data[index],\r\n        index,\r\n      };\r\n    });\r\n    const changed = !_elementsEqual(active, lastActive);\r\n    if (changed) {\r\n      this._active = active;\r\n      this._lastEvent = null;\r\n      this._updateHoverStyles(active, lastActive);\r\n    }\r\n  }\r\n  notifyPlugins(hook, args, filter) {\r\n    return this._plugins.notify(this, hook, args, filter);\r\n  }\r\n  _updateHoverStyles(active, lastActive, replay) {\r\n    const hoverOptions = this.options.hover;\r\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\r\n    const deactivated = diff(lastActive, active);\r\n    const activated = replay ? active : diff(active, lastActive);\r\n    if (deactivated.length) {\r\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\r\n    }\r\n    if (activated.length && hoverOptions.mode) {\r\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\r\n    }\r\n  }\r\n  _eventHandler(e, replay) {\r\n    const args = {\r\n      event: e,\r\n      replay,\r\n      cancelable: true,\r\n      inChartArea: this.isPointInArea(e)\r\n    };\r\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\r\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\r\n      return;\r\n    }\r\n    const changed = this._handleEvent(e, replay, args.inChartArea);\r\n    args.cancelable = false;\r\n    this.notifyPlugins('afterEvent', args, eventFilter);\r\n    if (changed || args.changed) {\r\n      this.render();\r\n    }\r\n    return this;\r\n  }\r\n  _handleEvent(e, replay, inChartArea) {\r\n    const {_active: lastActive = [], options} = this;\r\n    const useFinalPosition = replay;\r\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\r\n    const isClick = _isClickEvent(e);\r\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\r\n    if (inChartArea) {\r\n      this._lastEvent = null;\r\n      callback(options.onHover, [e, active, this], this);\r\n      if (isClick) {\r\n        callback(options.onClick, [e, active, this], this);\r\n      }\r\n    }\r\n    const changed = !_elementsEqual(active, lastActive);\r\n    if (changed || replay) {\r\n      this._active = active;\r\n      this._updateHoverStyles(active, lastActive, replay);\r\n    }\r\n    this._lastEvent = lastEvent;\r\n    return changed;\r\n  }\r\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\r\n    if (e.type === 'mouseout') {\r\n      return [];\r\n    }\r\n    if (!inChartArea) {\r\n      return lastActive;\r\n    }\r\n    const hoverOptions = this.options.hover;\r\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\r\n  }\r\n}\r\nconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\r\nconst enumerable = true;\r\nObject.defineProperties(Chart, {\r\n  defaults: {\r\n    enumerable,\r\n    value: defaults\r\n  },\r\n  instances: {\r\n    enumerable,\r\n    value: instances\r\n  },\r\n  overrides: {\r\n    enumerable,\r\n    value: overrides\r\n  },\r\n  registry: {\r\n    enumerable,\r\n    value: registry\r\n  },\r\n  version: {\r\n    enumerable,\r\n    value: version\r\n  },\r\n  getChart: {\r\n    enumerable,\r\n    value: getChart\r\n  },\r\n  register: {\r\n    enumerable,\r\n    value: (...items) => {\r\n      registry.add(...items);\r\n      invalidatePlugins();\r\n    }\r\n  },\r\n  unregister: {\r\n    enumerable,\r\n    value: (...items) => {\r\n      registry.remove(...items);\r\n      invalidatePlugins();\r\n    }\r\n  }\r\n});\r\n\r\nfunction abstract() {\r\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\r\n}\r\nclass DateAdapter {\r\n  constructor(options) {\r\n    this.options = options || {};\r\n  }\r\n  formats() {\r\n    return abstract();\r\n  }\r\n  parse(value, format) {\r\n    return abstract();\r\n  }\r\n  format(timestamp, format) {\r\n    return abstract();\r\n  }\r\n  add(timestamp, amount, unit) {\r\n    return abstract();\r\n  }\r\n  diff(a, b, unit) {\r\n    return abstract();\r\n  }\r\n  startOf(timestamp, unit, weekday) {\r\n    return abstract();\r\n  }\r\n  endOf(timestamp, unit) {\r\n    return abstract();\r\n  }\r\n}\r\nDateAdapter.override = function(members) {\r\n  Object.assign(DateAdapter.prototype, members);\r\n};\r\nvar _adapters = {\r\n  _date: DateAdapter\r\n};\r\n\r\nfunction getAllScaleValues(scale, type) {\r\n  if (!scale._cache.$bar) {\r\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\r\n    let values = [];\r\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\r\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\r\n    }\r\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\r\n  }\r\n  return scale._cache.$bar;\r\n}\r\nfunction computeMinSampleSize(meta) {\r\n  const scale = meta.iScale;\r\n  const values = getAllScaleValues(scale, meta.type);\r\n  let min = scale._length;\r\n  let i, ilen, curr, prev;\r\n  const updateMinAndPrev = () => {\r\n    if (curr === 32767 || curr === -32768) {\r\n      return;\r\n    }\r\n    if (defined(prev)) {\r\n      min = Math.min(min, Math.abs(curr - prev) || min);\r\n    }\r\n    prev = curr;\r\n  };\r\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\r\n    curr = scale.getPixelForValue(values[i]);\r\n    updateMinAndPrev();\r\n  }\r\n  prev = undefined;\r\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\r\n    curr = scale.getPixelForTick(i);\r\n    updateMinAndPrev();\r\n  }\r\n  return min;\r\n}\r\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\r\n  const thickness = options.barThickness;\r\n  let size, ratio;\r\n  if (isNullOrUndef(thickness)) {\r\n    size = ruler.min * options.categoryPercentage;\r\n    ratio = options.barPercentage;\r\n  } else {\r\n    size = thickness * stackCount;\r\n    ratio = 1;\r\n  }\r\n  return {\r\n    chunk: size / stackCount,\r\n    ratio,\r\n    start: ruler.pixels[index] - (size / 2)\r\n  };\r\n}\r\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\r\n  const pixels = ruler.pixels;\r\n  const curr = pixels[index];\r\n  let prev = index > 0 ? pixels[index - 1] : null;\r\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\r\n  const percent = options.categoryPercentage;\r\n  if (prev === null) {\r\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\r\n  }\r\n  if (next === null) {\r\n    next = curr + curr - prev;\r\n  }\r\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\r\n  const size = Math.abs(next - prev) / 2 * percent;\r\n  return {\r\n    chunk: size / stackCount,\r\n    ratio: options.barPercentage,\r\n    start\r\n  };\r\n}\r\nfunction parseFloatBar(entry, item, vScale, i) {\r\n  const startValue = vScale.parse(entry[0], i);\r\n  const endValue = vScale.parse(entry[1], i);\r\n  const min = Math.min(startValue, endValue);\r\n  const max = Math.max(startValue, endValue);\r\n  let barStart = min;\r\n  let barEnd = max;\r\n  if (Math.abs(min) > Math.abs(max)) {\r\n    barStart = max;\r\n    barEnd = min;\r\n  }\r\n  item[vScale.axis] = barEnd;\r\n  item._custom = {\r\n    barStart,\r\n    barEnd,\r\n    start: startValue,\r\n    end: endValue,\r\n    min,\r\n    max\r\n  };\r\n}\r\nfunction parseValue(entry, item, vScale, i) {\r\n  if (isArray(entry)) {\r\n    parseFloatBar(entry, item, vScale, i);\r\n  } else {\r\n    item[vScale.axis] = vScale.parse(entry, i);\r\n  }\r\n  return item;\r\n}\r\nfunction parseArrayOrPrimitive(meta, data, start, count) {\r\n  const iScale = meta.iScale;\r\n  const vScale = meta.vScale;\r\n  const labels = iScale.getLabels();\r\n  const singleScale = iScale === vScale;\r\n  const parsed = [];\r\n  let i, ilen, item, entry;\r\n  for (i = start, ilen = start + count; i < ilen; ++i) {\r\n    entry = data[i];\r\n    item = {};\r\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\r\n    parsed.push(parseValue(entry, item, vScale, i));\r\n  }\r\n  return parsed;\r\n}\r\nfunction isFloatBar(custom) {\r\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\r\n}\r\nfunction barSign(size, vScale, actualBase) {\r\n  if (size !== 0) {\r\n    return sign(size);\r\n  }\r\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\r\n}\r\nfunction borderProps(properties) {\r\n  let reverse, start, end, top, bottom;\r\n  if (properties.horizontal) {\r\n    reverse = properties.base > properties.x;\r\n    start = 'left';\r\n    end = 'right';\r\n  } else {\r\n    reverse = properties.base < properties.y;\r\n    start = 'bottom';\r\n    end = 'top';\r\n  }\r\n  if (reverse) {\r\n    top = 'end';\r\n    bottom = 'start';\r\n  } else {\r\n    top = 'start';\r\n    bottom = 'end';\r\n  }\r\n  return {start, end, reverse, top, bottom};\r\n}\r\nfunction setBorderSkipped(properties, options, stack, index) {\r\n  let edge = options.borderSkipped;\r\n  const res = {};\r\n  if (!edge) {\r\n    properties.borderSkipped = res;\r\n    return;\r\n  }\r\n  const {start, end, reverse, top, bottom} = borderProps(properties);\r\n  if (edge === 'middle' && stack) {\r\n    properties.enableBorderRadius = true;\r\n    if ((stack._top || 0) === index) {\r\n      edge = top;\r\n    } else if ((stack._bottom || 0) === index) {\r\n      edge = bottom;\r\n    } else {\r\n      res[parseEdge(bottom, start, end, reverse)] = true;\r\n      edge = top;\r\n    }\r\n  }\r\n  res[parseEdge(edge, start, end, reverse)] = true;\r\n  properties.borderSkipped = res;\r\n}\r\nfunction parseEdge(edge, a, b, reverse) {\r\n  if (reverse) {\r\n    edge = swap(edge, a, b);\r\n    edge = startEnd(edge, b, a);\r\n  } else {\r\n    edge = startEnd(edge, a, b);\r\n  }\r\n  return edge;\r\n}\r\nfunction swap(orig, v1, v2) {\r\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\r\n}\r\nfunction startEnd(v, start, end) {\r\n  return v === 'start' ? start : v === 'end' ? end : v;\r\n}\r\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\r\n  properties.inflateAmount = inflateAmount === 'auto'\r\n    ? ratio === 1 ? 0.33 : 0\r\n    : inflateAmount;\r\n}\r\nclass BarController extends DatasetController {\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    return parseArrayOrPrimitive(meta, data, start, count);\r\n  }\r\n  parseArrayData(meta, data, start, count) {\r\n    return parseArrayOrPrimitive(meta, data, start, count);\r\n  }\r\n  parseObjectData(meta, data, start, count) {\r\n    const {iScale, vScale} = meta;\r\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\r\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\r\n    const parsed = [];\r\n    let i, ilen, item, obj;\r\n    for (i = start, ilen = start + count; i < ilen; ++i) {\r\n      obj = data[i];\r\n      item = {};\r\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\r\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\r\n    }\r\n    return parsed;\r\n  }\r\n  updateRangeFromParsed(range, scale, parsed, stack) {\r\n    super.updateRangeFromParsed(range, scale, parsed, stack);\r\n    const custom = parsed._custom;\r\n    if (custom && scale === this._cachedMeta.vScale) {\r\n      range.min = Math.min(range.min, custom.min);\r\n      range.max = Math.max(range.max, custom.max);\r\n    }\r\n  }\r\n  getMaxOverflow() {\r\n    return 0;\r\n  }\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const {iScale, vScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const custom = parsed._custom;\r\n    const value = isFloatBar(custom)\r\n      ? '[' + custom.start + ', ' + custom.end + ']'\r\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\r\n    return {\r\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\r\n      value\r\n    };\r\n  }\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    super.initialize();\r\n    const meta = this._cachedMeta;\r\n    meta.stack = this.getDataset().stack;\r\n  }\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    this.updateElements(meta.data, 0, meta.data.length, mode);\r\n  }\r\n  updateElements(bars, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {index, _cachedMeta: {vScale}} = this;\r\n    const base = vScale.getBasePixel();\r\n    const horizontal = vScale.isHorizontal();\r\n    const ruler = this._getRuler();\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions);\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n    for (let i = start; i < start + count; i++) {\r\n      const parsed = this.getParsed(i);\r\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\r\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\r\n      const stack = (parsed._stacks || {})[vScale.axis];\r\n      const properties = {\r\n        horizontal,\r\n        base: vpixels.base,\r\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\r\n        x: horizontal ? vpixels.head : ipixels.center,\r\n        y: horizontal ? ipixels.center : vpixels.head,\r\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\r\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\r\n      };\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\r\n      }\r\n      const options = properties.options || bars[i].options;\r\n      setBorderSkipped(properties, options, stack, index);\r\n      setInflateAmount(properties, options, ruler.ratio);\r\n      this.updateElement(bars[i], i, properties, mode);\r\n    }\r\n  }\r\n  _getStacks(last, dataIndex) {\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const metasets = iScale.getMatchingVisibleMetas(this._type);\r\n    const stacked = iScale.options.stacked;\r\n    const ilen = metasets.length;\r\n    const stacks = [];\r\n    let i, item;\r\n    for (i = 0; i < ilen; ++i) {\r\n      item = metasets[i];\r\n      if (!item.controller.options.grouped) {\r\n        continue;\r\n      }\r\n      if (typeof dataIndex !== 'undefined') {\r\n        const val = item.controller.getParsed(dataIndex)[\r\n          item.controller._cachedMeta.vScale.axis\r\n        ];\r\n        if (isNullOrUndef(val) || isNaN(val)) {\r\n          continue;\r\n        }\r\n      }\r\n      if (stacked === false || stacks.indexOf(item.stack) === -1 ||\r\n\t\t\t\t(stacked === undefined && item.stack === undefined)) {\r\n        stacks.push(item.stack);\r\n      }\r\n      if (item.index === last) {\r\n        break;\r\n      }\r\n    }\r\n    if (!stacks.length) {\r\n      stacks.push(undefined);\r\n    }\r\n    return stacks;\r\n  }\r\n  _getStackCount(index) {\r\n    return this._getStacks(undefined, index).length;\r\n  }\r\n  _getStackIndex(datasetIndex, name, dataIndex) {\r\n    const stacks = this._getStacks(datasetIndex, dataIndex);\r\n    const index = (name !== undefined)\r\n      ? stacks.indexOf(name)\r\n      : -1;\r\n    return (index === -1)\r\n      ? stacks.length - 1\r\n      : index;\r\n  }\r\n  _getRuler() {\r\n    const opts = this.options;\r\n    const meta = this._cachedMeta;\r\n    const iScale = meta.iScale;\r\n    const pixels = [];\r\n    let i, ilen;\r\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\r\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\r\n    }\r\n    const barThickness = opts.barThickness;\r\n    const min = barThickness || computeMinSampleSize(meta);\r\n    return {\r\n      min,\r\n      pixels,\r\n      start: iScale._startPixel,\r\n      end: iScale._endPixel,\r\n      stackCount: this._getStackCount(),\r\n      scale: iScale,\r\n      grouped: opts.grouped,\r\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\r\n    };\r\n  }\r\n  _calculateBarValuePixels(index) {\r\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\r\n    const actualBase = baseValue || 0;\r\n    const parsed = this.getParsed(index);\r\n    const custom = parsed._custom;\r\n    const floating = isFloatBar(custom);\r\n    let value = parsed[vScale.axis];\r\n    let start = 0;\r\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\r\n    let head, size;\r\n    if (length !== value) {\r\n      start = length - value;\r\n      length = value;\r\n    }\r\n    if (floating) {\r\n      value = custom.barStart;\r\n      length = custom.barEnd - custom.barStart;\r\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\r\n        start = 0;\r\n      }\r\n      start += value;\r\n    }\r\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\r\n    let base = vScale.getPixelForValue(startValue);\r\n    if (this.chart.getDataVisibility(index)) {\r\n      head = vScale.getPixelForValue(start + length);\r\n    } else {\r\n      head = base;\r\n    }\r\n    size = head - base;\r\n    if (Math.abs(size) < minBarLength) {\r\n      size = barSign(size, vScale, actualBase) * minBarLength;\r\n      if (value === actualBase) {\r\n        base -= size / 2;\r\n      }\r\n      const startPixel = vScale.getPixelForDecimal(0);\r\n      const endPixel = vScale.getPixelForDecimal(1);\r\n      const min = Math.min(startPixel, endPixel);\r\n      const max = Math.max(startPixel, endPixel);\r\n      base = Math.max(Math.min(base, max), min);\r\n      head = base + size;\r\n    }\r\n    if (base === vScale.getPixelForValue(actualBase)) {\r\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\r\n      base += halfGrid;\r\n      size -= halfGrid;\r\n    }\r\n    return {\r\n      size,\r\n      base,\r\n      head,\r\n      center: head + size / 2\r\n    };\r\n  }\r\n  _calculateBarIndexPixels(index, ruler) {\r\n    const scale = ruler.scale;\r\n    const options = this.options;\r\n    const skipNull = options.skipNull;\r\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\r\n    let center, size;\r\n    if (ruler.grouped) {\r\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\r\n      const range = options.barThickness === 'flex'\r\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\r\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\r\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\r\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\r\n    } else {\r\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\r\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\r\n    }\r\n    return {\r\n      base: center - size / 2,\r\n      head: center + size / 2,\r\n      center,\r\n      size\r\n    };\r\n  }\r\n  draw() {\r\n    const meta = this._cachedMeta;\r\n    const vScale = meta.vScale;\r\n    const rects = meta.data;\r\n    const ilen = rects.length;\r\n    let i = 0;\r\n    for (; i < ilen; ++i) {\r\n      if (this.getParsed(i)[vScale.axis] !== null) {\r\n        rects[i].draw(this._ctx);\r\n      }\r\n    }\r\n  }\r\n}\r\nBarController.id = 'bar';\r\nBarController.defaults = {\r\n  datasetElementType: false,\r\n  dataElementType: 'bar',\r\n  categoryPercentage: 0.8,\r\n  barPercentage: 0.9,\r\n  grouped: true,\r\n  animations: {\r\n    numbers: {\r\n      type: 'number',\r\n      properties: ['x', 'y', 'base', 'width', 'height']\r\n    }\r\n  }\r\n};\r\nBarController.overrides = {\r\n  scales: {\r\n    _index_: {\r\n      type: 'category',\r\n      offset: true,\r\n      grid: {\r\n        offset: true\r\n      }\r\n    },\r\n    _value_: {\r\n      type: 'linear',\r\n      beginAtZero: true,\r\n    }\r\n  }\r\n};\r\n\r\nclass BubbleController extends DatasetController {\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    super.initialize();\r\n  }\r\n  parsePrimitiveData(meta, data, start, count) {\r\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\r\n    }\r\n    return parsed;\r\n  }\r\n  parseArrayData(meta, data, start, count) {\r\n    const parsed = super.parseArrayData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      const item = data[start + i];\r\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\r\n    }\r\n    return parsed;\r\n  }\r\n  parseObjectData(meta, data, start, count) {\r\n    const parsed = super.parseObjectData(meta, data, start, count);\r\n    for (let i = 0; i < parsed.length; i++) {\r\n      const item = data[start + i];\r\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\r\n    }\r\n    return parsed;\r\n  }\r\n  getMaxOverflow() {\r\n    const data = this._cachedMeta.data;\r\n    let max = 0;\r\n    for (let i = data.length - 1; i >= 0; --i) {\r\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\r\n    }\r\n    return max > 0 && max;\r\n  }\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const {xScale, yScale} = meta;\r\n    const parsed = this.getParsed(index);\r\n    const x = xScale.getLabelForValue(parsed.x);\r\n    const y = yScale.getLabelForValue(parsed.y);\r\n    const r = parsed._custom;\r\n    return {\r\n      label: meta.label,\r\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\r\n    };\r\n  }\r\n  update(mode) {\r\n    const points = this._cachedMeta.data;\r\n    this.updateElements(points, 0, points.length, mode);\r\n  }\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale} = this._cachedMeta;\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    for (let i = start; i < start + count; i++) {\r\n      const point = points[i];\r\n      const parsed = !reset && this.getParsed(i);\r\n      const properties = {};\r\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\r\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\r\n      if (includeOptions) {\r\n        properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n        if (reset) {\r\n          properties.options.radius = 0;\r\n        }\r\n      }\r\n      this.updateElement(point, i, properties, mode);\r\n    }\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n  }\r\n  resolveDataElementOptions(index, mode) {\r\n    const parsed = this.getParsed(index);\r\n    let values = super.resolveDataElementOptions(index, mode);\r\n    if (values.$shared) {\r\n      values = Object.assign({}, values, {$shared: false});\r\n    }\r\n    const radius = values.radius;\r\n    if (mode !== 'active') {\r\n      values.radius = 0;\r\n    }\r\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\r\n    return values;\r\n  }\r\n}\r\nBubbleController.id = 'bubble';\r\nBubbleController.defaults = {\r\n  datasetElementType: false,\r\n  dataElementType: 'point',\r\n  animations: {\r\n    numbers: {\r\n      type: 'number',\r\n      properties: ['x', 'y', 'borderWidth', 'radius']\r\n    }\r\n  }\r\n};\r\nBubbleController.overrides = {\r\n  scales: {\r\n    x: {\r\n      type: 'linear'\r\n    },\r\n    y: {\r\n      type: 'linear'\r\n    }\r\n  },\r\n  plugins: {\r\n    tooltip: {\r\n      callbacks: {\r\n        title() {\r\n          return '';\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nfunction getRatioAndOffset(rotation, circumference, cutout) {\r\n  let ratioX = 1;\r\n  let ratioY = 1;\r\n  let offsetX = 0;\r\n  let offsetY = 0;\r\n  if (circumference < TAU) {\r\n    const startAngle = rotation;\r\n    const endAngle = startAngle + circumference;\r\n    const startX = Math.cos(startAngle);\r\n    const startY = Math.sin(startAngle);\r\n    const endX = Math.cos(endAngle);\r\n    const endY = Math.sin(endAngle);\r\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\r\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\r\n    const maxX = calcMax(0, startX, endX);\r\n    const maxY = calcMax(HALF_PI, startY, endY);\r\n    const minX = calcMin(PI, startX, endX);\r\n    const minY = calcMin(PI + HALF_PI, startY, endY);\r\n    ratioX = (maxX - minX) / 2;\r\n    ratioY = (maxY - minY) / 2;\r\n    offsetX = -(maxX + minX) / 2;\r\n    offsetY = -(maxY + minY) / 2;\r\n  }\r\n  return {ratioX, ratioY, offsetX, offsetY};\r\n}\r\nclass DoughnutController extends DatasetController {\r\n  constructor(chart, datasetIndex) {\r\n    super(chart, datasetIndex);\r\n    this.enableOptionSharing = true;\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n    this.offsetX = undefined;\r\n    this.offsetY = undefined;\r\n  }\r\n  linkScales() {}\r\n  parse(start, count) {\r\n    const data = this.getDataset().data;\r\n    const meta = this._cachedMeta;\r\n    if (this._parsing === false) {\r\n      meta._parsed = data;\r\n    } else {\r\n      let getter = (i) => +data[i];\r\n      if (isObject(data[start])) {\r\n        const {key = 'value'} = this._parsing;\r\n        getter = (i) => +resolveObjectKey(data[i], key);\r\n      }\r\n      let i, ilen;\r\n      for (i = start, ilen = start + count; i < ilen; ++i) {\r\n        meta._parsed[i] = getter(i);\r\n      }\r\n    }\r\n  }\r\n  _getRotation() {\r\n    return toRadians(this.options.rotation - 90);\r\n  }\r\n  _getCircumference() {\r\n    return toRadians(this.options.circumference);\r\n  }\r\n  _getRotationExtents() {\r\n    let min = TAU;\r\n    let max = -TAU;\r\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\r\n      if (this.chart.isDatasetVisible(i)) {\r\n        const controller = this.chart.getDatasetMeta(i).controller;\r\n        const rotation = controller._getRotation();\r\n        const circumference = controller._getCircumference();\r\n        min = Math.min(min, rotation);\r\n        max = Math.max(max, rotation + circumference);\r\n      }\r\n    }\r\n    return {\r\n      rotation: min,\r\n      circumference: max - min,\r\n    };\r\n  }\r\n  update(mode) {\r\n    const chart = this.chart;\r\n    const {chartArea} = chart;\r\n    const meta = this._cachedMeta;\r\n    const arcs = meta.data;\r\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\r\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\r\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\r\n    const chartWeight = this._getRingWeight(this.index);\r\n    const {circumference, rotation} = this._getRotationExtents();\r\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\r\n    const maxWidth = (chartArea.width - spacing) / ratioX;\r\n    const maxHeight = (chartArea.height - spacing) / ratioY;\r\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\r\n    const outerRadius = toDimension(this.options.radius, maxRadius);\r\n    const innerRadius = Math.max(outerRadius * cutout, 0);\r\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\r\n    this.offsetX = offsetX * outerRadius;\r\n    this.offsetY = offsetY * outerRadius;\r\n    meta.total = this.calculateTotal();\r\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\r\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\r\n    this.updateElements(arcs, 0, arcs.length, mode);\r\n  }\r\n  _circumference(i, reset) {\r\n    const opts = this.options;\r\n    const meta = this._cachedMeta;\r\n    const circumference = this._getCircumference();\r\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\r\n      return 0;\r\n    }\r\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\r\n  }\r\n  updateElements(arcs, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const chart = this.chart;\r\n    const chartArea = chart.chartArea;\r\n    const opts = chart.options;\r\n    const animationOpts = opts.animation;\r\n    const centerX = (chartArea.left + chartArea.right) / 2;\r\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\r\n    const animateScale = reset && animationOpts.animateScale;\r\n    const innerRadius = animateScale ? 0 : this.innerRadius;\r\n    const outerRadius = animateScale ? 0 : this.outerRadius;\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions);\r\n    let startAngle = this._getRotation();\r\n    let i;\r\n    for (i = 0; i < start; ++i) {\r\n      startAngle += this._circumference(i, reset);\r\n    }\r\n    for (i = start; i < start + count; ++i) {\r\n      const circumference = this._circumference(i, reset);\r\n      const arc = arcs[i];\r\n      const properties = {\r\n        x: centerX + this.offsetX,\r\n        y: centerY + this.offsetY,\r\n        startAngle,\r\n        endAngle: startAngle + circumference,\r\n        circumference,\r\n        outerRadius,\r\n        innerRadius\r\n      };\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\r\n      }\r\n      startAngle += circumference;\r\n      this.updateElement(arc, i, properties, mode);\r\n    }\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n  }\r\n  calculateTotal() {\r\n    const meta = this._cachedMeta;\r\n    const metaData = meta.data;\r\n    let total = 0;\r\n    let i;\r\n    for (i = 0; i < metaData.length; i++) {\r\n      const value = meta._parsed[i];\r\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\r\n        total += Math.abs(value);\r\n      }\r\n    }\r\n    return total;\r\n  }\r\n  calculateCircumference(value) {\r\n    const total = this._cachedMeta.total;\r\n    if (total > 0 && !isNaN(value)) {\r\n      return TAU * (Math.abs(value) / total);\r\n    }\r\n    return 0;\r\n  }\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const chart = this.chart;\r\n    const labels = chart.data.labels || [];\r\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\r\n    return {\r\n      label: labels[index] || '',\r\n      value,\r\n    };\r\n  }\r\n  getMaxBorderWidth(arcs) {\r\n    let max = 0;\r\n    const chart = this.chart;\r\n    let i, ilen, meta, controller, options;\r\n    if (!arcs) {\r\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\r\n        if (chart.isDatasetVisible(i)) {\r\n          meta = chart.getDatasetMeta(i);\r\n          arcs = meta.data;\r\n          controller = meta.controller;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (!arcs) {\r\n      return 0;\r\n    }\r\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n      options = controller.resolveDataElementOptions(i);\r\n      if (options.borderAlign !== 'inner') {\r\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\r\n      }\r\n    }\r\n    return max;\r\n  }\r\n  getMaxOffset(arcs) {\r\n    let max = 0;\r\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\r\n      const options = this.resolveDataElementOptions(i);\r\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\r\n    }\r\n    return max;\r\n  }\r\n  _getRingWeightOffset(datasetIndex) {\r\n    let ringWeightOffset = 0;\r\n    for (let i = 0; i < datasetIndex; ++i) {\r\n      if (this.chart.isDatasetVisible(i)) {\r\n        ringWeightOffset += this._getRingWeight(i);\r\n      }\r\n    }\r\n    return ringWeightOffset;\r\n  }\r\n  _getRingWeight(datasetIndex) {\r\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\r\n  }\r\n  _getVisibleDatasetWeightTotal() {\r\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\r\n  }\r\n}\r\nDoughnutController.id = 'doughnut';\r\nDoughnutController.defaults = {\r\n  datasetElementType: false,\r\n  dataElementType: 'arc',\r\n  animation: {\r\n    animateRotate: true,\r\n    animateScale: false\r\n  },\r\n  animations: {\r\n    numbers: {\r\n      type: 'number',\r\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\r\n    },\r\n  },\r\n  cutout: '50%',\r\n  rotation: 0,\r\n  circumference: 360,\r\n  radius: '100%',\r\n  spacing: 0,\r\n  indexAxis: 'r',\r\n};\r\nDoughnutController.descriptors = {\r\n  _scriptable: (name) => name !== 'spacing',\r\n  _indexable: (name) => name !== 'spacing',\r\n};\r\nDoughnutController.overrides = {\r\n  aspectRatio: 1,\r\n  plugins: {\r\n    legend: {\r\n      labels: {\r\n        generateLabels(chart) {\r\n          const data = chart.data;\r\n          if (data.labels.length && data.datasets.length) {\r\n            const {labels: {pointStyle}} = chart.legend.options;\r\n            return data.labels.map((label, i) => {\r\n              const meta = chart.getDatasetMeta(0);\r\n              const style = meta.controller.getStyle(i);\r\n              return {\r\n                text: label,\r\n                fillStyle: style.backgroundColor,\r\n                strokeStyle: style.borderColor,\r\n                lineWidth: style.borderWidth,\r\n                pointStyle: pointStyle,\r\n                hidden: !chart.getDataVisibility(i),\r\n                index: i\r\n              };\r\n            });\r\n          }\r\n          return [];\r\n        }\r\n      },\r\n      onClick(e, legendItem, legend) {\r\n        legend.chart.toggleDataVisibility(legendItem.index);\r\n        legend.chart.update();\r\n      }\r\n    },\r\n    tooltip: {\r\n      callbacks: {\r\n        title() {\r\n          return '';\r\n        },\r\n        label(tooltipItem) {\r\n          let dataLabel = tooltipItem.label;\r\n          const value = ': ' + tooltipItem.formattedValue;\r\n          if (isArray(dataLabel)) {\r\n            dataLabel = dataLabel.slice();\r\n            dataLabel[0] += value;\r\n          } else {\r\n            dataLabel += value;\r\n          }\r\n          return dataLabel;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nclass LineController extends DatasetController {\r\n  initialize() {\r\n    this.enableOptionSharing = true;\r\n    this.supportsDecimation = true;\r\n    super.initialize();\r\n  }\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const {dataset: line, data: points = [], _dataset} = meta;\r\n    const animationsDisabled = this.chart._animationsDisabled;\r\n    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\r\n    this._drawStart = start;\r\n    this._drawCount = count;\r\n    if (scaleRangesChanged(meta)) {\r\n      start = 0;\r\n      count = points.length;\r\n    }\r\n    line._chart = this.chart;\r\n    line._datasetIndex = this.index;\r\n    line._decimated = !!_dataset._decimated;\r\n    line.points = points;\r\n    const options = this.resolveDatasetElementOptions(mode);\r\n    if (!this.options.showLine) {\r\n      options.borderWidth = 0;\r\n    }\r\n    options.segment = this.options.segment;\r\n    this.updateElement(line, undefined, {\r\n      animated: !animationsDisabled,\r\n      options\r\n    }, mode);\r\n    this.updateElements(points, start, count, mode);\r\n  }\r\n  updateElements(points, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\r\n    const firstOpts = this.resolveDataElementOptions(start, mode);\r\n    const sharedOptions = this.getSharedOptions(firstOpts);\r\n    const includeOptions = this.includeOptions(mode, sharedOptions);\r\n    const iAxis = iScale.axis;\r\n    const vAxis = vScale.axis;\r\n    const {spanGaps, segment} = this.options;\r\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\r\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\r\n    let prevParsed = start > 0 && this.getParsed(start - 1);\r\n    for (let i = start; i < start + count; ++i) {\r\n      const point = points[i];\r\n      const parsed = this.getParsed(i);\r\n      const properties = directUpdate ? point : {};\r\n      const nullData = isNullOrUndef(parsed[vAxis]);\r\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\r\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\r\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\r\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\r\n      if (segment) {\r\n        properties.parsed = parsed;\r\n        properties.raw = _dataset.data[i];\r\n      }\r\n      if (includeOptions) {\r\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      }\r\n      if (!directUpdate) {\r\n        this.updateElement(point, i, properties, mode);\r\n      }\r\n      prevParsed = parsed;\r\n    }\r\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\r\n  }\r\n  getMaxOverflow() {\r\n    const meta = this._cachedMeta;\r\n    const dataset = meta.dataset;\r\n    const border = dataset.options && dataset.options.borderWidth || 0;\r\n    const data = meta.data || [];\r\n    if (!data.length) {\r\n      return border;\r\n    }\r\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\r\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\r\n    return Math.max(border, firstPoint, lastPoint) / 2;\r\n  }\r\n  draw() {\r\n    const meta = this._cachedMeta;\r\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\r\n    super.draw();\r\n  }\r\n}\r\nLineController.id = 'line';\r\nLineController.defaults = {\r\n  datasetElementType: 'line',\r\n  dataElementType: 'point',\r\n  showLine: true,\r\n  spanGaps: false,\r\n};\r\nLineController.overrides = {\r\n  scales: {\r\n    _index_: {\r\n      type: 'category',\r\n    },\r\n    _value_: {\r\n      type: 'linear',\r\n    },\r\n  }\r\n};\r\nfunction getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\r\n  const pointCount = points.length;\r\n  let start = 0;\r\n  let count = pointCount;\r\n  if (meta._sorted) {\r\n    const {iScale, _parsed} = meta;\r\n    const axis = iScale.axis;\r\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n    if (minDefined) {\r\n      start = _limitValue(Math.min(\r\n        _lookupByKey(_parsed, iScale.axis, min).lo,\r\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\r\n      0, pointCount - 1);\r\n    }\r\n    if (maxDefined) {\r\n      count = _limitValue(Math.max(\r\n        _lookupByKey(_parsed, iScale.axis, max).hi + 1,\r\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),\r\n      start, pointCount) - start;\r\n    } else {\r\n      count = pointCount - start;\r\n    }\r\n  }\r\n  return {start, count};\r\n}\r\nfunction scaleRangesChanged(meta) {\r\n  const {xScale, yScale, _scaleRanges} = meta;\r\n  const newRanges = {\r\n    xmin: xScale.min,\r\n    xmax: xScale.max,\r\n    ymin: yScale.min,\r\n    ymax: yScale.max\r\n  };\r\n  if (!_scaleRanges) {\r\n    meta._scaleRanges = newRanges;\r\n    return true;\r\n  }\r\n  const changed = _scaleRanges.xmin !== xScale.min\r\n\t\t|| _scaleRanges.xmax !== xScale.max\r\n\t\t|| _scaleRanges.ymin !== yScale.min\r\n\t\t|| _scaleRanges.ymax !== yScale.max;\r\n  Object.assign(_scaleRanges, newRanges);\r\n  return changed;\r\n}\r\n\r\nclass PolarAreaController extends DatasetController {\r\n  constructor(chart, datasetIndex) {\r\n    super(chart, datasetIndex);\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n  }\r\n  getLabelAndValue(index) {\r\n    const meta = this._cachedMeta;\r\n    const chart = this.chart;\r\n    const labels = chart.data.labels || [];\r\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\r\n    return {\r\n      label: labels[index] || '',\r\n      value,\r\n    };\r\n  }\r\n  parseObjectData(meta, data, start, count) {\r\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n  }\r\n  update(mode) {\r\n    const arcs = this._cachedMeta.data;\r\n    this._updateRadius();\r\n    this.updateElements(arcs, 0, arcs.length, mode);\r\n  }\r\n  getMinMax() {\r\n    const meta = this._cachedMeta;\r\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\r\n    meta.data.forEach((element, index) => {\r\n      const parsed = this.getParsed(index).r;\r\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\r\n        if (parsed < range.min) {\r\n          range.min = parsed;\r\n        }\r\n        if (parsed > range.max) {\r\n          range.max = parsed;\r\n        }\r\n      }\r\n    });\r\n    return range;\r\n  }\r\n  _updateRadius() {\r\n    const chart = this.chart;\r\n    const chartArea = chart.chartArea;\r\n    const opts = chart.options;\r\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n    const outerRadius = Math.max(minSize / 2, 0);\r\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\r\n    this.outerRadius = outerRadius - (radiusLength * this.index);\r\n    this.innerRadius = this.outerRadius - radiusLength;\r\n  }\r\n  updateElements(arcs, start, count, mode) {\r\n    const reset = mode === 'reset';\r\n    const chart = this.chart;\r\n    const opts = chart.options;\r\n    const animationOpts = opts.animation;\r\n    const scale = this._cachedMeta.rScale;\r\n    const centerX = scale.xCenter;\r\n    const centerY = scale.yCenter;\r\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\r\n    let angle = datasetStartAngle;\r\n    let i;\r\n    const defaultAngle = 360 / this.countVisibleElements();\r\n    for (i = 0; i < start; ++i) {\r\n      angle += this._computeAngle(i, mode, defaultAngle);\r\n    }\r\n    for (i = start; i < start + count; i++) {\r\n      const arc = arcs[i];\r\n      let startAngle = angle;\r\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\r\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\r\n      angle = endAngle;\r\n      if (reset) {\r\n        if (animationOpts.animateScale) {\r\n          outerRadius = 0;\r\n        }\r\n        if (animationOpts.animateRotate) {\r\n          startAngle = endAngle = datasetStartAngle;\r\n        }\r\n      }\r\n      const properties = {\r\n        x: centerX,\r\n        y: centerY,\r\n        innerRadius: 0,\r\n        outerRadius,\r\n        startAngle,\r\n        endAngle,\r\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\r\n      };\r\n      this.updateElement(arc, i, properties, mode);\r\n    }\r\n  }\r\n  countVisibleElements() {\r\n    const meta = this._cachedMeta;\r\n    let count = 0;\r\n    meta.data.forEach((element, index) => {\r\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\r\n        count++;\r\n      }\r\n    });\r\n    return count;\r\n  }\r\n  _computeAngle(index, mode, defaultAngle) {\r\n    return this.chart.getDataVisibility(index)\r\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\r\n      : 0;\r\n  }\r\n}\r\nPolarAreaController.id = 'polarArea';\r\nPolarAreaController.defaults = {\r\n  dataElementType: 'arc',\r\n  animation: {\r\n    animateRotate: true,\r\n    animateScale: true\r\n  },\r\n  animations: {\r\n    numbers: {\r\n      type: 'number',\r\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\r\n    },\r\n  },\r\n  indexAxis: 'r',\r\n  startAngle: 0,\r\n};\r\nPolarAreaController.overrides = {\r\n  aspectRatio: 1,\r\n  plugins: {\r\n    legend: {\r\n      labels: {\r\n        generateLabels(chart) {\r\n          const data = chart.data;\r\n          if (data.labels.length && data.datasets.length) {\r\n            const {labels: {pointStyle}} = chart.legend.options;\r\n            return data.labels.map((label, i) => {\r\n              const meta = chart.getDatasetMeta(0);\r\n              const style = meta.controller.getStyle(i);\r\n              return {\r\n                text: label,\r\n                fillStyle: style.backgroundColor,\r\n                strokeStyle: style.borderColor,\r\n                lineWidth: style.borderWidth,\r\n                pointStyle: pointStyle,\r\n                hidden: !chart.getDataVisibility(i),\r\n                index: i\r\n              };\r\n            });\r\n          }\r\n          return [];\r\n        }\r\n      },\r\n      onClick(e, legendItem, legend) {\r\n        legend.chart.toggleDataVisibility(legendItem.index);\r\n        legend.chart.update();\r\n      }\r\n    },\r\n    tooltip: {\r\n      callbacks: {\r\n        title() {\r\n          return '';\r\n        },\r\n        label(context) {\r\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\r\n        }\r\n      }\r\n    }\r\n  },\r\n  scales: {\r\n    r: {\r\n      type: 'radialLinear',\r\n      angleLines: {\r\n        display: false\r\n      },\r\n      beginAtZero: true,\r\n      grid: {\r\n        circular: true\r\n      },\r\n      pointLabels: {\r\n        display: false\r\n      },\r\n      startAngle: 0\r\n    }\r\n  }\r\n};\r\n\r\nclass PieController extends DoughnutController {\r\n}\r\nPieController.id = 'pie';\r\nPieController.defaults = {\r\n  cutout: 0,\r\n  rotation: 0,\r\n  circumference: 360,\r\n  radius: '100%'\r\n};\r\n\r\nclass RadarController extends DatasetController {\r\n  getLabelAndValue(index) {\r\n    const vScale = this._cachedMeta.vScale;\r\n    const parsed = this.getParsed(index);\r\n    return {\r\n      label: vScale.getLabels()[index],\r\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\r\n    };\r\n  }\r\n  parseObjectData(meta, data, start, count) {\r\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\r\n  }\r\n  update(mode) {\r\n    const meta = this._cachedMeta;\r\n    const line = meta.dataset;\r\n    const points = meta.data || [];\r\n    const labels = meta.iScale.getLabels();\r\n    line.points = points;\r\n    if (mode !== 'resize') {\r\n      const options = this.resolveDatasetElementOptions(mode);\r\n      if (!this.options.showLine) {\r\n        options.borderWidth = 0;\r\n      }\r\n      const properties = {\r\n        _loop: true,\r\n        _fullLoop: labels.length === points.length,\r\n        options\r\n      };\r\n      this.updateElement(line, undefined, properties, mode);\r\n    }\r\n    this.updateElements(points, 0, points.length, mode);\r\n  }\r\n  updateElements(points, start, count, mode) {\r\n    const scale = this._cachedMeta.rScale;\r\n    const reset = mode === 'reset';\r\n    for (let i = start; i < start + count; i++) {\r\n      const point = points[i];\r\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\r\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\r\n      const x = reset ? scale.xCenter : pointPosition.x;\r\n      const y = reset ? scale.yCenter : pointPosition.y;\r\n      const properties = {\r\n        x,\r\n        y,\r\n        angle: pointPosition.angle,\r\n        skip: isNaN(x) || isNaN(y),\r\n        options\r\n      };\r\n      this.updateElement(point, i, properties, mode);\r\n    }\r\n  }\r\n}\r\nRadarController.id = 'radar';\r\nRadarController.defaults = {\r\n  datasetElementType: 'line',\r\n  dataElementType: 'point',\r\n  indexAxis: 'r',\r\n  showLine: true,\r\n  elements: {\r\n    line: {\r\n      fill: 'start'\r\n    }\r\n  },\r\n};\r\nRadarController.overrides = {\r\n  aspectRatio: 1,\r\n  scales: {\r\n    r: {\r\n      type: 'radialLinear',\r\n    }\r\n  }\r\n};\r\n\r\nclass ScatterController extends LineController {\r\n}\r\nScatterController.id = 'scatter';\r\nScatterController.defaults = {\r\n  showLine: false,\r\n  fill: false\r\n};\r\nScatterController.overrides = {\r\n  interaction: {\r\n    mode: 'point'\r\n  },\r\n  plugins: {\r\n    tooltip: {\r\n      callbacks: {\r\n        title() {\r\n          return '';\r\n        },\r\n        label(item) {\r\n          return '(' + item.label + ', ' + item.formattedValue + ')';\r\n        }\r\n      }\r\n    }\r\n  },\r\n  scales: {\r\n    x: {\r\n      type: 'linear'\r\n    },\r\n    y: {\r\n      type: 'linear'\r\n    }\r\n  }\r\n};\r\n\r\nvar controllers = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nBarController: BarController,\r\nBubbleController: BubbleController,\r\nDoughnutController: DoughnutController,\r\nLineController: LineController,\r\nPolarAreaController: PolarAreaController,\r\nPieController: PieController,\r\nRadarController: RadarController,\r\nScatterController: ScatterController\r\n});\r\n\r\nfunction clipArc(ctx, element, endAngle) {\r\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\r\n  let angleMargin = pixelMargin / outerRadius;\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\r\n  if (innerRadius > pixelMargin) {\r\n    angleMargin = pixelMargin / innerRadius;\r\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\r\n  } else {\r\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\r\n  }\r\n  ctx.closePath();\r\n  ctx.clip();\r\n}\r\nfunction toRadiusCorners(value) {\r\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\r\n}\r\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\r\n  const o = toRadiusCorners(arc.options.borderRadius);\r\n  const halfThickness = (outerRadius - innerRadius) / 2;\r\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\r\n  const computeOuterLimit = (val) => {\r\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\r\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\r\n  };\r\n  return {\r\n    outerStart: computeOuterLimit(o.outerStart),\r\n    outerEnd: computeOuterLimit(o.outerEnd),\r\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\r\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\r\n  };\r\n}\r\nfunction rThetaToXY(r, theta, x, y) {\r\n  return {\r\n    x: x + r * Math.cos(theta),\r\n    y: y + r * Math.sin(theta),\r\n  };\r\n}\r\nfunction pathArc(ctx, element, offset, spacing, end) {\r\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\r\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\r\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\r\n  let spacingOffset = 0;\r\n  const alpha = end - start;\r\n  if (spacing) {\r\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\r\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\r\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\r\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\r\n    spacingOffset = (alpha - adjustedAngle) / 2;\r\n  }\r\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\r\n  const angleOffset = (alpha - beta) / 2;\r\n  const startAngle = start + angleOffset + spacingOffset;\r\n  const endAngle = end - angleOffset - spacingOffset;\r\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\r\n  const outerStartAdjustedRadius = outerRadius - outerStart;\r\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\r\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\r\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\r\n  const innerStartAdjustedRadius = innerRadius + innerStart;\r\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\r\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\r\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\r\n  if (outerEnd > 0) {\r\n    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\r\n    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\r\n  }\r\n  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\r\n  ctx.lineTo(p4.x, p4.y);\r\n  if (innerEnd > 0) {\r\n    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\r\n    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\r\n  }\r\n  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\r\n  if (innerStart > 0) {\r\n    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\r\n    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\r\n  }\r\n  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\r\n  ctx.lineTo(p8.x, p8.y);\r\n  if (outerStart > 0) {\r\n    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\r\n    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\r\n  }\r\n  ctx.closePath();\r\n}\r\nfunction drawArc(ctx, element, offset, spacing) {\r\n  const {fullCircles, startAngle, circumference} = element;\r\n  let endAngle = element.endAngle;\r\n  if (fullCircles) {\r\n    pathArc(ctx, element, offset, spacing, startAngle + TAU);\r\n    for (let i = 0; i < fullCircles; ++i) {\r\n      ctx.fill();\r\n    }\r\n    if (!isNaN(circumference)) {\r\n      endAngle = startAngle + circumference % TAU;\r\n      if (circumference % TAU === 0) {\r\n        endAngle += TAU;\r\n      }\r\n    }\r\n  }\r\n  pathArc(ctx, element, offset, spacing, endAngle);\r\n  ctx.fill();\r\n  return endAngle;\r\n}\r\nfunction drawFullCircleBorders(ctx, element, inner) {\r\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\r\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\r\n  const innerRadius = element.innerRadius + pixelMargin;\r\n  let i;\r\n  if (inner) {\r\n    clipArc(ctx, element, startAngle + TAU);\r\n  }\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\r\n  for (i = 0; i < fullCircles; ++i) {\r\n    ctx.stroke();\r\n  }\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\r\n  for (i = 0; i < fullCircles; ++i) {\r\n    ctx.stroke();\r\n  }\r\n}\r\nfunction drawBorder(ctx, element, offset, spacing, endAngle) {\r\n  const {options} = element;\r\n  const {borderWidth, borderJoinStyle} = options;\r\n  const inner = options.borderAlign === 'inner';\r\n  if (!borderWidth) {\r\n    return;\r\n  }\r\n  if (inner) {\r\n    ctx.lineWidth = borderWidth * 2;\r\n    ctx.lineJoin = borderJoinStyle || 'round';\r\n  } else {\r\n    ctx.lineWidth = borderWidth;\r\n    ctx.lineJoin = borderJoinStyle || 'bevel';\r\n  }\r\n  if (element.fullCircles) {\r\n    drawFullCircleBorders(ctx, element, inner);\r\n  }\r\n  if (inner) {\r\n    clipArc(ctx, element, endAngle);\r\n  }\r\n  pathArc(ctx, element, offset, spacing, endAngle);\r\n  ctx.stroke();\r\n}\r\nclass ArcElement extends Element {\r\n  constructor(cfg) {\r\n    super();\r\n    this.options = undefined;\r\n    this.circumference = undefined;\r\n    this.startAngle = undefined;\r\n    this.endAngle = undefined;\r\n    this.innerRadius = undefined;\r\n    this.outerRadius = undefined;\r\n    this.pixelMargin = 0;\r\n    this.fullCircles = 0;\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n  inRange(chartX, chartY, useFinalPosition) {\r\n    const point = this.getProps(['x', 'y'], useFinalPosition);\r\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\r\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\r\n      'startAngle',\r\n      'endAngle',\r\n      'innerRadius',\r\n      'outerRadius',\r\n      'circumference'\r\n    ], useFinalPosition);\r\n    const rAdjust = this.options.spacing / 2;\r\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\r\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\r\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\r\n    return (betweenAngles && withinRadius);\r\n  }\r\n  getCenterPoint(useFinalPosition) {\r\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\r\n      'x',\r\n      'y',\r\n      'startAngle',\r\n      'endAngle',\r\n      'innerRadius',\r\n      'outerRadius',\r\n      'circumference',\r\n    ], useFinalPosition);\r\n    const {offset, spacing} = this.options;\r\n    const halfAngle = (startAngle + endAngle) / 2;\r\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\r\n    return {\r\n      x: x + Math.cos(halfAngle) * halfRadius,\r\n      y: y + Math.sin(halfAngle) * halfRadius\r\n    };\r\n  }\r\n  tooltipPosition(useFinalPosition) {\r\n    return this.getCenterPoint(useFinalPosition);\r\n  }\r\n  draw(ctx) {\r\n    const {options, circumference} = this;\r\n    const offset = (options.offset || 0) / 2;\r\n    const spacing = (options.spacing || 0) / 2;\r\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\r\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\r\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\r\n      return;\r\n    }\r\n    ctx.save();\r\n    let radiusOffset = 0;\r\n    if (offset) {\r\n      radiusOffset = offset / 2;\r\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\r\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\r\n      if (this.circumference >= PI) {\r\n        radiusOffset = offset;\r\n      }\r\n    }\r\n    ctx.fillStyle = options.backgroundColor;\r\n    ctx.strokeStyle = options.borderColor;\r\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing);\r\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle);\r\n    ctx.restore();\r\n  }\r\n}\r\nArcElement.id = 'arc';\r\nArcElement.defaults = {\r\n  borderAlign: 'center',\r\n  borderColor: '#fff',\r\n  borderJoinStyle: undefined,\r\n  borderRadius: 0,\r\n  borderWidth: 2,\r\n  offset: 0,\r\n  spacing: 0,\r\n  angle: undefined,\r\n};\r\nArcElement.defaultRoutes = {\r\n  backgroundColor: 'backgroundColor'\r\n};\r\n\r\nfunction setStyle(ctx, options, style = options) {\r\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\r\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\r\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\r\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\r\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\r\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\r\n}\r\nfunction lineTo(ctx, previous, target) {\r\n  ctx.lineTo(target.x, target.y);\r\n}\r\nfunction getLineMethod(options) {\r\n  if (options.stepped) {\r\n    return _steppedLineTo;\r\n  }\r\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n    return _bezierCurveTo;\r\n  }\r\n  return lineTo;\r\n}\r\nfunction pathVars(points, segment, params = {}) {\r\n  const count = points.length;\r\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\r\n  const {start: segmentStart, end: segmentEnd} = segment;\r\n  const start = Math.max(paramsStart, segmentStart);\r\n  const end = Math.min(paramsEnd, segmentEnd);\r\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\r\n  return {\r\n    count,\r\n    start,\r\n    loop: segment.loop,\r\n    ilen: end < start && !outside ? count + end - start : end - start\r\n  };\r\n}\r\nfunction pathSegment(ctx, line, segment, params) {\r\n  const {points, options} = line;\r\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\r\n  const lineMethod = getLineMethod(options);\r\n  let {move = true, reverse} = params || {};\r\n  let i, point, prev;\r\n  for (i = 0; i <= ilen; ++i) {\r\n    point = points[(start + (reverse ? ilen - i : i)) % count];\r\n    if (point.skip) {\r\n      continue;\r\n    } else if (move) {\r\n      ctx.moveTo(point.x, point.y);\r\n      move = false;\r\n    } else {\r\n      lineMethod(ctx, prev, point, reverse, options.stepped);\r\n    }\r\n    prev = point;\r\n  }\r\n  if (loop) {\r\n    point = points[(start + (reverse ? ilen : 0)) % count];\r\n    lineMethod(ctx, prev, point, reverse, options.stepped);\r\n  }\r\n  return !!loop;\r\n}\r\nfunction fastPathSegment(ctx, line, segment, params) {\r\n  const points = line.points;\r\n  const {count, start, ilen} = pathVars(points, segment, params);\r\n  const {move = true, reverse} = params || {};\r\n  let avgX = 0;\r\n  let countX = 0;\r\n  let i, point, prevX, minY, maxY, lastY;\r\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\r\n  const drawX = () => {\r\n    if (minY !== maxY) {\r\n      ctx.lineTo(avgX, maxY);\r\n      ctx.lineTo(avgX, minY);\r\n      ctx.lineTo(avgX, lastY);\r\n    }\r\n  };\r\n  if (move) {\r\n    point = points[pointIndex(0)];\r\n    ctx.moveTo(point.x, point.y);\r\n  }\r\n  for (i = 0; i <= ilen; ++i) {\r\n    point = points[pointIndex(i)];\r\n    if (point.skip) {\r\n      continue;\r\n    }\r\n    const x = point.x;\r\n    const y = point.y;\r\n    const truncX = x | 0;\r\n    if (truncX === prevX) {\r\n      if (y < minY) {\r\n        minY = y;\r\n      } else if (y > maxY) {\r\n        maxY = y;\r\n      }\r\n      avgX = (countX * avgX + x) / ++countX;\r\n    } else {\r\n      drawX();\r\n      ctx.lineTo(x, y);\r\n      prevX = truncX;\r\n      countX = 0;\r\n      minY = maxY = y;\r\n    }\r\n    lastY = y;\r\n  }\r\n  drawX();\r\n}\r\nfunction _getSegmentMethod(line) {\r\n  const opts = line.options;\r\n  const borderDash = opts.borderDash && opts.borderDash.length;\r\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\r\n  return useFastPath ? fastPathSegment : pathSegment;\r\n}\r\nfunction _getInterpolationMethod(options) {\r\n  if (options.stepped) {\r\n    return _steppedInterpolation;\r\n  }\r\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\r\n    return _bezierInterpolation;\r\n  }\r\n  return _pointInLine;\r\n}\r\nfunction strokePathWithCache(ctx, line, start, count) {\r\n  let path = line._path;\r\n  if (!path) {\r\n    path = line._path = new Path2D();\r\n    if (line.path(path, start, count)) {\r\n      path.closePath();\r\n    }\r\n  }\r\n  setStyle(ctx, line.options);\r\n  ctx.stroke(path);\r\n}\r\nfunction strokePathDirect(ctx, line, start, count) {\r\n  const {segments, options} = line;\r\n  const segmentMethod = _getSegmentMethod(line);\r\n  for (const segment of segments) {\r\n    setStyle(ctx, options, segment.style);\r\n    ctx.beginPath();\r\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\r\n      ctx.closePath();\r\n    }\r\n    ctx.stroke();\r\n  }\r\n}\r\nconst usePath2D = typeof Path2D === 'function';\r\nfunction draw(ctx, line, start, count) {\r\n  if (usePath2D && !line.options.segment) {\r\n    strokePathWithCache(ctx, line, start, count);\r\n  } else {\r\n    strokePathDirect(ctx, line, start, count);\r\n  }\r\n}\r\nclass LineElement extends Element {\r\n  constructor(cfg) {\r\n    super();\r\n    this.animated = true;\r\n    this.options = undefined;\r\n    this._chart = undefined;\r\n    this._loop = undefined;\r\n    this._fullLoop = undefined;\r\n    this._path = undefined;\r\n    this._points = undefined;\r\n    this._segments = undefined;\r\n    this._decimated = false;\r\n    this._pointsUpdated = false;\r\n    this._datasetIndex = undefined;\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n  updateControlPoints(chartArea, indexAxis) {\r\n    const options = this.options;\r\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\r\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\r\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\r\n      this._pointsUpdated = true;\r\n    }\r\n  }\r\n  set points(points) {\r\n    this._points = points;\r\n    delete this._segments;\r\n    delete this._path;\r\n    this._pointsUpdated = false;\r\n  }\r\n  get points() {\r\n    return this._points;\r\n  }\r\n  get segments() {\r\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\r\n  }\r\n  first() {\r\n    const segments = this.segments;\r\n    const points = this.points;\r\n    return segments.length && points[segments[0].start];\r\n  }\r\n  last() {\r\n    const segments = this.segments;\r\n    const points = this.points;\r\n    const count = segments.length;\r\n    return count && points[segments[count - 1].end];\r\n  }\r\n  interpolate(point, property) {\r\n    const options = this.options;\r\n    const value = point[property];\r\n    const points = this.points;\r\n    const segments = _boundSegments(this, {property, start: value, end: value});\r\n    if (!segments.length) {\r\n      return;\r\n    }\r\n    const result = [];\r\n    const _interpolate = _getInterpolationMethod(options);\r\n    let i, ilen;\r\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\r\n      const {start, end} = segments[i];\r\n      const p1 = points[start];\r\n      const p2 = points[end];\r\n      if (p1 === p2) {\r\n        result.push(p1);\r\n        continue;\r\n      }\r\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\r\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\r\n      interpolated[property] = point[property];\r\n      result.push(interpolated);\r\n    }\r\n    return result.length === 1 ? result[0] : result;\r\n  }\r\n  pathSegment(ctx, segment, params) {\r\n    const segmentMethod = _getSegmentMethod(this);\r\n    return segmentMethod(ctx, this, segment, params);\r\n  }\r\n  path(ctx, start, count) {\r\n    const segments = this.segments;\r\n    const segmentMethod = _getSegmentMethod(this);\r\n    let loop = this._loop;\r\n    start = start || 0;\r\n    count = count || (this.points.length - start);\r\n    for (const segment of segments) {\r\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\r\n    }\r\n    return !!loop;\r\n  }\r\n  draw(ctx, chartArea, start, count) {\r\n    const options = this.options || {};\r\n    const points = this.points || [];\r\n    if (points.length && options.borderWidth) {\r\n      ctx.save();\r\n      draw(ctx, this, start, count);\r\n      ctx.restore();\r\n    }\r\n    if (this.animated) {\r\n      this._pointsUpdated = false;\r\n      this._path = undefined;\r\n    }\r\n  }\r\n}\r\nLineElement.id = 'line';\r\nLineElement.defaults = {\r\n  borderCapStyle: 'butt',\r\n  borderDash: [],\r\n  borderDashOffset: 0,\r\n  borderJoinStyle: 'miter',\r\n  borderWidth: 3,\r\n  capBezierPoints: true,\r\n  cubicInterpolationMode: 'default',\r\n  fill: false,\r\n  spanGaps: false,\r\n  stepped: false,\r\n  tension: 0,\r\n};\r\nLineElement.defaultRoutes = {\r\n  backgroundColor: 'backgroundColor',\r\n  borderColor: 'borderColor'\r\n};\r\nLineElement.descriptors = {\r\n  _scriptable: true,\r\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\r\n};\r\n\r\nfunction inRange$1(el, pos, axis, useFinalPosition) {\r\n  const options = el.options;\r\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\r\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\r\n}\r\nclass PointElement extends Element {\r\n  constructor(cfg) {\r\n    super();\r\n    this.options = undefined;\r\n    this.parsed = undefined;\r\n    this.skip = undefined;\r\n    this.stop = undefined;\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n  inRange(mouseX, mouseY, useFinalPosition) {\r\n    const options = this.options;\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\r\n  }\r\n  inXRange(mouseX, useFinalPosition) {\r\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\r\n  }\r\n  inYRange(mouseY, useFinalPosition) {\r\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\r\n  }\r\n  getCenterPoint(useFinalPosition) {\r\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\r\n    return {x, y};\r\n  }\r\n  size(options) {\r\n    options = options || this.options || {};\r\n    let radius = options.radius || 0;\r\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\r\n    const borderWidth = radius && options.borderWidth || 0;\r\n    return (radius + borderWidth) * 2;\r\n  }\r\n  draw(ctx, area) {\r\n    const options = this.options;\r\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\r\n      return;\r\n    }\r\n    ctx.strokeStyle = options.borderColor;\r\n    ctx.lineWidth = options.borderWidth;\r\n    ctx.fillStyle = options.backgroundColor;\r\n    drawPoint(ctx, options, this.x, this.y);\r\n  }\r\n  getRange() {\r\n    const options = this.options || {};\r\n    return options.radius + options.hitRadius;\r\n  }\r\n}\r\nPointElement.id = 'point';\r\nPointElement.defaults = {\r\n  borderWidth: 1,\r\n  hitRadius: 1,\r\n  hoverBorderWidth: 1,\r\n  hoverRadius: 4,\r\n  pointStyle: 'circle',\r\n  radius: 3,\r\n  rotation: 0\r\n};\r\nPointElement.defaultRoutes = {\r\n  backgroundColor: 'backgroundColor',\r\n  borderColor: 'borderColor'\r\n};\r\n\r\nfunction getBarBounds(bar, useFinalPosition) {\r\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\r\n  let left, right, top, bottom, half;\r\n  if (bar.horizontal) {\r\n    half = height / 2;\r\n    left = Math.min(x, base);\r\n    right = Math.max(x, base);\r\n    top = y - half;\r\n    bottom = y + half;\r\n  } else {\r\n    half = width / 2;\r\n    left = x - half;\r\n    right = x + half;\r\n    top = Math.min(y, base);\r\n    bottom = Math.max(y, base);\r\n  }\r\n  return {left, top, right, bottom};\r\n}\r\nfunction skipOrLimit(skip, value, min, max) {\r\n  return skip ? 0 : _limitValue(value, min, max);\r\n}\r\nfunction parseBorderWidth(bar, maxW, maxH) {\r\n  const value = bar.options.borderWidth;\r\n  const skip = bar.borderSkipped;\r\n  const o = toTRBL(value);\r\n  return {\r\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\r\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\r\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\r\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\r\n  };\r\n}\r\nfunction parseBorderRadius(bar, maxW, maxH) {\r\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\r\n  const value = bar.options.borderRadius;\r\n  const o = toTRBLCorners(value);\r\n  const maxR = Math.min(maxW, maxH);\r\n  const skip = bar.borderSkipped;\r\n  const enableBorder = enableBorderRadius || isObject(value);\r\n  return {\r\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\r\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\r\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\r\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\r\n  };\r\n}\r\nfunction boundingRects(bar) {\r\n  const bounds = getBarBounds(bar);\r\n  const width = bounds.right - bounds.left;\r\n  const height = bounds.bottom - bounds.top;\r\n  const border = parseBorderWidth(bar, width / 2, height / 2);\r\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\r\n  return {\r\n    outer: {\r\n      x: bounds.left,\r\n      y: bounds.top,\r\n      w: width,\r\n      h: height,\r\n      radius\r\n    },\r\n    inner: {\r\n      x: bounds.left + border.l,\r\n      y: bounds.top + border.t,\r\n      w: width - border.l - border.r,\r\n      h: height - border.t - border.b,\r\n      radius: {\r\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\r\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\r\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\r\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\r\n      }\r\n    }\r\n  };\r\n}\r\nfunction inRange(bar, x, y, useFinalPosition) {\r\n  const skipX = x === null;\r\n  const skipY = y === null;\r\n  const skipBoth = skipX && skipY;\r\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\r\n  return bounds\r\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\r\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\r\n}\r\nfunction hasRadius(radius) {\r\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\r\n}\r\nfunction addNormalRectPath(ctx, rect) {\r\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\r\n}\r\nfunction inflateRect(rect, amount, refRect = {}) {\r\n  const x = rect.x !== refRect.x ? -amount : 0;\r\n  const y = rect.y !== refRect.y ? -amount : 0;\r\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\r\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\r\n  return {\r\n    x: rect.x + x,\r\n    y: rect.y + y,\r\n    w: rect.w + w,\r\n    h: rect.h + h,\r\n    radius: rect.radius\r\n  };\r\n}\r\nclass BarElement extends Element {\r\n  constructor(cfg) {\r\n    super();\r\n    this.options = undefined;\r\n    this.horizontal = undefined;\r\n    this.base = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this.inflateAmount = undefined;\r\n    if (cfg) {\r\n      Object.assign(this, cfg);\r\n    }\r\n  }\r\n  draw(ctx) {\r\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\r\n    const {inner, outer} = boundingRects(this);\r\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\r\n    ctx.save();\r\n    if (outer.w !== inner.w || outer.h !== inner.h) {\r\n      ctx.beginPath();\r\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\r\n      ctx.clip();\r\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\r\n      ctx.fillStyle = borderColor;\r\n      ctx.fill('evenodd');\r\n    }\r\n    ctx.beginPath();\r\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\r\n    ctx.fillStyle = backgroundColor;\r\n    ctx.fill();\r\n    ctx.restore();\r\n  }\r\n  inRange(mouseX, mouseY, useFinalPosition) {\r\n    return inRange(this, mouseX, mouseY, useFinalPosition);\r\n  }\r\n  inXRange(mouseX, useFinalPosition) {\r\n    return inRange(this, mouseX, null, useFinalPosition);\r\n  }\r\n  inYRange(mouseY, useFinalPosition) {\r\n    return inRange(this, null, mouseY, useFinalPosition);\r\n  }\r\n  getCenterPoint(useFinalPosition) {\r\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\r\n    return {\r\n      x: horizontal ? (x + base) / 2 : x,\r\n      y: horizontal ? y : (y + base) / 2\r\n    };\r\n  }\r\n  getRange(axis) {\r\n    return axis === 'x' ? this.width / 2 : this.height / 2;\r\n  }\r\n}\r\nBarElement.id = 'bar';\r\nBarElement.defaults = {\r\n  borderSkipped: 'start',\r\n  borderWidth: 0,\r\n  borderRadius: 0,\r\n  inflateAmount: 'auto',\r\n  pointStyle: undefined\r\n};\r\nBarElement.defaultRoutes = {\r\n  backgroundColor: 'backgroundColor',\r\n  borderColor: 'borderColor'\r\n};\r\n\r\nvar elements = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nArcElement: ArcElement,\r\nLineElement: LineElement,\r\nPointElement: PointElement,\r\nBarElement: BarElement\r\n});\r\n\r\nfunction lttbDecimation(data, start, count, availableWidth, options) {\r\n  const samples = options.samples || availableWidth;\r\n  if (samples >= count) {\r\n    return data.slice(start, start + count);\r\n  }\r\n  const decimated = [];\r\n  const bucketWidth = (count - 2) / (samples - 2);\r\n  let sampledIndex = 0;\r\n  const endIndex = start + count - 1;\r\n  let a = start;\r\n  let i, maxAreaPoint, maxArea, area, nextA;\r\n  decimated[sampledIndex++] = data[a];\r\n  for (i = 0; i < samples - 2; i++) {\r\n    let avgX = 0;\r\n    let avgY = 0;\r\n    let j;\r\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\r\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\r\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\r\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\r\n      avgX += data[j].x;\r\n      avgY += data[j].y;\r\n    }\r\n    avgX /= avgRangeLength;\r\n    avgY /= avgRangeLength;\r\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\r\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\r\n    const {x: pointAx, y: pointAy} = data[a];\r\n    maxArea = area = -1;\r\n    for (j = rangeOffs; j < rangeTo; j++) {\r\n      area = 0.5 * Math.abs(\r\n        (pointAx - avgX) * (data[j].y - pointAy) -\r\n        (pointAx - data[j].x) * (avgY - pointAy)\r\n      );\r\n      if (area > maxArea) {\r\n        maxArea = area;\r\n        maxAreaPoint = data[j];\r\n        nextA = j;\r\n      }\r\n    }\r\n    decimated[sampledIndex++] = maxAreaPoint;\r\n    a = nextA;\r\n  }\r\n  decimated[sampledIndex++] = data[endIndex];\r\n  return decimated;\r\n}\r\nfunction minMaxDecimation(data, start, count, availableWidth) {\r\n  let avgX = 0;\r\n  let countX = 0;\r\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\r\n  const decimated = [];\r\n  const endIndex = start + count - 1;\r\n  const xMin = data[start].x;\r\n  const xMax = data[endIndex].x;\r\n  const dx = xMax - xMin;\r\n  for (i = start; i < start + count; ++i) {\r\n    point = data[i];\r\n    x = (point.x - xMin) / dx * availableWidth;\r\n    y = point.y;\r\n    const truncX = x | 0;\r\n    if (truncX === prevX) {\r\n      if (y < minY) {\r\n        minY = y;\r\n        minIndex = i;\r\n      } else if (y > maxY) {\r\n        maxY = y;\r\n        maxIndex = i;\r\n      }\r\n      avgX = (countX * avgX + point.x) / ++countX;\r\n    } else {\r\n      const lastIndex = i - 1;\r\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\r\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\r\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\r\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\r\n          decimated.push({\r\n            ...data[intermediateIndex1],\r\n            x: avgX,\r\n          });\r\n        }\r\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\r\n          decimated.push({\r\n            ...data[intermediateIndex2],\r\n            x: avgX\r\n          });\r\n        }\r\n      }\r\n      if (i > 0 && lastIndex !== startIndex) {\r\n        decimated.push(data[lastIndex]);\r\n      }\r\n      decimated.push(point);\r\n      prevX = truncX;\r\n      countX = 0;\r\n      minY = maxY = y;\r\n      minIndex = maxIndex = startIndex = i;\r\n    }\r\n  }\r\n  return decimated;\r\n}\r\nfunction cleanDecimatedDataset(dataset) {\r\n  if (dataset._decimated) {\r\n    const data = dataset._data;\r\n    delete dataset._decimated;\r\n    delete dataset._data;\r\n    Object.defineProperty(dataset, 'data', {value: data});\r\n  }\r\n}\r\nfunction cleanDecimatedData(chart) {\r\n  chart.data.datasets.forEach((dataset) => {\r\n    cleanDecimatedDataset(dataset);\r\n  });\r\n}\r\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\r\n  const pointCount = points.length;\r\n  let start = 0;\r\n  let count;\r\n  const {iScale} = meta;\r\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\r\n  if (minDefined) {\r\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\r\n  }\r\n  if (maxDefined) {\r\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\r\n  } else {\r\n    count = pointCount - start;\r\n  }\r\n  return {start, count};\r\n}\r\nvar plugin_decimation = {\r\n  id: 'decimation',\r\n  defaults: {\r\n    algorithm: 'min-max',\r\n    enabled: false,\r\n  },\r\n  beforeElementsUpdate: (chart, args, options) => {\r\n    if (!options.enabled) {\r\n      cleanDecimatedData(chart);\r\n      return;\r\n    }\r\n    const availableWidth = chart.width;\r\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\r\n      const {_data, indexAxis} = dataset;\r\n      const meta = chart.getDatasetMeta(datasetIndex);\r\n      const data = _data || dataset.data;\r\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\r\n        return;\r\n      }\r\n      if (!meta.controller.supportsDecimation) {\r\n        return;\r\n      }\r\n      const xAxis = chart.scales[meta.xAxisID];\r\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\r\n        return;\r\n      }\r\n      if (chart.options.parsing) {\r\n        return;\r\n      }\r\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\r\n      const threshold = options.threshold || 4 * availableWidth;\r\n      if (count <= threshold) {\r\n        cleanDecimatedDataset(dataset);\r\n        return;\r\n      }\r\n      if (isNullOrUndef(_data)) {\r\n        dataset._data = data;\r\n        delete dataset.data;\r\n        Object.defineProperty(dataset, 'data', {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: function() {\r\n            return this._decimated;\r\n          },\r\n          set: function(d) {\r\n            this._data = d;\r\n          }\r\n        });\r\n      }\r\n      let decimated;\r\n      switch (options.algorithm) {\r\n      case 'lttb':\r\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\r\n        break;\r\n      case 'min-max':\r\n        decimated = minMaxDecimation(data, start, count, availableWidth);\r\n        break;\r\n      default:\r\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\r\n      }\r\n      dataset._decimated = decimated;\r\n    });\r\n  },\r\n  destroy(chart) {\r\n    cleanDecimatedData(chart);\r\n  }\r\n};\r\n\r\nfunction _segments(line, target, property) {\r\n  const segments = line.segments;\r\n  const points = line.points;\r\n  const tpoints = target.points;\r\n  const parts = [];\r\n  for (const segment of segments) {\r\n    let {start, end} = segment;\r\n    end = _findSegmentEnd(start, end, points);\r\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\r\n    if (!target.segments) {\r\n      parts.push({\r\n        source: segment,\r\n        target: bounds,\r\n        start: points[start],\r\n        end: points[end]\r\n      });\r\n      continue;\r\n    }\r\n    const targetSegments = _boundSegments(target, bounds);\r\n    for (const tgt of targetSegments) {\r\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\r\n      const fillSources = _boundSegment(segment, points, subBounds);\r\n      for (const fillSource of fillSources) {\r\n        parts.push({\r\n          source: fillSource,\r\n          target: tgt,\r\n          start: {\r\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\r\n          },\r\n          end: {\r\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return parts;\r\n}\r\nfunction _getBounds(property, first, last, loop) {\r\n  if (loop) {\r\n    return;\r\n  }\r\n  let start = first[property];\r\n  let end = last[property];\r\n  if (property === 'angle') {\r\n    start = _normalizeAngle(start);\r\n    end = _normalizeAngle(end);\r\n  }\r\n  return {property, start, end};\r\n}\r\nfunction _pointsFromSegments(boundary, line) {\r\n  const {x = null, y = null} = boundary || {};\r\n  const linePoints = line.points;\r\n  const points = [];\r\n  line.segments.forEach(({start, end}) => {\r\n    end = _findSegmentEnd(start, end, linePoints);\r\n    const first = linePoints[start];\r\n    const last = linePoints[end];\r\n    if (y !== null) {\r\n      points.push({x: first.x, y});\r\n      points.push({x: last.x, y});\r\n    } else if (x !== null) {\r\n      points.push({x, y: first.y});\r\n      points.push({x, y: last.y});\r\n    }\r\n  });\r\n  return points;\r\n}\r\nfunction _findSegmentEnd(start, end, points) {\r\n  for (;end > start; end--) {\r\n    const point = points[end];\r\n    if (!isNaN(point.x) && !isNaN(point.y)) {\r\n      break;\r\n    }\r\n  }\r\n  return end;\r\n}\r\nfunction _getEdge(a, b, prop, fn) {\r\n  if (a && b) {\r\n    return fn(a[prop], b[prop]);\r\n  }\r\n  return a ? a[prop] : b ? b[prop] : 0;\r\n}\r\n\r\nfunction _createBoundaryLine(boundary, line) {\r\n  let points = [];\r\n  let _loop = false;\r\n  if (isArray(boundary)) {\r\n    _loop = true;\r\n    points = boundary;\r\n  } else {\r\n    points = _pointsFromSegments(boundary, line);\r\n  }\r\n  return points.length ? new LineElement({\r\n    points,\r\n    options: {tension: 0},\r\n    _loop,\r\n    _fullLoop: _loop\r\n  }) : null;\r\n}\r\n\r\nfunction _resolveTarget(sources, index, propagate) {\r\n  const source = sources[index];\r\n  let fill = source.fill;\r\n  const visited = [index];\r\n  let target;\r\n  if (!propagate) {\r\n    return fill;\r\n  }\r\n  while (fill !== false && visited.indexOf(fill) === -1) {\r\n    if (!isNumberFinite(fill)) {\r\n      return fill;\r\n    }\r\n    target = sources[fill];\r\n    if (!target) {\r\n      return false;\r\n    }\r\n    if (target.visible) {\r\n      return fill;\r\n    }\r\n    visited.push(fill);\r\n    fill = target.fill;\r\n  }\r\n  return false;\r\n}\r\nfunction _decodeFill(line, index, count) {\r\n  const fill = parseFillOption(line);\r\n  if (isObject(fill)) {\r\n    return isNaN(fill.value) ? false : fill;\r\n  }\r\n  let target = parseFloat(fill);\r\n  if (isNumberFinite(target) && Math.floor(target) === target) {\r\n    return decodeTargetIndex(fill[0], index, target, count);\r\n  }\r\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\r\n}\r\nfunction decodeTargetIndex(firstCh, index, target, count) {\r\n  if (firstCh === '-' || firstCh === '+') {\r\n    target = index + target;\r\n  }\r\n  if (target === index || target < 0 || target >= count) {\r\n    return false;\r\n  }\r\n  return target;\r\n}\r\nfunction _getTargetPixel(fill, scale) {\r\n  let pixel = null;\r\n  if (fill === 'start') {\r\n    pixel = scale.bottom;\r\n  } else if (fill === 'end') {\r\n    pixel = scale.top;\r\n  } else if (isObject(fill)) {\r\n    pixel = scale.getPixelForValue(fill.value);\r\n  } else if (scale.getBasePixel) {\r\n    pixel = scale.getBasePixel();\r\n  }\r\n  return pixel;\r\n}\r\nfunction _getTargetValue(fill, scale, startValue) {\r\n  let value;\r\n  if (fill === 'start') {\r\n    value = startValue;\r\n  } else if (fill === 'end') {\r\n    value = scale.options.reverse ? scale.min : scale.max;\r\n  } else if (isObject(fill)) {\r\n    value = fill.value;\r\n  } else {\r\n    value = scale.getBaseValue();\r\n  }\r\n  return value;\r\n}\r\nfunction parseFillOption(line) {\r\n  const options = line.options;\r\n  const fillOption = options.fill;\r\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\r\n  if (fill === undefined) {\r\n    fill = !!options.backgroundColor;\r\n  }\r\n  if (fill === false || fill === null) {\r\n    return false;\r\n  }\r\n  if (fill === true) {\r\n    return 'origin';\r\n  }\r\n  return fill;\r\n}\r\n\r\nfunction _buildStackLine(source) {\r\n  const {scale, index, line} = source;\r\n  const points = [];\r\n  const segments = line.segments;\r\n  const sourcePoints = line.points;\r\n  const linesBelow = getLinesBelow(scale, index);\r\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const segment = segments[i];\r\n    for (let j = segment.start; j <= segment.end; j++) {\r\n      addPointsBelow(points, sourcePoints[j], linesBelow);\r\n    }\r\n  }\r\n  return new LineElement({points, options: {}});\r\n}\r\nfunction getLinesBelow(scale, index) {\r\n  const below = [];\r\n  const metas = scale.getMatchingVisibleMetas('line');\r\n  for (let i = 0; i < metas.length; i++) {\r\n    const meta = metas[i];\r\n    if (meta.index === index) {\r\n      break;\r\n    }\r\n    if (!meta.hidden) {\r\n      below.unshift(meta.dataset);\r\n    }\r\n  }\r\n  return below;\r\n}\r\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\r\n  const postponed = [];\r\n  for (let j = 0; j < linesBelow.length; j++) {\r\n    const line = linesBelow[j];\r\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\r\n    if (!point || (first && last)) {\r\n      continue;\r\n    }\r\n    if (first) {\r\n      postponed.unshift(point);\r\n    } else {\r\n      points.push(point);\r\n      if (!last) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  points.push(...postponed);\r\n}\r\nfunction findPoint(line, sourcePoint, property) {\r\n  const point = line.interpolate(sourcePoint, property);\r\n  if (!point) {\r\n    return {};\r\n  }\r\n  const pointValue = point[property];\r\n  const segments = line.segments;\r\n  const linePoints = line.points;\r\n  let first = false;\r\n  let last = false;\r\n  for (let i = 0; i < segments.length; i++) {\r\n    const segment = segments[i];\r\n    const firstValue = linePoints[segment.start][property];\r\n    const lastValue = linePoints[segment.end][property];\r\n    if (_isBetween(pointValue, firstValue, lastValue)) {\r\n      first = pointValue === firstValue;\r\n      last = pointValue === lastValue;\r\n      break;\r\n    }\r\n  }\r\n  return {first, last, point};\r\n}\r\n\r\nclass simpleArc {\r\n  constructor(opts) {\r\n    this.x = opts.x;\r\n    this.y = opts.y;\r\n    this.radius = opts.radius;\r\n  }\r\n  pathSegment(ctx, bounds, opts) {\r\n    const {x, y, radius} = this;\r\n    bounds = bounds || {start: 0, end: TAU};\r\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\r\n    return !opts.bounds;\r\n  }\r\n  interpolate(point) {\r\n    const {x, y, radius} = this;\r\n    const angle = point.angle;\r\n    return {\r\n      x: x + Math.cos(angle) * radius,\r\n      y: y + Math.sin(angle) * radius,\r\n      angle\r\n    };\r\n  }\r\n}\r\n\r\nfunction _getTarget(source) {\r\n  const {chart, fill, line} = source;\r\n  if (isNumberFinite(fill)) {\r\n    return getLineByIndex(chart, fill);\r\n  }\r\n  if (fill === 'stack') {\r\n    return _buildStackLine(source);\r\n  }\r\n  if (fill === 'shape') {\r\n    return true;\r\n  }\r\n  const boundary = computeBoundary(source);\r\n  if (boundary instanceof simpleArc) {\r\n    return boundary;\r\n  }\r\n  return _createBoundaryLine(boundary, line);\r\n}\r\nfunction getLineByIndex(chart, index) {\r\n  const meta = chart.getDatasetMeta(index);\r\n  const visible = meta && chart.isDatasetVisible(index);\r\n  return visible ? meta.dataset : null;\r\n}\r\nfunction computeBoundary(source) {\r\n  const scale = source.scale || {};\r\n  if (scale.getPointPositionForValue) {\r\n    return computeCircularBoundary(source);\r\n  }\r\n  return computeLinearBoundary(source);\r\n}\r\nfunction computeLinearBoundary(source) {\r\n  const {scale = {}, fill} = source;\r\n  const pixel = _getTargetPixel(fill, scale);\r\n  if (isNumberFinite(pixel)) {\r\n    const horizontal = scale.isHorizontal();\r\n    return {\r\n      x: horizontal ? pixel : null,\r\n      y: horizontal ? null : pixel\r\n    };\r\n  }\r\n  return null;\r\n}\r\nfunction computeCircularBoundary(source) {\r\n  const {scale, fill} = source;\r\n  const options = scale.options;\r\n  const length = scale.getLabels().length;\r\n  const start = options.reverse ? scale.max : scale.min;\r\n  const value = _getTargetValue(fill, scale, start);\r\n  const target = [];\r\n  if (options.grid.circular) {\r\n    const center = scale.getPointPositionForValue(0, start);\r\n    return new simpleArc({\r\n      x: center.x,\r\n      y: center.y,\r\n      radius: scale.getDistanceFromCenterForValue(value)\r\n    });\r\n  }\r\n  for (let i = 0; i < length; ++i) {\r\n    target.push(scale.getPointPositionForValue(i, value));\r\n  }\r\n  return target;\r\n}\r\n\r\nfunction _drawfill(ctx, source, area) {\r\n  const target = _getTarget(source);\r\n  const {line, scale, axis} = source;\r\n  const lineOpts = line.options;\r\n  const fillOption = lineOpts.fill;\r\n  const color = lineOpts.backgroundColor;\r\n  const {above = color, below = color} = fillOption || {};\r\n  if (target && line.points.length) {\r\n    clipArea(ctx, area);\r\n    doFill(ctx, {line, target, above, below, area, scale, axis});\r\n    unclipArea(ctx);\r\n  }\r\n}\r\nfunction doFill(ctx, cfg) {\r\n  const {line, target, above, below, area, scale} = cfg;\r\n  const property = line._loop ? 'angle' : cfg.axis;\r\n  ctx.save();\r\n  if (property === 'x' && below !== above) {\r\n    clipVertical(ctx, target, area.top);\r\n    fill(ctx, {line, target, color: above, scale, property});\r\n    ctx.restore();\r\n    ctx.save();\r\n    clipVertical(ctx, target, area.bottom);\r\n  }\r\n  fill(ctx, {line, target, color: below, scale, property});\r\n  ctx.restore();\r\n}\r\nfunction clipVertical(ctx, target, clipY) {\r\n  const {segments, points} = target;\r\n  let first = true;\r\n  let lineLoop = false;\r\n  ctx.beginPath();\r\n  for (const segment of segments) {\r\n    const {start, end} = segment;\r\n    const firstPoint = points[start];\r\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\r\n    if (first) {\r\n      ctx.moveTo(firstPoint.x, firstPoint.y);\r\n      first = false;\r\n    } else {\r\n      ctx.lineTo(firstPoint.x, clipY);\r\n      ctx.lineTo(firstPoint.x, firstPoint.y);\r\n    }\r\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\r\n    if (lineLoop) {\r\n      ctx.closePath();\r\n    } else {\r\n      ctx.lineTo(lastPoint.x, clipY);\r\n    }\r\n  }\r\n  ctx.lineTo(target.first().x, clipY);\r\n  ctx.closePath();\r\n  ctx.clip();\r\n}\r\nfunction fill(ctx, cfg) {\r\n  const {line, target, property, color, scale} = cfg;\r\n  const segments = _segments(line, target, property);\r\n  for (const {source: src, target: tgt, start, end} of segments) {\r\n    const {style: {backgroundColor = color} = {}} = src;\r\n    const notShape = target !== true;\r\n    ctx.save();\r\n    ctx.fillStyle = backgroundColor;\r\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\r\n    ctx.beginPath();\r\n    const lineLoop = !!line.pathSegment(ctx, src);\r\n    let loop;\r\n    if (notShape) {\r\n      if (lineLoop) {\r\n        ctx.closePath();\r\n      } else {\r\n        interpolatedLineTo(ctx, target, end, property);\r\n      }\r\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\r\n      loop = lineLoop && targetLoop;\r\n      if (!loop) {\r\n        interpolatedLineTo(ctx, target, start, property);\r\n      }\r\n    }\r\n    ctx.closePath();\r\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\r\n    ctx.restore();\r\n  }\r\n}\r\nfunction clipBounds(ctx, scale, bounds) {\r\n  const {top, bottom} = scale.chart.chartArea;\r\n  const {property, start, end} = bounds || {};\r\n  if (property === 'x') {\r\n    ctx.beginPath();\r\n    ctx.rect(start, top, end - start, bottom - top);\r\n    ctx.clip();\r\n  }\r\n}\r\nfunction interpolatedLineTo(ctx, target, point, property) {\r\n  const interpolatedPoint = target.interpolate(point, property);\r\n  if (interpolatedPoint) {\r\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\r\n  }\r\n}\r\n\r\nvar index = {\r\n  id: 'filler',\r\n  afterDatasetsUpdate(chart, _args, options) {\r\n    const count = (chart.data.datasets || []).length;\r\n    const sources = [];\r\n    let meta, i, line, source;\r\n    for (i = 0; i < count; ++i) {\r\n      meta = chart.getDatasetMeta(i);\r\n      line = meta.dataset;\r\n      source = null;\r\n      if (line && line.options && line instanceof LineElement) {\r\n        source = {\r\n          visible: chart.isDatasetVisible(i),\r\n          index: i,\r\n          fill: _decodeFill(line, i, count),\r\n          chart,\r\n          axis: meta.controller.options.indexAxis,\r\n          scale: meta.vScale,\r\n          line,\r\n        };\r\n      }\r\n      meta.$filler = source;\r\n      sources.push(source);\r\n    }\r\n    for (i = 0; i < count; ++i) {\r\n      source = sources[i];\r\n      if (!source || source.fill === false) {\r\n        continue;\r\n      }\r\n      source.fill = _resolveTarget(sources, i, options.propagate);\r\n    }\r\n  },\r\n  beforeDraw(chart, _args, options) {\r\n    const draw = options.drawTime === 'beforeDraw';\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    const area = chart.chartArea;\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      const source = metasets[i].$filler;\r\n      if (!source) {\r\n        continue;\r\n      }\r\n      source.line.updateControlPoints(area, source.axis);\r\n      if (draw) {\r\n        _drawfill(chart.ctx, source, area);\r\n      }\r\n    }\r\n  },\r\n  beforeDatasetsDraw(chart, _args, options) {\r\n    if (options.drawTime !== 'beforeDatasetsDraw') {\r\n      return;\r\n    }\r\n    const metasets = chart.getSortedVisibleDatasetMetas();\r\n    for (let i = metasets.length - 1; i >= 0; --i) {\r\n      const source = metasets[i].$filler;\r\n      if (source) {\r\n        _drawfill(chart.ctx, source, chart.chartArea);\r\n      }\r\n    }\r\n  },\r\n  beforeDatasetDraw(chart, args, options) {\r\n    const source = args.meta.$filler;\r\n    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {\r\n      return;\r\n    }\r\n    _drawfill(chart.ctx, source, chart.chartArea);\r\n  },\r\n  defaults: {\r\n    propagate: true,\r\n    drawTime: 'beforeDatasetDraw'\r\n  }\r\n};\r\n\r\nconst getBoxSize = (labelOpts, fontSize) => {\r\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\r\n  if (labelOpts.usePointStyle) {\r\n    boxHeight = Math.min(boxHeight, fontSize);\r\n    boxWidth = Math.min(boxWidth, fontSize);\r\n  }\r\n  return {\r\n    boxWidth,\r\n    boxHeight,\r\n    itemHeight: Math.max(fontSize, boxHeight)\r\n  };\r\n};\r\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\r\nclass Legend extends Element {\r\n  constructor(config) {\r\n    super();\r\n    this._added = false;\r\n    this.legendHitBoxes = [];\r\n    this._hoveredItem = null;\r\n    this.doughnutMode = false;\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.ctx = config.ctx;\r\n    this.legendItems = undefined;\r\n    this.columnSizes = undefined;\r\n    this.lineWidths = undefined;\r\n    this.maxHeight = undefined;\r\n    this.maxWidth = undefined;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.height = undefined;\r\n    this.width = undefined;\r\n    this._margins = undefined;\r\n    this.position = undefined;\r\n    this.weight = undefined;\r\n    this.fullSize = undefined;\r\n  }\r\n  update(maxWidth, maxHeight, margins) {\r\n    this.maxWidth = maxWidth;\r\n    this.maxHeight = maxHeight;\r\n    this._margins = margins;\r\n    this.setDimensions();\r\n    this.buildLabels();\r\n    this.fit();\r\n  }\r\n  setDimensions() {\r\n    if (this.isHorizontal()) {\r\n      this.width = this.maxWidth;\r\n      this.left = this._margins.left;\r\n      this.right = this.width;\r\n    } else {\r\n      this.height = this.maxHeight;\r\n      this.top = this._margins.top;\r\n      this.bottom = this.height;\r\n    }\r\n  }\r\n  buildLabels() {\r\n    const labelOpts = this.options.labels || {};\r\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\r\n    if (labelOpts.filter) {\r\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\r\n    }\r\n    if (labelOpts.sort) {\r\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\r\n    }\r\n    if (this.options.reverse) {\r\n      legendItems.reverse();\r\n    }\r\n    this.legendItems = legendItems;\r\n  }\r\n  fit() {\r\n    const {options, ctx} = this;\r\n    if (!options.display) {\r\n      this.width = this.height = 0;\r\n      return;\r\n    }\r\n    const labelOpts = options.labels;\r\n    const labelFont = toFont(labelOpts.font);\r\n    const fontSize = labelFont.size;\r\n    const titleHeight = this._computeTitleHeight();\r\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n    let width, height;\r\n    ctx.font = labelFont.string;\r\n    if (this.isHorizontal()) {\r\n      width = this.maxWidth;\r\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n    } else {\r\n      height = this.maxHeight;\r\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\r\n    }\r\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\r\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\r\n  }\r\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\r\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\r\n    const hitboxes = this.legendHitBoxes = [];\r\n    const lineWidths = this.lineWidths = [0];\r\n    const lineHeight = itemHeight + padding;\r\n    let totalHeight = titleHeight;\r\n    ctx.textAlign = 'left';\r\n    ctx.textBaseline = 'middle';\r\n    let row = -1;\r\n    let top = -lineHeight;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\r\n        totalHeight += lineHeight;\r\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\r\n        top += lineHeight;\r\n        row++;\r\n      }\r\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\r\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\r\n    });\r\n    return totalHeight;\r\n  }\r\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\r\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\r\n    const hitboxes = this.legendHitBoxes = [];\r\n    const columnSizes = this.columnSizes = [];\r\n    const heightLimit = maxHeight - titleHeight;\r\n    let totalWidth = padding;\r\n    let currentColWidth = 0;\r\n    let currentColHeight = 0;\r\n    let left = 0;\r\n    let col = 0;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\r\n        totalWidth += currentColWidth + padding;\r\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\r\n        left += currentColWidth + padding;\r\n        col++;\r\n        currentColWidth = currentColHeight = 0;\r\n      }\r\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\r\n      currentColWidth = Math.max(currentColWidth, itemWidth);\r\n      currentColHeight += itemHeight + padding;\r\n    });\r\n    totalWidth += currentColWidth;\r\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\r\n    return totalWidth;\r\n  }\r\n  adjustHitBoxes() {\r\n    if (!this.options.display) {\r\n      return;\r\n    }\r\n    const titleHeight = this._computeTitleHeight();\r\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\r\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\r\n    if (this.isHorizontal()) {\r\n      let row = 0;\r\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n      for (const hitbox of hitboxes) {\r\n        if (row !== hitbox.row) {\r\n          row = hitbox.row;\r\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\r\n        }\r\n        hitbox.top += this.top + titleHeight + padding;\r\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\r\n        left += hitbox.width + padding;\r\n      }\r\n    } else {\r\n      let col = 0;\r\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n      for (const hitbox of hitboxes) {\r\n        if (hitbox.col !== col) {\r\n          col = hitbox.col;\r\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\r\n        }\r\n        hitbox.top = top;\r\n        hitbox.left += this.left + padding;\r\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\r\n        top += hitbox.height + padding;\r\n      }\r\n    }\r\n  }\r\n  isHorizontal() {\r\n    return this.options.position === 'top' || this.options.position === 'bottom';\r\n  }\r\n  draw() {\r\n    if (this.options.display) {\r\n      const ctx = this.ctx;\r\n      clipArea(ctx, this);\r\n      this._draw();\r\n      unclipArea(ctx);\r\n    }\r\n  }\r\n  _draw() {\r\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\r\n    const {align, labels: labelOpts} = opts;\r\n    const defaultColor = defaults.color;\r\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n    const labelFont = toFont(labelOpts.font);\r\n    const {color: fontColor, padding} = labelOpts;\r\n    const fontSize = labelFont.size;\r\n    const halfFontSize = fontSize / 2;\r\n    let cursor;\r\n    this.drawTitle();\r\n    ctx.textAlign = rtlHelper.textAlign('left');\r\n    ctx.textBaseline = 'middle';\r\n    ctx.lineWidth = 0.5;\r\n    ctx.font = labelFont.string;\r\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\r\n    const drawLegendBox = function(x, y, legendItem) {\r\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\r\n        return;\r\n      }\r\n      ctx.save();\r\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\r\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\r\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\r\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\r\n      ctx.lineWidth = lineWidth;\r\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\r\n      if (labelOpts.usePointStyle) {\r\n        const drawOptions = {\r\n          radius: boxWidth * Math.SQRT2 / 2,\r\n          pointStyle: legendItem.pointStyle,\r\n          rotation: legendItem.rotation,\r\n          borderWidth: lineWidth\r\n        };\r\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\r\n        const centerY = y + halfFontSize;\r\n        drawPoint(ctx, drawOptions, centerX, centerY);\r\n      } else {\r\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\r\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\r\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\r\n        ctx.beginPath();\r\n        if (Object.values(borderRadius).some(v => v !== 0)) {\r\n          addRoundedRectPath(ctx, {\r\n            x: xBoxLeft,\r\n            y: yBoxTop,\r\n            w: boxWidth,\r\n            h: boxHeight,\r\n            radius: borderRadius,\r\n          });\r\n        } else {\r\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\r\n        }\r\n        ctx.fill();\r\n        if (lineWidth !== 0) {\r\n          ctx.stroke();\r\n        }\r\n      }\r\n      ctx.restore();\r\n    };\r\n    const fillText = function(x, y, legendItem) {\r\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\r\n        strikethrough: legendItem.hidden,\r\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\r\n      });\r\n    };\r\n    const isHorizontal = this.isHorizontal();\r\n    const titleHeight = this._computeTitleHeight();\r\n    if (isHorizontal) {\r\n      cursor = {\r\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\r\n        y: this.top + padding + titleHeight,\r\n        line: 0\r\n      };\r\n    } else {\r\n      cursor = {\r\n        x: this.left + padding,\r\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\r\n        line: 0\r\n      };\r\n    }\r\n    overrideTextDirection(this.ctx, opts.textDirection);\r\n    const lineHeight = itemHeight + padding;\r\n    this.legendItems.forEach((legendItem, i) => {\r\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\r\n      ctx.fillStyle = legendItem.fontColor || fontColor;\r\n      const textWidth = ctx.measureText(legendItem.text).width;\r\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\r\n      const width = boxWidth + halfFontSize + textWidth;\r\n      let x = cursor.x;\r\n      let y = cursor.y;\r\n      rtlHelper.setWidth(this.width);\r\n      if (isHorizontal) {\r\n        if (i > 0 && x + width + padding > this.right) {\r\n          y = cursor.y += lineHeight;\r\n          cursor.line++;\r\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\r\n        }\r\n      } else if (i > 0 && y + lineHeight > this.bottom) {\r\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\r\n        cursor.line++;\r\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\r\n      }\r\n      const realX = rtlHelper.x(x);\r\n      drawLegendBox(realX, y, legendItem);\r\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\r\n      fillText(rtlHelper.x(x), y, legendItem);\r\n      if (isHorizontal) {\r\n        cursor.x += width + padding;\r\n      } else {\r\n        cursor.y += lineHeight;\r\n      }\r\n    });\r\n    restoreTextDirection(this.ctx, opts.textDirection);\r\n  }\r\n  drawTitle() {\r\n    const opts = this.options;\r\n    const titleOpts = opts.title;\r\n    const titleFont = toFont(titleOpts.font);\r\n    const titlePadding = toPadding(titleOpts.padding);\r\n    if (!titleOpts.display) {\r\n      return;\r\n    }\r\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\r\n    const ctx = this.ctx;\r\n    const position = titleOpts.position;\r\n    const halfFontSize = titleFont.size / 2;\r\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\r\n    let y;\r\n    let left = this.left;\r\n    let maxWidth = this.width;\r\n    if (this.isHorizontal()) {\r\n      maxWidth = Math.max(...this.lineWidths);\r\n      y = this.top + topPaddingPlusHalfFontSize;\r\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\r\n    } else {\r\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\r\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\r\n    }\r\n    const x = _alignStartEnd(position, left, left + maxWidth);\r\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\r\n    ctx.textBaseline = 'middle';\r\n    ctx.strokeStyle = titleOpts.color;\r\n    ctx.fillStyle = titleOpts.color;\r\n    ctx.font = titleFont.string;\r\n    renderText(ctx, titleOpts.text, x, y, titleFont);\r\n  }\r\n  _computeTitleHeight() {\r\n    const titleOpts = this.options.title;\r\n    const titleFont = toFont(titleOpts.font);\r\n    const titlePadding = toPadding(titleOpts.padding);\r\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\r\n  }\r\n  _getLegendItemAt(x, y) {\r\n    let i, hitBox, lh;\r\n    if (_isBetween(x, this.left, this.right)\r\n      && _isBetween(y, this.top, this.bottom)) {\r\n      lh = this.legendHitBoxes;\r\n      for (i = 0; i < lh.length; ++i) {\r\n        hitBox = lh[i];\r\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\r\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\r\n          return this.legendItems[i];\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  handleEvent(e) {\r\n    const opts = this.options;\r\n    if (!isListened(e.type, opts)) {\r\n      return;\r\n    }\r\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\r\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\r\n      const previous = this._hoveredItem;\r\n      const sameItem = itemsEqual(previous, hoveredItem);\r\n      if (previous && !sameItem) {\r\n        callback(opts.onLeave, [e, previous, this], this);\r\n      }\r\n      this._hoveredItem = hoveredItem;\r\n      if (hoveredItem && !sameItem) {\r\n        callback(opts.onHover, [e, hoveredItem, this], this);\r\n      }\r\n    } else if (hoveredItem) {\r\n      callback(opts.onClick, [e, hoveredItem, this], this);\r\n    }\r\n  }\r\n}\r\nfunction isListened(type, opts) {\r\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\r\n    return true;\r\n  }\r\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nvar plugin_legend = {\r\n  id: 'legend',\r\n  _element: Legend,\r\n  start(chart, _args, options) {\r\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\r\n    layouts.configure(chart, legend, options);\r\n    layouts.addBox(chart, legend);\r\n  },\r\n  stop(chart) {\r\n    layouts.removeBox(chart, chart.legend);\r\n    delete chart.legend;\r\n  },\r\n  beforeUpdate(chart, _args, options) {\r\n    const legend = chart.legend;\r\n    layouts.configure(chart, legend, options);\r\n    legend.options = options;\r\n  },\r\n  afterUpdate(chart) {\r\n    const legend = chart.legend;\r\n    legend.buildLabels();\r\n    legend.adjustHitBoxes();\r\n  },\r\n  afterEvent(chart, args) {\r\n    if (!args.replay) {\r\n      chart.legend.handleEvent(args.event);\r\n    }\r\n  },\r\n  defaults: {\r\n    display: true,\r\n    position: 'top',\r\n    align: 'center',\r\n    fullSize: true,\r\n    reverse: false,\r\n    weight: 1000,\r\n    onClick(e, legendItem, legend) {\r\n      const index = legendItem.datasetIndex;\r\n      const ci = legend.chart;\r\n      if (ci.isDatasetVisible(index)) {\r\n        ci.hide(index);\r\n        legendItem.hidden = true;\r\n      } else {\r\n        ci.show(index);\r\n        legendItem.hidden = false;\r\n      }\r\n    },\r\n    onHover: null,\r\n    onLeave: null,\r\n    labels: {\r\n      color: (ctx) => ctx.chart.options.color,\r\n      boxWidth: 40,\r\n      padding: 10,\r\n      generateLabels(chart) {\r\n        const datasets = chart.data.datasets;\r\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\r\n        return chart._getSortedDatasetMetas().map((meta) => {\r\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\r\n          const borderWidth = toPadding(style.borderWidth);\r\n          return {\r\n            text: datasets[meta.index].label,\r\n            fillStyle: style.backgroundColor,\r\n            fontColor: color,\r\n            hidden: !meta.visible,\r\n            lineCap: style.borderCapStyle,\r\n            lineDash: style.borderDash,\r\n            lineDashOffset: style.borderDashOffset,\r\n            lineJoin: style.borderJoinStyle,\r\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\r\n            strokeStyle: style.borderColor,\r\n            pointStyle: pointStyle || style.pointStyle,\r\n            rotation: style.rotation,\r\n            textAlign: textAlign || style.textAlign,\r\n            borderRadius: 0,\r\n            datasetIndex: meta.index\r\n          };\r\n        }, this);\r\n      }\r\n    },\r\n    title: {\r\n      color: (ctx) => ctx.chart.options.color,\r\n      display: false,\r\n      position: 'center',\r\n      text: '',\r\n    }\r\n  },\r\n  descriptors: {\r\n    _scriptable: (name) => !name.startsWith('on'),\r\n    labels: {\r\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\r\n    }\r\n  },\r\n};\r\n\r\nclass Title extends Element {\r\n  constructor(config) {\r\n    super();\r\n    this.chart = config.chart;\r\n    this.options = config.options;\r\n    this.ctx = config.ctx;\r\n    this._padding = undefined;\r\n    this.top = undefined;\r\n    this.bottom = undefined;\r\n    this.left = undefined;\r\n    this.right = undefined;\r\n    this.width = undefined;\r\n    this.height = undefined;\r\n    this.position = undefined;\r\n    this.weight = undefined;\r\n    this.fullSize = undefined;\r\n  }\r\n  update(maxWidth, maxHeight) {\r\n    const opts = this.options;\r\n    this.left = 0;\r\n    this.top = 0;\r\n    if (!opts.display) {\r\n      this.width = this.height = this.right = this.bottom = 0;\r\n      return;\r\n    }\r\n    this.width = this.right = maxWidth;\r\n    this.height = this.bottom = maxHeight;\r\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\r\n    this._padding = toPadding(opts.padding);\r\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\r\n    if (this.isHorizontal()) {\r\n      this.height = textSize;\r\n    } else {\r\n      this.width = textSize;\r\n    }\r\n  }\r\n  isHorizontal() {\r\n    const pos = this.options.position;\r\n    return pos === 'top' || pos === 'bottom';\r\n  }\r\n  _drawArgs(offset) {\r\n    const {top, left, bottom, right, options} = this;\r\n    const align = options.align;\r\n    let rotation = 0;\r\n    let maxWidth, titleX, titleY;\r\n    if (this.isHorizontal()) {\r\n      titleX = _alignStartEnd(align, left, right);\r\n      titleY = top + offset;\r\n      maxWidth = right - left;\r\n    } else {\r\n      if (options.position === 'left') {\r\n        titleX = left + offset;\r\n        titleY = _alignStartEnd(align, bottom, top);\r\n        rotation = PI * -0.5;\r\n      } else {\r\n        titleX = right - offset;\r\n        titleY = _alignStartEnd(align, top, bottom);\r\n        rotation = PI * 0.5;\r\n      }\r\n      maxWidth = bottom - top;\r\n    }\r\n    return {titleX, titleY, maxWidth, rotation};\r\n  }\r\n  draw() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    if (!opts.display) {\r\n      return;\r\n    }\r\n    const fontOpts = toFont(opts.font);\r\n    const lineHeight = fontOpts.lineHeight;\r\n    const offset = lineHeight / 2 + this._padding.top;\r\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\r\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\r\n      color: opts.color,\r\n      maxWidth,\r\n      rotation,\r\n      textAlign: _toLeftRightCenter(opts.align),\r\n      textBaseline: 'middle',\r\n      translation: [titleX, titleY],\r\n    });\r\n  }\r\n}\r\nfunction createTitle(chart, titleOpts) {\r\n  const title = new Title({\r\n    ctx: chart.ctx,\r\n    options: titleOpts,\r\n    chart\r\n  });\r\n  layouts.configure(chart, title, titleOpts);\r\n  layouts.addBox(chart, title);\r\n  chart.titleBlock = title;\r\n}\r\nvar plugin_title = {\r\n  id: 'title',\r\n  _element: Title,\r\n  start(chart, _args, options) {\r\n    createTitle(chart, options);\r\n  },\r\n  stop(chart) {\r\n    const titleBlock = chart.titleBlock;\r\n    layouts.removeBox(chart, titleBlock);\r\n    delete chart.titleBlock;\r\n  },\r\n  beforeUpdate(chart, _args, options) {\r\n    const title = chart.titleBlock;\r\n    layouts.configure(chart, title, options);\r\n    title.options = options;\r\n  },\r\n  defaults: {\r\n    align: 'center',\r\n    display: false,\r\n    font: {\r\n      weight: 'bold',\r\n    },\r\n    fullSize: true,\r\n    padding: 10,\r\n    position: 'top',\r\n    text: '',\r\n    weight: 2000\r\n  },\r\n  defaultRoutes: {\r\n    color: 'color'\r\n  },\r\n  descriptors: {\r\n    _scriptable: true,\r\n    _indexable: false,\r\n  },\r\n};\r\n\r\nconst map = new WeakMap();\r\nvar plugin_subtitle = {\r\n  id: 'subtitle',\r\n  start(chart, _args, options) {\r\n    const title = new Title({\r\n      ctx: chart.ctx,\r\n      options,\r\n      chart\r\n    });\r\n    layouts.configure(chart, title, options);\r\n    layouts.addBox(chart, title);\r\n    map.set(chart, title);\r\n  },\r\n  stop(chart) {\r\n    layouts.removeBox(chart, map.get(chart));\r\n    map.delete(chart);\r\n  },\r\n  beforeUpdate(chart, _args, options) {\r\n    const title = map.get(chart);\r\n    layouts.configure(chart, title, options);\r\n    title.options = options;\r\n  },\r\n  defaults: {\r\n    align: 'center',\r\n    display: false,\r\n    font: {\r\n      weight: 'normal',\r\n    },\r\n    fullSize: true,\r\n    padding: 0,\r\n    position: 'top',\r\n    text: '',\r\n    weight: 1500\r\n  },\r\n  defaultRoutes: {\r\n    color: 'color'\r\n  },\r\n  descriptors: {\r\n    _scriptable: true,\r\n    _indexable: false,\r\n  },\r\n};\r\n\r\nconst positioners = {\r\n  average(items) {\r\n    if (!items.length) {\r\n      return false;\r\n    }\r\n    let i, len;\r\n    let x = 0;\r\n    let y = 0;\r\n    let count = 0;\r\n    for (i = 0, len = items.length; i < len; ++i) {\r\n      const el = items[i].element;\r\n      if (el && el.hasValue()) {\r\n        const pos = el.tooltipPosition();\r\n        x += pos.x;\r\n        y += pos.y;\r\n        ++count;\r\n      }\r\n    }\r\n    return {\r\n      x: x / count,\r\n      y: y / count\r\n    };\r\n  },\r\n  nearest(items, eventPosition) {\r\n    if (!items.length) {\r\n      return false;\r\n    }\r\n    let x = eventPosition.x;\r\n    let y = eventPosition.y;\r\n    let minDistance = Number.POSITIVE_INFINITY;\r\n    let i, len, nearestElement;\r\n    for (i = 0, len = items.length; i < len; ++i) {\r\n      const el = items[i].element;\r\n      if (el && el.hasValue()) {\r\n        const center = el.getCenterPoint();\r\n        const d = distanceBetweenPoints(eventPosition, center);\r\n        if (d < minDistance) {\r\n          minDistance = d;\r\n          nearestElement = el;\r\n        }\r\n      }\r\n    }\r\n    if (nearestElement) {\r\n      const tp = nearestElement.tooltipPosition();\r\n      x = tp.x;\r\n      y = tp.y;\r\n    }\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n};\r\nfunction pushOrConcat(base, toPush) {\r\n  if (toPush) {\r\n    if (isArray(toPush)) {\r\n      Array.prototype.push.apply(base, toPush);\r\n    } else {\r\n      base.push(toPush);\r\n    }\r\n  }\r\n  return base;\r\n}\r\nfunction splitNewlines(str) {\r\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\r\n    return str.split('\\n');\r\n  }\r\n  return str;\r\n}\r\nfunction createTooltipItem(chart, item) {\r\n  const {element, datasetIndex, index} = item;\r\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\r\n  const {label, value} = controller.getLabelAndValue(index);\r\n  return {\r\n    chart,\r\n    label,\r\n    parsed: controller.getParsed(index),\r\n    raw: chart.data.datasets[datasetIndex].data[index],\r\n    formattedValue: value,\r\n    dataset: controller.getDataset(),\r\n    dataIndex: index,\r\n    datasetIndex,\r\n    element\r\n  };\r\n}\r\nfunction getTooltipSize(tooltip, options) {\r\n  const ctx = tooltip.chart.ctx;\r\n  const {body, footer, title} = tooltip;\r\n  const {boxWidth, boxHeight} = options;\r\n  const bodyFont = toFont(options.bodyFont);\r\n  const titleFont = toFont(options.titleFont);\r\n  const footerFont = toFont(options.footerFont);\r\n  const titleLineCount = title.length;\r\n  const footerLineCount = footer.length;\r\n  const bodyLineItemCount = body.length;\r\n  const padding = toPadding(options.padding);\r\n  let height = padding.height;\r\n  let width = 0;\r\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\r\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\r\n  if (titleLineCount) {\r\n    height += titleLineCount * titleFont.lineHeight\r\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\r\n\t\t\t+ options.titleMarginBottom;\r\n  }\r\n  if (combinedBodyLength) {\r\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\r\n    height += bodyLineItemCount * bodyLineHeight\r\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\r\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\r\n  }\r\n  if (footerLineCount) {\r\n    height += options.footerMarginTop\r\n\t\t\t+ footerLineCount * footerFont.lineHeight\r\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\r\n  }\r\n  let widthPadding = 0;\r\n  const maxLineWidth = function(line) {\r\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n  };\r\n  ctx.save();\r\n  ctx.font = titleFont.string;\r\n  each(tooltip.title, maxLineWidth);\r\n  ctx.font = bodyFont.string;\r\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\r\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\r\n  each(body, (bodyItem) => {\r\n    each(bodyItem.before, maxLineWidth);\r\n    each(bodyItem.lines, maxLineWidth);\r\n    each(bodyItem.after, maxLineWidth);\r\n  });\r\n  widthPadding = 0;\r\n  ctx.font = footerFont.string;\r\n  each(tooltip.footer, maxLineWidth);\r\n  ctx.restore();\r\n  width += padding.width;\r\n  return {width, height};\r\n}\r\nfunction determineYAlign(chart, size) {\r\n  const {y, height} = size;\r\n  if (y < height / 2) {\r\n    return 'top';\r\n  } else if (y > (chart.height - height / 2)) {\r\n    return 'bottom';\r\n  }\r\n  return 'center';\r\n}\r\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\r\n  const {x, width} = size;\r\n  const caret = options.caretSize + options.caretPadding;\r\n  if (xAlign === 'left' && x + width + caret > chart.width) {\r\n    return true;\r\n  }\r\n  if (xAlign === 'right' && x - width - caret < 0) {\r\n    return true;\r\n  }\r\n}\r\nfunction determineXAlign(chart, options, size, yAlign) {\r\n  const {x, width} = size;\r\n  const {width: chartWidth, chartArea: {left, right}} = chart;\r\n  let xAlign = 'center';\r\n  if (yAlign === 'center') {\r\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\r\n  } else if (x <= width / 2) {\r\n    xAlign = 'left';\r\n  } else if (x >= chartWidth - width / 2) {\r\n    xAlign = 'right';\r\n  }\r\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\r\n    xAlign = 'center';\r\n  }\r\n  return xAlign;\r\n}\r\nfunction determineAlignment(chart, options, size) {\r\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\r\n  return {\r\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\r\n    yAlign\r\n  };\r\n}\r\nfunction alignX(size, xAlign) {\r\n  let {x, width} = size;\r\n  if (xAlign === 'right') {\r\n    x -= width;\r\n  } else if (xAlign === 'center') {\r\n    x -= (width / 2);\r\n  }\r\n  return x;\r\n}\r\nfunction alignY(size, yAlign, paddingAndSize) {\r\n  let {y, height} = size;\r\n  if (yAlign === 'top') {\r\n    y += paddingAndSize;\r\n  } else if (yAlign === 'bottom') {\r\n    y -= height + paddingAndSize;\r\n  } else {\r\n    y -= (height / 2);\r\n  }\r\n  return y;\r\n}\r\nfunction getBackgroundPoint(options, size, alignment, chart) {\r\n  const {caretSize, caretPadding, cornerRadius} = options;\r\n  const {xAlign, yAlign} = alignment;\r\n  const paddingAndSize = caretSize + caretPadding;\r\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\r\n  let x = alignX(size, xAlign);\r\n  const y = alignY(size, yAlign, paddingAndSize);\r\n  if (yAlign === 'center') {\r\n    if (xAlign === 'left') {\r\n      x += paddingAndSize;\r\n    } else if (xAlign === 'right') {\r\n      x -= paddingAndSize;\r\n    }\r\n  } else if (xAlign === 'left') {\r\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\r\n  } else if (xAlign === 'right') {\r\n    x += Math.max(topRight, bottomRight) + caretSize;\r\n  }\r\n  return {\r\n    x: _limitValue(x, 0, chart.width - size.width),\r\n    y: _limitValue(y, 0, chart.height - size.height)\r\n  };\r\n}\r\nfunction getAlignedX(tooltip, align, options) {\r\n  const padding = toPadding(options.padding);\r\n  return align === 'center'\r\n    ? tooltip.x + tooltip.width / 2\r\n    : align === 'right'\r\n      ? tooltip.x + tooltip.width - padding.right\r\n      : tooltip.x + padding.left;\r\n}\r\nfunction getBeforeAfterBodyLines(callback) {\r\n  return pushOrConcat([], splitNewlines(callback));\r\n}\r\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\r\n  return createContext(parent, {\r\n    tooltip,\r\n    tooltipItems,\r\n    type: 'tooltip'\r\n  });\r\n}\r\nfunction overrideCallbacks(callbacks, context) {\r\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\r\n  return override ? callbacks.override(override) : callbacks;\r\n}\r\nclass Tooltip extends Element {\r\n  constructor(config) {\r\n    super();\r\n    this.opacity = 0;\r\n    this._active = [];\r\n    this._eventPosition = undefined;\r\n    this._size = undefined;\r\n    this._cachedAnimations = undefined;\r\n    this._tooltipItems = [];\r\n    this.$animations = undefined;\r\n    this.$context = undefined;\r\n    this.chart = config.chart || config._chart;\r\n    this._chart = this.chart;\r\n    this.options = config.options;\r\n    this.dataPoints = undefined;\r\n    this.title = undefined;\r\n    this.beforeBody = undefined;\r\n    this.body = undefined;\r\n    this.afterBody = undefined;\r\n    this.footer = undefined;\r\n    this.xAlign = undefined;\r\n    this.yAlign = undefined;\r\n    this.x = undefined;\r\n    this.y = undefined;\r\n    this.height = undefined;\r\n    this.width = undefined;\r\n    this.caretX = undefined;\r\n    this.caretY = undefined;\r\n    this.labelColors = undefined;\r\n    this.labelPointStyles = undefined;\r\n    this.labelTextColors = undefined;\r\n  }\r\n  initialize(options) {\r\n    this.options = options;\r\n    this._cachedAnimations = undefined;\r\n    this.$context = undefined;\r\n  }\r\n  _resolveAnimations() {\r\n    const cached = this._cachedAnimations;\r\n    if (cached) {\r\n      return cached;\r\n    }\r\n    const chart = this.chart;\r\n    const options = this.options.setContext(this.getContext());\r\n    const opts = options.enabled && chart.options.animation && options.animations;\r\n    const animations = new Animations(this.chart, opts);\r\n    if (opts._cacheable) {\r\n      this._cachedAnimations = Object.freeze(animations);\r\n    }\r\n    return animations;\r\n  }\r\n  getContext() {\r\n    return this.$context ||\r\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\r\n  }\r\n  getTitle(context, options) {\r\n    const {callbacks} = options;\r\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\r\n    const title = callbacks.title.apply(this, [context]);\r\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\r\n    let lines = [];\r\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n    lines = pushOrConcat(lines, splitNewlines(title));\r\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n    return lines;\r\n  }\r\n  getBeforeBody(tooltipItems, options) {\r\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\r\n  }\r\n  getBody(tooltipItems, options) {\r\n    const {callbacks} = options;\r\n    const bodyItems = [];\r\n    each(tooltipItems, (context) => {\r\n      const bodyItem = {\r\n        before: [],\r\n        lines: [],\r\n        after: []\r\n      };\r\n      const scoped = overrideCallbacks(callbacks, context);\r\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\r\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\r\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\r\n      bodyItems.push(bodyItem);\r\n    });\r\n    return bodyItems;\r\n  }\r\n  getAfterBody(tooltipItems, options) {\r\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\r\n  }\r\n  getFooter(tooltipItems, options) {\r\n    const {callbacks} = options;\r\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\r\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\r\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\r\n    let lines = [];\r\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n    lines = pushOrConcat(lines, splitNewlines(footer));\r\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n    return lines;\r\n  }\r\n  _createItems(options) {\r\n    const active = this._active;\r\n    const data = this.chart.data;\r\n    const labelColors = [];\r\n    const labelPointStyles = [];\r\n    const labelTextColors = [];\r\n    let tooltipItems = [];\r\n    let i, len;\r\n    for (i = 0, len = active.length; i < len; ++i) {\r\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\r\n    }\r\n    if (options.filter) {\r\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\r\n    }\r\n    if (options.itemSort) {\r\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\r\n    }\r\n    each(tooltipItems, (context) => {\r\n      const scoped = overrideCallbacks(options.callbacks, context);\r\n      labelColors.push(scoped.labelColor.call(this, context));\r\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\r\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\r\n    });\r\n    this.labelColors = labelColors;\r\n    this.labelPointStyles = labelPointStyles;\r\n    this.labelTextColors = labelTextColors;\r\n    this.dataPoints = tooltipItems;\r\n    return tooltipItems;\r\n  }\r\n  update(changed, replay) {\r\n    const options = this.options.setContext(this.getContext());\r\n    const active = this._active;\r\n    let properties;\r\n    let tooltipItems = [];\r\n    if (!active.length) {\r\n      if (this.opacity !== 0) {\r\n        properties = {\r\n          opacity: 0\r\n        };\r\n      }\r\n    } else {\r\n      const position = positioners[options.position].call(this, active, this._eventPosition);\r\n      tooltipItems = this._createItems(options);\r\n      this.title = this.getTitle(tooltipItems, options);\r\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\r\n      this.body = this.getBody(tooltipItems, options);\r\n      this.afterBody = this.getAfterBody(tooltipItems, options);\r\n      this.footer = this.getFooter(tooltipItems, options);\r\n      const size = this._size = getTooltipSize(this, options);\r\n      const positionAndSize = Object.assign({}, position, size);\r\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\r\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\r\n      this.xAlign = alignment.xAlign;\r\n      this.yAlign = alignment.yAlign;\r\n      properties = {\r\n        opacity: 1,\r\n        x: backgroundPoint.x,\r\n        y: backgroundPoint.y,\r\n        width: size.width,\r\n        height: size.height,\r\n        caretX: position.x,\r\n        caretY: position.y\r\n      };\r\n    }\r\n    this._tooltipItems = tooltipItems;\r\n    this.$context = undefined;\r\n    if (properties) {\r\n      this._resolveAnimations().update(this, properties);\r\n    }\r\n    if (changed && options.external) {\r\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\r\n    }\r\n  }\r\n  drawCaret(tooltipPoint, ctx, size, options) {\r\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\r\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\r\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\r\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\r\n  }\r\n  getCaretPosition(tooltipPoint, size, options) {\r\n    const {xAlign, yAlign} = this;\r\n    const {caretSize, cornerRadius} = options;\r\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\r\n    const {x: ptX, y: ptY} = tooltipPoint;\r\n    const {width, height} = size;\r\n    let x1, x2, x3, y1, y2, y3;\r\n    if (yAlign === 'center') {\r\n      y2 = ptY + (height / 2);\r\n      if (xAlign === 'left') {\r\n        x1 = ptX;\r\n        x2 = x1 - caretSize;\r\n        y1 = y2 + caretSize;\r\n        y3 = y2 - caretSize;\r\n      } else {\r\n        x1 = ptX + width;\r\n        x2 = x1 + caretSize;\r\n        y1 = y2 - caretSize;\r\n        y3 = y2 + caretSize;\r\n      }\r\n      x3 = x1;\r\n    } else {\r\n      if (xAlign === 'left') {\r\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\r\n      } else if (xAlign === 'right') {\r\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\r\n      } else {\r\n        x2 = this.caretX;\r\n      }\r\n      if (yAlign === 'top') {\r\n        y1 = ptY;\r\n        y2 = y1 - caretSize;\r\n        x1 = x2 - caretSize;\r\n        x3 = x2 + caretSize;\r\n      } else {\r\n        y1 = ptY + height;\r\n        y2 = y1 + caretSize;\r\n        x1 = x2 + caretSize;\r\n        x3 = x2 - caretSize;\r\n      }\r\n      y3 = y1;\r\n    }\r\n    return {x1, x2, x3, y1, y2, y3};\r\n  }\r\n  drawTitle(pt, ctx, options) {\r\n    const title = this.title;\r\n    const length = title.length;\r\n    let titleFont, titleSpacing, i;\r\n    if (length) {\r\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n      pt.x = getAlignedX(this, options.titleAlign, options);\r\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\r\n      ctx.textBaseline = 'middle';\r\n      titleFont = toFont(options.titleFont);\r\n      titleSpacing = options.titleSpacing;\r\n      ctx.fillStyle = options.titleColor;\r\n      ctx.font = titleFont.string;\r\n      for (i = 0; i < length; ++i) {\r\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\r\n        pt.y += titleFont.lineHeight + titleSpacing;\r\n        if (i + 1 === length) {\r\n          pt.y += options.titleMarginBottom - titleSpacing;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\r\n    const labelColors = this.labelColors[i];\r\n    const labelPointStyle = this.labelPointStyles[i];\r\n    const {boxHeight, boxWidth, boxPadding} = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    const colorX = getAlignedX(this, 'left', options);\r\n    const rtlColorX = rtlHelper.x(colorX);\r\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\r\n    const colorY = pt.y + yOffSet;\r\n    if (options.usePointStyle) {\r\n      const drawOptions = {\r\n        radius: Math.min(boxWidth, boxHeight) / 2,\r\n        pointStyle: labelPointStyle.pointStyle,\r\n        rotation: labelPointStyle.rotation,\r\n        borderWidth: 1\r\n      };\r\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\r\n      const centerY = colorY + boxHeight / 2;\r\n      ctx.strokeStyle = options.multiKeyBackground;\r\n      ctx.fillStyle = options.multiKeyBackground;\r\n      drawPoint(ctx, drawOptions, centerX, centerY);\r\n      ctx.strokeStyle = labelColors.borderColor;\r\n      ctx.fillStyle = labelColors.backgroundColor;\r\n      drawPoint(ctx, drawOptions, centerX, centerY);\r\n    } else {\r\n      ctx.lineWidth = labelColors.borderWidth || 1;\r\n      ctx.strokeStyle = labelColors.borderColor;\r\n      ctx.setLineDash(labelColors.borderDash || []);\r\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\r\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\r\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\r\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\r\n      if (Object.values(borderRadius).some(v => v !== 0)) {\r\n        ctx.beginPath();\r\n        ctx.fillStyle = options.multiKeyBackground;\r\n        addRoundedRectPath(ctx, {\r\n          x: outerX,\r\n          y: colorY,\r\n          w: boxWidth,\r\n          h: boxHeight,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.fillStyle = labelColors.backgroundColor;\r\n        ctx.beginPath();\r\n        addRoundedRectPath(ctx, {\r\n          x: innerX,\r\n          y: colorY + 1,\r\n          w: boxWidth - 2,\r\n          h: boxHeight - 2,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n      } else {\r\n        ctx.fillStyle = options.multiKeyBackground;\r\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\r\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\r\n        ctx.fillStyle = labelColors.backgroundColor;\r\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\r\n      }\r\n    }\r\n    ctx.fillStyle = this.labelTextColors[i];\r\n  }\r\n  drawBody(pt, ctx, options) {\r\n    const {body} = this;\r\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\r\n    const bodyFont = toFont(options.bodyFont);\r\n    let bodyLineHeight = bodyFont.lineHeight;\r\n    let xLinePadding = 0;\r\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n    const fillLineOfText = function(line) {\r\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\r\n      pt.y += bodyLineHeight + bodySpacing;\r\n    };\r\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\r\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\r\n    ctx.textAlign = bodyAlign;\r\n    ctx.textBaseline = 'middle';\r\n    ctx.font = bodyFont.string;\r\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\r\n    ctx.fillStyle = options.bodyColor;\r\n    each(this.beforeBody, fillLineOfText);\r\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\r\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\r\n      : 0;\r\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\r\n      bodyItem = body[i];\r\n      textColor = this.labelTextColors[i];\r\n      ctx.fillStyle = textColor;\r\n      each(bodyItem.before, fillLineOfText);\r\n      lines = bodyItem.lines;\r\n      if (displayColors && lines.length) {\r\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\r\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\r\n      }\r\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\r\n        fillLineOfText(lines[j]);\r\n        bodyLineHeight = bodyFont.lineHeight;\r\n      }\r\n      each(bodyItem.after, fillLineOfText);\r\n    }\r\n    xLinePadding = 0;\r\n    bodyLineHeight = bodyFont.lineHeight;\r\n    each(this.afterBody, fillLineOfText);\r\n    pt.y -= bodySpacing;\r\n  }\r\n  drawFooter(pt, ctx, options) {\r\n    const footer = this.footer;\r\n    const length = footer.length;\r\n    let footerFont, i;\r\n    if (length) {\r\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\r\n      pt.x = getAlignedX(this, options.footerAlign, options);\r\n      pt.y += options.footerMarginTop;\r\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\r\n      ctx.textBaseline = 'middle';\r\n      footerFont = toFont(options.footerFont);\r\n      ctx.fillStyle = options.footerColor;\r\n      ctx.font = footerFont.string;\r\n      for (i = 0; i < length; ++i) {\r\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\r\n        pt.y += footerFont.lineHeight + options.footerSpacing;\r\n      }\r\n    }\r\n  }\r\n  drawBackground(pt, ctx, tooltipSize, options) {\r\n    const {xAlign, yAlign} = this;\r\n    const {x, y} = pt;\r\n    const {width, height} = tooltipSize;\r\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\r\n    ctx.fillStyle = options.backgroundColor;\r\n    ctx.strokeStyle = options.borderColor;\r\n    ctx.lineWidth = options.borderWidth;\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + topLeft, y);\r\n    if (yAlign === 'top') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + width - topRight, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\r\n    if (yAlign === 'center' && xAlign === 'right') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + width, y + height - bottomRight);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\r\n    if (yAlign === 'bottom') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x + bottomLeft, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\r\n    if (yAlign === 'center' && xAlign === 'left') {\r\n      this.drawCaret(pt, ctx, tooltipSize, options);\r\n    }\r\n    ctx.lineTo(x, y + topLeft);\r\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    if (options.borderWidth > 0) {\r\n      ctx.stroke();\r\n    }\r\n  }\r\n  _updateAnimationTarget(options) {\r\n    const chart = this.chart;\r\n    const anims = this.$animations;\r\n    const animX = anims && anims.x;\r\n    const animY = anims && anims.y;\r\n    if (animX || animY) {\r\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\r\n      if (!position) {\r\n        return;\r\n      }\r\n      const size = this._size = getTooltipSize(this, options);\r\n      const positionAndSize = Object.assign({}, position, this._size);\r\n      const alignment = determineAlignment(chart, options, positionAndSize);\r\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\r\n      if (animX._to !== point.x || animY._to !== point.y) {\r\n        this.xAlign = alignment.xAlign;\r\n        this.yAlign = alignment.yAlign;\r\n        this.width = size.width;\r\n        this.height = size.height;\r\n        this.caretX = position.x;\r\n        this.caretY = position.y;\r\n        this._resolveAnimations().update(this, point);\r\n      }\r\n    }\r\n  }\r\n  _willRender() {\r\n    return !!this.opacity;\r\n  }\r\n  draw(ctx) {\r\n    const options = this.options.setContext(this.getContext());\r\n    let opacity = this.opacity;\r\n    if (!opacity) {\r\n      return;\r\n    }\r\n    this._updateAnimationTarget(options);\r\n    const tooltipSize = {\r\n      width: this.width,\r\n      height: this.height\r\n    };\r\n    const pt = {\r\n      x: this.x,\r\n      y: this.y\r\n    };\r\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\r\n    const padding = toPadding(options.padding);\r\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\r\n    if (options.enabled && hasTooltipContent) {\r\n      ctx.save();\r\n      ctx.globalAlpha = opacity;\r\n      this.drawBackground(pt, ctx, tooltipSize, options);\r\n      overrideTextDirection(ctx, options.textDirection);\r\n      pt.y += padding.top;\r\n      this.drawTitle(pt, ctx, options);\r\n      this.drawBody(pt, ctx, options);\r\n      this.drawFooter(pt, ctx, options);\r\n      restoreTextDirection(ctx, options.textDirection);\r\n      ctx.restore();\r\n    }\r\n  }\r\n  getActiveElements() {\r\n    return this._active || [];\r\n  }\r\n  setActiveElements(activeElements, eventPosition) {\r\n    const lastActive = this._active;\r\n    const active = activeElements.map(({datasetIndex, index}) => {\r\n      const meta = this.chart.getDatasetMeta(datasetIndex);\r\n      if (!meta) {\r\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\r\n      }\r\n      return {\r\n        datasetIndex,\r\n        element: meta.data[index],\r\n        index,\r\n      };\r\n    });\r\n    const changed = !_elementsEqual(lastActive, active);\r\n    const positionChanged = this._positionChanged(active, eventPosition);\r\n    if (changed || positionChanged) {\r\n      this._active = active;\r\n      this._eventPosition = eventPosition;\r\n      this._ignoreReplayEvents = true;\r\n      this.update(true);\r\n    }\r\n  }\r\n  handleEvent(e, replay, inChartArea = true) {\r\n    if (replay && this._ignoreReplayEvents) {\r\n      return false;\r\n    }\r\n    this._ignoreReplayEvents = false;\r\n    const options = this.options;\r\n    const lastActive = this._active || [];\r\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\r\n    const positionChanged = this._positionChanged(active, e);\r\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\r\n    if (changed) {\r\n      this._active = active;\r\n      if (options.enabled || options.external) {\r\n        this._eventPosition = {\r\n          x: e.x,\r\n          y: e.y\r\n        };\r\n        this.update(true, replay);\r\n      }\r\n    }\r\n    return changed;\r\n  }\r\n  _getActiveElements(e, lastActive, replay, inChartArea) {\r\n    const options = this.options;\r\n    if (e.type === 'mouseout') {\r\n      return [];\r\n    }\r\n    if (!inChartArea) {\r\n      return lastActive;\r\n    }\r\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\r\n    if (options.reverse) {\r\n      active.reverse();\r\n    }\r\n    return active;\r\n  }\r\n  _positionChanged(active, e) {\r\n    const {caretX, caretY, options} = this;\r\n    const position = positioners[options.position].call(this, active, e);\r\n    return position !== false && (caretX !== position.x || caretY !== position.y);\r\n  }\r\n}\r\nTooltip.positioners = positioners;\r\nvar plugin_tooltip = {\r\n  id: 'tooltip',\r\n  _element: Tooltip,\r\n  positioners,\r\n  afterInit(chart, _args, options) {\r\n    if (options) {\r\n      chart.tooltip = new Tooltip({chart, options});\r\n    }\r\n  },\r\n  beforeUpdate(chart, _args, options) {\r\n    if (chart.tooltip) {\r\n      chart.tooltip.initialize(options);\r\n    }\r\n  },\r\n  reset(chart, _args, options) {\r\n    if (chart.tooltip) {\r\n      chart.tooltip.initialize(options);\r\n    }\r\n  },\r\n  afterDraw(chart) {\r\n    const tooltip = chart.tooltip;\r\n    if (tooltip && tooltip._willRender()) {\r\n      const args = {\r\n        tooltip\r\n      };\r\n      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\r\n        return;\r\n      }\r\n      tooltip.draw(chart.ctx);\r\n      chart.notifyPlugins('afterTooltipDraw', args);\r\n    }\r\n  },\r\n  afterEvent(chart, args) {\r\n    if (chart.tooltip) {\r\n      const useFinalPosition = args.replay;\r\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\r\n        args.changed = true;\r\n      }\r\n    }\r\n  },\r\n  defaults: {\r\n    enabled: true,\r\n    external: null,\r\n    position: 'average',\r\n    backgroundColor: 'rgba(0,0,0,0.8)',\r\n    titleColor: '#fff',\r\n    titleFont: {\r\n      weight: 'bold',\r\n    },\r\n    titleSpacing: 2,\r\n    titleMarginBottom: 6,\r\n    titleAlign: 'left',\r\n    bodyColor: '#fff',\r\n    bodySpacing: 2,\r\n    bodyFont: {\r\n    },\r\n    bodyAlign: 'left',\r\n    footerColor: '#fff',\r\n    footerSpacing: 2,\r\n    footerMarginTop: 6,\r\n    footerFont: {\r\n      weight: 'bold',\r\n    },\r\n    footerAlign: 'left',\r\n    padding: 6,\r\n    caretPadding: 2,\r\n    caretSize: 5,\r\n    cornerRadius: 6,\r\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\r\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\r\n    multiKeyBackground: '#fff',\r\n    displayColors: true,\r\n    boxPadding: 0,\r\n    borderColor: 'rgba(0,0,0,0)',\r\n    borderWidth: 0,\r\n    animation: {\r\n      duration: 400,\r\n      easing: 'easeOutQuart',\r\n    },\r\n    animations: {\r\n      numbers: {\r\n        type: 'number',\r\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\r\n      },\r\n      opacity: {\r\n        easing: 'linear',\r\n        duration: 200\r\n      }\r\n    },\r\n    callbacks: {\r\n      beforeTitle: noop,\r\n      title(tooltipItems) {\r\n        if (tooltipItems.length > 0) {\r\n          const item = tooltipItems[0];\r\n          const labels = item.chart.data.labels;\r\n          const labelCount = labels ? labels.length : 0;\r\n          if (this && this.options && this.options.mode === 'dataset') {\r\n            return item.dataset.label || '';\r\n          } else if (item.label) {\r\n            return item.label;\r\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\r\n            return labels[item.dataIndex];\r\n          }\r\n        }\r\n        return '';\r\n      },\r\n      afterTitle: noop,\r\n      beforeBody: noop,\r\n      beforeLabel: noop,\r\n      label(tooltipItem) {\r\n        if (this && this.options && this.options.mode === 'dataset') {\r\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\r\n        }\r\n        let label = tooltipItem.dataset.label || '';\r\n        if (label) {\r\n          label += ': ';\r\n        }\r\n        const value = tooltipItem.formattedValue;\r\n        if (!isNullOrUndef(value)) {\r\n          label += value;\r\n        }\r\n        return label;\r\n      },\r\n      labelColor(tooltipItem) {\r\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n        return {\r\n          borderColor: options.borderColor,\r\n          backgroundColor: options.backgroundColor,\r\n          borderWidth: options.borderWidth,\r\n          borderDash: options.borderDash,\r\n          borderDashOffset: options.borderDashOffset,\r\n          borderRadius: 0,\r\n        };\r\n      },\r\n      labelTextColor() {\r\n        return this.options.bodyColor;\r\n      },\r\n      labelPointStyle(tooltipItem) {\r\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\r\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\r\n        return {\r\n          pointStyle: options.pointStyle,\r\n          rotation: options.rotation,\r\n        };\r\n      },\r\n      afterLabel: noop,\r\n      afterBody: noop,\r\n      beforeFooter: noop,\r\n      footer: noop,\r\n      afterFooter: noop\r\n    }\r\n  },\r\n  defaultRoutes: {\r\n    bodyFont: 'font',\r\n    footerFont: 'font',\r\n    titleFont: 'font'\r\n  },\r\n  descriptors: {\r\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\r\n    _indexable: false,\r\n    callbacks: {\r\n      _scriptable: false,\r\n      _indexable: false,\r\n    },\r\n    animation: {\r\n      _fallback: false\r\n    },\r\n    animations: {\r\n      _fallback: 'animation'\r\n    }\r\n  },\r\n  additionalOptionScopes: ['interaction']\r\n};\r\n\r\nvar plugins = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nDecimation: plugin_decimation,\r\nFiller: index,\r\nLegend: plugin_legend,\r\nSubTitle: plugin_subtitle,\r\nTitle: plugin_title,\r\nTooltip: plugin_tooltip\r\n});\r\n\r\nconst addIfString = (labels, raw, index, addedLabels) => {\r\n  if (typeof raw === 'string') {\r\n    index = labels.push(raw) - 1;\r\n    addedLabels.unshift({index, label: raw});\r\n  } else if (isNaN(raw)) {\r\n    index = null;\r\n  }\r\n  return index;\r\n};\r\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\r\n  const first = labels.indexOf(raw);\r\n  if (first === -1) {\r\n    return addIfString(labels, raw, index, addedLabels);\r\n  }\r\n  const last = labels.lastIndexOf(raw);\r\n  return first !== last ? index : first;\r\n}\r\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\r\nclass CategoryScale extends Scale {\r\n  constructor(cfg) {\r\n    super(cfg);\r\n    this._startValue = undefined;\r\n    this._valueRange = 0;\r\n    this._addedLabels = [];\r\n  }\r\n  init(scaleOptions) {\r\n    const added = this._addedLabels;\r\n    if (added.length) {\r\n      const labels = this.getLabels();\r\n      for (const {index, label} of added) {\r\n        if (labels[index] === label) {\r\n          labels.splice(index, 1);\r\n        }\r\n      }\r\n      this._addedLabels = [];\r\n    }\r\n    super.init(scaleOptions);\r\n  }\r\n  parse(raw, index) {\r\n    if (isNullOrUndef(raw)) {\r\n      return null;\r\n    }\r\n    const labels = this.getLabels();\r\n    index = isFinite(index) && labels[index] === raw ? index\r\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\r\n    return validIndex(index, labels.length - 1);\r\n  }\r\n  determineDataLimits() {\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let {min, max} = this.getMinMax(true);\r\n    if (this.options.bounds === 'ticks') {\r\n      if (!minDefined) {\r\n        min = 0;\r\n      }\r\n      if (!maxDefined) {\r\n        max = this.getLabels().length - 1;\r\n      }\r\n    }\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n  buildTicks() {\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const offset = this.options.offset;\r\n    const ticks = [];\r\n    let labels = this.getLabels();\r\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\r\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\r\n    this._startValue = this.min - (offset ? 0.5 : 0);\r\n    for (let value = min; value <= max; value++) {\r\n      ticks.push({value});\r\n    }\r\n    return ticks;\r\n  }\r\n  getLabelForValue(value) {\r\n    const labels = this.getLabels();\r\n    if (value >= 0 && value < labels.length) {\r\n      return labels[value];\r\n    }\r\n    return value;\r\n  }\r\n  configure() {\r\n    super.configure();\r\n    if (!this.isHorizontal()) {\r\n      this._reversePixels = !this._reversePixels;\r\n    }\r\n  }\r\n  getPixelForValue(value) {\r\n    if (typeof value !== 'number') {\r\n      value = this.parse(value);\r\n    }\r\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n  }\r\n  getPixelForTick(index) {\r\n    const ticks = this.ticks;\r\n    if (index < 0 || index > ticks.length - 1) {\r\n      return null;\r\n    }\r\n    return this.getPixelForValue(ticks[index].value);\r\n  }\r\n  getValueForPixel(pixel) {\r\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\r\n  }\r\n  getBasePixel() {\r\n    return this.bottom;\r\n  }\r\n}\r\nCategoryScale.id = 'category';\r\nCategoryScale.defaults = {\r\n  ticks: {\r\n    callback: CategoryScale.prototype.getLabelForValue\r\n  }\r\n};\r\n\r\nfunction generateTicks$1(generationOptions, dataRange) {\r\n  const ticks = [];\r\n  const MIN_SPACING = 1e-14;\r\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\r\n  const unit = step || 1;\r\n  const maxSpaces = maxTicks - 1;\r\n  const {min: rmin, max: rmax} = dataRange;\r\n  const minDefined = !isNullOrUndef(min);\r\n  const maxDefined = !isNullOrUndef(max);\r\n  const countDefined = !isNullOrUndef(count);\r\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\r\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\r\n  let factor, niceMin, niceMax, numSpaces;\r\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\r\n    return [{value: rmin}, {value: rmax}];\r\n  }\r\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\r\n  if (numSpaces > maxSpaces) {\r\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\r\n  }\r\n  if (!isNullOrUndef(precision)) {\r\n    factor = Math.pow(10, precision);\r\n    spacing = Math.ceil(spacing * factor) / factor;\r\n  }\r\n  if (bounds === 'ticks') {\r\n    niceMin = Math.floor(rmin / spacing) * spacing;\r\n    niceMax = Math.ceil(rmax / spacing) * spacing;\r\n  } else {\r\n    niceMin = rmin;\r\n    niceMax = rmax;\r\n  }\r\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\r\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\r\n    spacing = (max - min) / numSpaces;\r\n    niceMin = min;\r\n    niceMax = max;\r\n  } else if (countDefined) {\r\n    niceMin = minDefined ? min : niceMin;\r\n    niceMax = maxDefined ? max : niceMax;\r\n    numSpaces = count - 1;\r\n    spacing = (niceMax - niceMin) / numSpaces;\r\n  } else {\r\n    numSpaces = (niceMax - niceMin) / spacing;\r\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n      numSpaces = Math.round(numSpaces);\r\n    } else {\r\n      numSpaces = Math.ceil(numSpaces);\r\n    }\r\n  }\r\n  const decimalPlaces = Math.max(\r\n    _decimalPlaces(spacing),\r\n    _decimalPlaces(niceMin)\r\n  );\r\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\r\n  niceMin = Math.round(niceMin * factor) / factor;\r\n  niceMax = Math.round(niceMax * factor) / factor;\r\n  let j = 0;\r\n  if (minDefined) {\r\n    if (includeBounds && niceMin !== min) {\r\n      ticks.push({value: min});\r\n      if (niceMin < min) {\r\n        j++;\r\n      }\r\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\r\n        j++;\r\n      }\r\n    } else if (niceMin < min) {\r\n      j++;\r\n    }\r\n  }\r\n  for (; j < numSpaces; ++j) {\r\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\r\n  }\r\n  if (maxDefined && includeBounds && niceMax !== max) {\r\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\r\n      ticks[ticks.length - 1].value = max;\r\n    } else {\r\n      ticks.push({value: max});\r\n    }\r\n  } else if (!maxDefined || niceMax === max) {\r\n    ticks.push({value: niceMax});\r\n  }\r\n  return ticks;\r\n}\r\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\r\n  const rad = toRadians(minRotation);\r\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\r\n  const length = 0.75 * minSpacing * ('' + value).length;\r\n  return Math.min(minSpacing / ratio, length);\r\n}\r\nclass LinearScaleBase extends Scale {\r\n  constructor(cfg) {\r\n    super(cfg);\r\n    this.start = undefined;\r\n    this.end = undefined;\r\n    this._startValue = undefined;\r\n    this._endValue = undefined;\r\n    this._valueRange = 0;\r\n  }\r\n  parse(raw, index) {\r\n    if (isNullOrUndef(raw)) {\r\n      return null;\r\n    }\r\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\r\n      return null;\r\n    }\r\n    return +raw;\r\n  }\r\n  handleTickRangeOptions() {\r\n    const {beginAtZero} = this.options;\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let {min, max} = this;\r\n    const setMin = v => (min = minDefined ? min : v);\r\n    const setMax = v => (max = maxDefined ? max : v);\r\n    if (beginAtZero) {\r\n      const minSign = sign(min);\r\n      const maxSign = sign(max);\r\n      if (minSign < 0 && maxSign < 0) {\r\n        setMax(0);\r\n      } else if (minSign > 0 && maxSign > 0) {\r\n        setMin(0);\r\n      }\r\n    }\r\n    if (min === max) {\r\n      let offset = 1;\r\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\r\n        offset = Math.abs(max * 0.05);\r\n      }\r\n      setMax(max + offset);\r\n      if (!beginAtZero) {\r\n        setMin(min - offset);\r\n      }\r\n    }\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n  getTickLimit() {\r\n    const tickOpts = this.options.ticks;\r\n    let {maxTicksLimit, stepSize} = tickOpts;\r\n    let maxTicks;\r\n    if (stepSize) {\r\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\r\n      if (maxTicks > 1000) {\r\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\r\n        maxTicks = 1000;\r\n      }\r\n    } else {\r\n      maxTicks = this.computeTickLimit();\r\n      maxTicksLimit = maxTicksLimit || 11;\r\n    }\r\n    if (maxTicksLimit) {\r\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\r\n    }\r\n    return maxTicks;\r\n  }\r\n  computeTickLimit() {\r\n    return Number.POSITIVE_INFINITY;\r\n  }\r\n  buildTicks() {\r\n    const opts = this.options;\r\n    const tickOpts = opts.ticks;\r\n    let maxTicks = this.getTickLimit();\r\n    maxTicks = Math.max(2, maxTicks);\r\n    const numericGeneratorOptions = {\r\n      maxTicks,\r\n      bounds: opts.bounds,\r\n      min: opts.min,\r\n      max: opts.max,\r\n      precision: tickOpts.precision,\r\n      step: tickOpts.stepSize,\r\n      count: tickOpts.count,\r\n      maxDigits: this._maxDigits(),\r\n      horizontal: this.isHorizontal(),\r\n      minRotation: tickOpts.minRotation || 0,\r\n      includeBounds: tickOpts.includeBounds !== false\r\n    };\r\n    const dataRange = this._range || this;\r\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\r\n    if (opts.bounds === 'ticks') {\r\n      _setMinAndMaxByKey(ticks, this, 'value');\r\n    }\r\n    if (opts.reverse) {\r\n      ticks.reverse();\r\n      this.start = this.max;\r\n      this.end = this.min;\r\n    } else {\r\n      this.start = this.min;\r\n      this.end = this.max;\r\n    }\r\n    return ticks;\r\n  }\r\n  configure() {\r\n    const ticks = this.ticks;\r\n    let start = this.min;\r\n    let end = this.max;\r\n    super.configure();\r\n    if (this.options.offset && ticks.length) {\r\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\r\n      start -= offset;\r\n      end += offset;\r\n    }\r\n    this._startValue = start;\r\n    this._endValue = end;\r\n    this._valueRange = end - start;\r\n  }\r\n  getLabelForValue(value) {\r\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n  }\r\n}\r\n\r\nclass LinearScale extends LinearScaleBase {\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(true);\r\n    this.min = isNumberFinite(min) ? min : 0;\r\n    this.max = isNumberFinite(max) ? max : 1;\r\n    this.handleTickRangeOptions();\r\n  }\r\n  computeTickLimit() {\r\n    const horizontal = this.isHorizontal();\r\n    const length = horizontal ? this.width : this.height;\r\n    const minRotation = toRadians(this.options.ticks.minRotation);\r\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\r\n    const tickFont = this._resolveTickFontOptions(0);\r\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\r\n  }\r\n  getPixelForValue(value) {\r\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\r\n  }\r\n  getValueForPixel(pixel) {\r\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\r\n  }\r\n}\r\nLinearScale.id = 'linear';\r\nLinearScale.defaults = {\r\n  ticks: {\r\n    callback: Ticks.formatters.numeric\r\n  }\r\n};\r\n\r\nfunction isMajor(tickVal) {\r\n  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\r\n  return remain === 1;\r\n}\r\nfunction generateTicks(generationOptions, dataRange) {\r\n  const endExp = Math.floor(log10(dataRange.max));\r\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\r\n  const ticks = [];\r\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\r\n  let exp = Math.floor(log10(tickVal));\r\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\r\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\r\n  do {\r\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\r\n    ++significand;\r\n    if (significand === 10) {\r\n      significand = 1;\r\n      ++exp;\r\n      precision = exp >= 0 ? 1 : precision;\r\n    }\r\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\r\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\r\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\r\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\r\n  return ticks;\r\n}\r\nclass LogarithmicScale extends Scale {\r\n  constructor(cfg) {\r\n    super(cfg);\r\n    this.start = undefined;\r\n    this.end = undefined;\r\n    this._startValue = undefined;\r\n    this._valueRange = 0;\r\n  }\r\n  parse(raw, index) {\r\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\r\n    if (value === 0) {\r\n      this._zero = true;\r\n      return undefined;\r\n    }\r\n    return isNumberFinite(value) && value > 0 ? value : null;\r\n  }\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(true);\r\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\r\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\r\n    if (this.options.beginAtZero) {\r\n      this._zero = true;\r\n    }\r\n    this.handleTickRangeOptions();\r\n  }\r\n  handleTickRangeOptions() {\r\n    const {minDefined, maxDefined} = this.getUserBounds();\r\n    let min = this.min;\r\n    let max = this.max;\r\n    const setMin = v => (min = minDefined ? min : v);\r\n    const setMax = v => (max = maxDefined ? max : v);\r\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\r\n    if (min === max) {\r\n      if (min <= 0) {\r\n        setMin(1);\r\n        setMax(10);\r\n      } else {\r\n        setMin(exp(min, -1));\r\n        setMax(exp(max, +1));\r\n      }\r\n    }\r\n    if (min <= 0) {\r\n      setMin(exp(max, -1));\r\n    }\r\n    if (max <= 0) {\r\n      setMax(exp(min, +1));\r\n    }\r\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\r\n      setMin(exp(min, -1));\r\n    }\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n  buildTicks() {\r\n    const opts = this.options;\r\n    const generationOptions = {\r\n      min: this._userMin,\r\n      max: this._userMax\r\n    };\r\n    const ticks = generateTicks(generationOptions, this);\r\n    if (opts.bounds === 'ticks') {\r\n      _setMinAndMaxByKey(ticks, this, 'value');\r\n    }\r\n    if (opts.reverse) {\r\n      ticks.reverse();\r\n      this.start = this.max;\r\n      this.end = this.min;\r\n    } else {\r\n      this.start = this.min;\r\n      this.end = this.max;\r\n    }\r\n    return ticks;\r\n  }\r\n  getLabelForValue(value) {\r\n    return value === undefined\r\n      ? '0'\r\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\r\n  }\r\n  configure() {\r\n    const start = this.min;\r\n    super.configure();\r\n    this._startValue = log10(start);\r\n    this._valueRange = log10(this.max) - log10(start);\r\n  }\r\n  getPixelForValue(value) {\r\n    if (value === undefined || value === 0) {\r\n      value = this.min;\r\n    }\r\n    if (value === null || isNaN(value)) {\r\n      return NaN;\r\n    }\r\n    return this.getPixelForDecimal(value === this.min\r\n      ? 0\r\n      : (log10(value) - this._startValue) / this._valueRange);\r\n  }\r\n  getValueForPixel(pixel) {\r\n    const decimal = this.getDecimalForPixel(pixel);\r\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\r\n  }\r\n}\r\nLogarithmicScale.id = 'logarithmic';\r\nLogarithmicScale.defaults = {\r\n  ticks: {\r\n    callback: Ticks.formatters.logarithmic,\r\n    major: {\r\n      enabled: true\r\n    }\r\n  }\r\n};\r\n\r\nfunction getTickBackdropHeight(opts) {\r\n  const tickOpts = opts.ticks;\r\n  if (tickOpts.display && opts.display) {\r\n    const padding = toPadding(tickOpts.backdropPadding);\r\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\r\n  }\r\n  return 0;\r\n}\r\nfunction measureLabelSize(ctx, font, label) {\r\n  label = isArray(label) ? label : [label];\r\n  return {\r\n    w: _longestText(ctx, font.string, label),\r\n    h: label.length * font.lineHeight\r\n  };\r\n}\r\nfunction determineLimits(angle, pos, size, min, max) {\r\n  if (angle === min || angle === max) {\r\n    return {\r\n      start: pos - (size / 2),\r\n      end: pos + (size / 2)\r\n    };\r\n  } else if (angle < min || angle > max) {\r\n    return {\r\n      start: pos - size,\r\n      end: pos\r\n    };\r\n  }\r\n  return {\r\n    start: pos,\r\n    end: pos + size\r\n  };\r\n}\r\nfunction fitWithPointLabels(scale) {\r\n  const orig = {\r\n    l: scale.left + scale._padding.left,\r\n    r: scale.right - scale._padding.right,\r\n    t: scale.top + scale._padding.top,\r\n    b: scale.bottom - scale._padding.bottom\r\n  };\r\n  const limits = Object.assign({}, orig);\r\n  const labelSizes = [];\r\n  const padding = [];\r\n  const valueCount = scale._pointLabels.length;\r\n  const pointLabelOpts = scale.options.pointLabels;\r\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\r\n  for (let i = 0; i < valueCount; i++) {\r\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\r\n    padding[i] = opts.padding;\r\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\r\n    const plFont = toFont(opts.font);\r\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\r\n    labelSizes[i] = textSize;\r\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\r\n    const angle = Math.round(toDegrees(angleRadians));\r\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\r\n  }\r\n  scale.setCenterPoint(\r\n    orig.l - limits.l,\r\n    limits.r - orig.r,\r\n    orig.t - limits.t,\r\n    limits.b - orig.b\r\n  );\r\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\r\n}\r\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\r\n  const sin = Math.abs(Math.sin(angle));\r\n  const cos = Math.abs(Math.cos(angle));\r\n  let x = 0;\r\n  let y = 0;\r\n  if (hLimits.start < orig.l) {\r\n    x = (orig.l - hLimits.start) / sin;\r\n    limits.l = Math.min(limits.l, orig.l - x);\r\n  } else if (hLimits.end > orig.r) {\r\n    x = (hLimits.end - orig.r) / sin;\r\n    limits.r = Math.max(limits.r, orig.r + x);\r\n  }\r\n  if (vLimits.start < orig.t) {\r\n    y = (orig.t - vLimits.start) / cos;\r\n    limits.t = Math.min(limits.t, orig.t - y);\r\n  } else if (vLimits.end > orig.b) {\r\n    y = (vLimits.end - orig.b) / cos;\r\n    limits.b = Math.max(limits.b, orig.b + y);\r\n  }\r\n}\r\nfunction buildPointLabelItems(scale, labelSizes, padding) {\r\n  const items = [];\r\n  const valueCount = scale._pointLabels.length;\r\n  const opts = scale.options;\r\n  const extra = getTickBackdropHeight(opts) / 2;\r\n  const outerDistance = scale.drawingArea;\r\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\r\n  for (let i = 0; i < valueCount; i++) {\r\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\r\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\r\n    const size = labelSizes[i];\r\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\r\n    const textAlign = getTextAlignForAngle(angle);\r\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\r\n    items.push({\r\n      x: pointLabelPosition.x,\r\n      y,\r\n      textAlign,\r\n      left,\r\n      top: y,\r\n      right: left + size.w,\r\n      bottom: y + size.h\r\n    });\r\n  }\r\n  return items;\r\n}\r\nfunction getTextAlignForAngle(angle) {\r\n  if (angle === 0 || angle === 180) {\r\n    return 'center';\r\n  } else if (angle < 180) {\r\n    return 'left';\r\n  }\r\n  return 'right';\r\n}\r\nfunction leftForTextAlign(x, w, align) {\r\n  if (align === 'right') {\r\n    x -= w;\r\n  } else if (align === 'center') {\r\n    x -= (w / 2);\r\n  }\r\n  return x;\r\n}\r\nfunction yForAngle(y, h, angle) {\r\n  if (angle === 90 || angle === 270) {\r\n    y -= (h / 2);\r\n  } else if (angle > 270 || angle < 90) {\r\n    y -= h;\r\n  }\r\n  return y;\r\n}\r\nfunction drawPointLabels(scale, labelCount) {\r\n  const {ctx, options: {pointLabels}} = scale;\r\n  for (let i = labelCount - 1; i >= 0; i--) {\r\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\r\n    const plFont = toFont(optsAtIndex.font);\r\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\r\n    const {backdropColor} = optsAtIndex;\r\n    if (!isNullOrUndef(backdropColor)) {\r\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\r\n      const padding = toPadding(optsAtIndex.backdropPadding);\r\n      ctx.fillStyle = backdropColor;\r\n      const backdropLeft = left - padding.left;\r\n      const backdropTop = top - padding.top;\r\n      const backdropWidth = right - left + padding.width;\r\n      const backdropHeight = bottom - top + padding.height;\r\n      if (Object.values(borderRadius).some(v => v !== 0)) {\r\n        ctx.beginPath();\r\n        addRoundedRectPath(ctx, {\r\n          x: backdropLeft,\r\n          y: backdropTop,\r\n          w: backdropWidth,\r\n          h: backdropHeight,\r\n          radius: borderRadius,\r\n        });\r\n        ctx.fill();\r\n      } else {\r\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\r\n      }\r\n    }\r\n    renderText(\r\n      ctx,\r\n      scale._pointLabels[i],\r\n      x,\r\n      y + (plFont.lineHeight / 2),\r\n      plFont,\r\n      {\r\n        color: optsAtIndex.color,\r\n        textAlign: textAlign,\r\n        textBaseline: 'middle'\r\n      }\r\n    );\r\n  }\r\n}\r\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\r\n  const {ctx} = scale;\r\n  if (circular) {\r\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\r\n  } else {\r\n    let pointPosition = scale.getPointPosition(0, radius);\r\n    ctx.moveTo(pointPosition.x, pointPosition.y);\r\n    for (let i = 1; i < labelCount; i++) {\r\n      pointPosition = scale.getPointPosition(i, radius);\r\n      ctx.lineTo(pointPosition.x, pointPosition.y);\r\n    }\r\n  }\r\n}\r\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\r\n  const ctx = scale.ctx;\r\n  const circular = gridLineOpts.circular;\r\n  const {color, lineWidth} = gridLineOpts;\r\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\r\n    return;\r\n  }\r\n  ctx.save();\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = lineWidth;\r\n  ctx.setLineDash(gridLineOpts.borderDash);\r\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\r\n  ctx.beginPath();\r\n  pathRadiusLine(scale, radius, circular, labelCount);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\nfunction createPointLabelContext(parent, index, label) {\r\n  return createContext(parent, {\r\n    label,\r\n    index,\r\n    type: 'pointLabel'\r\n  });\r\n}\r\nclass RadialLinearScale extends LinearScaleBase {\r\n  constructor(cfg) {\r\n    super(cfg);\r\n    this.xCenter = undefined;\r\n    this.yCenter = undefined;\r\n    this.drawingArea = undefined;\r\n    this._pointLabels = [];\r\n    this._pointLabelItems = [];\r\n  }\r\n  setDimensions() {\r\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\r\n    const w = this.width = this.maxWidth - padding.width;\r\n    const h = this.height = this.maxHeight - padding.height;\r\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\r\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\r\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\r\n  }\r\n  determineDataLimits() {\r\n    const {min, max} = this.getMinMax(false);\r\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\r\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\r\n    this.handleTickRangeOptions();\r\n  }\r\n  computeTickLimit() {\r\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\r\n  }\r\n  generateTickLabels(ticks) {\r\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\r\n    this._pointLabels = this.getLabels()\r\n      .map((value, index) => {\r\n        const label = callback(this.options.pointLabels.callback, [value, index], this);\r\n        return label || label === 0 ? label : '';\r\n      })\r\n      .filter((v, i) => this.chart.getDataVisibility(i));\r\n  }\r\n  fit() {\r\n    const opts = this.options;\r\n    if (opts.display && opts.pointLabels.display) {\r\n      fitWithPointLabels(this);\r\n    } else {\r\n      this.setCenterPoint(0, 0, 0, 0);\r\n    }\r\n  }\r\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\r\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\r\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\r\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\r\n  }\r\n  getIndexAngle(index) {\r\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\r\n    const startAngle = this.options.startAngle || 0;\r\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\r\n  }\r\n  getDistanceFromCenterForValue(value) {\r\n    if (isNullOrUndef(value)) {\r\n      return NaN;\r\n    }\r\n    const scalingFactor = this.drawingArea / (this.max - this.min);\r\n    if (this.options.reverse) {\r\n      return (this.max - value) * scalingFactor;\r\n    }\r\n    return (value - this.min) * scalingFactor;\r\n  }\r\n  getValueForDistanceFromCenter(distance) {\r\n    if (isNullOrUndef(distance)) {\r\n      return NaN;\r\n    }\r\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\r\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\r\n  }\r\n  getPointLabelContext(index) {\r\n    const pointLabels = this._pointLabels || [];\r\n    if (index >= 0 && index < pointLabels.length) {\r\n      const pointLabel = pointLabels[index];\r\n      return createPointLabelContext(this.getContext(), index, pointLabel);\r\n    }\r\n  }\r\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\r\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\r\n    return {\r\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\r\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\r\n      angle\r\n    };\r\n  }\r\n  getPointPositionForValue(index, value) {\r\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n  }\r\n  getBasePosition(index) {\r\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\r\n  }\r\n  getPointLabelPosition(index) {\r\n    const {left, top, right, bottom} = this._pointLabelItems[index];\r\n    return {\r\n      left,\r\n      top,\r\n      right,\r\n      bottom,\r\n    };\r\n  }\r\n  drawBackground() {\r\n    const {backgroundColor, grid: {circular}} = this.options;\r\n    if (backgroundColor) {\r\n      const ctx = this.ctx;\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\r\n      ctx.closePath();\r\n      ctx.fillStyle = backgroundColor;\r\n      ctx.fill();\r\n      ctx.restore();\r\n    }\r\n  }\r\n  drawGrid() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    const {angleLines, grid} = opts;\r\n    const labelCount = this._pointLabels.length;\r\n    let i, offset, position;\r\n    if (opts.pointLabels.display) {\r\n      drawPointLabels(this, labelCount);\r\n    }\r\n    if (grid.display) {\r\n      this.ticks.forEach((tick, index) => {\r\n        if (index !== 0) {\r\n          offset = this.getDistanceFromCenterForValue(tick.value);\r\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\r\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\r\n        }\r\n      });\r\n    }\r\n    if (angleLines.display) {\r\n      ctx.save();\r\n      for (i = labelCount - 1; i >= 0; i--) {\r\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\r\n        const {color, lineWidth} = optsAtIndex;\r\n        if (!lineWidth || !color) {\r\n          continue;\r\n        }\r\n        ctx.lineWidth = lineWidth;\r\n        ctx.strokeStyle = color;\r\n        ctx.setLineDash(optsAtIndex.borderDash);\r\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\r\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\r\n        position = this.getPointPosition(i, offset);\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.xCenter, this.yCenter);\r\n        ctx.lineTo(position.x, position.y);\r\n        ctx.stroke();\r\n      }\r\n      ctx.restore();\r\n    }\r\n  }\r\n  drawBorder() {}\r\n  drawLabels() {\r\n    const ctx = this.ctx;\r\n    const opts = this.options;\r\n    const tickOpts = opts.ticks;\r\n    if (!tickOpts.display) {\r\n      return;\r\n    }\r\n    const startAngle = this.getIndexAngle(0);\r\n    let offset, width;\r\n    ctx.save();\r\n    ctx.translate(this.xCenter, this.yCenter);\r\n    ctx.rotate(startAngle);\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    this.ticks.forEach((tick, index) => {\r\n      if (index === 0 && !opts.reverse) {\r\n        return;\r\n      }\r\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\r\n      const tickFont = toFont(optsAtIndex.font);\r\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\r\n      if (optsAtIndex.showLabelBackdrop) {\r\n        ctx.font = tickFont.string;\r\n        width = ctx.measureText(tick.label).width;\r\n        ctx.fillStyle = optsAtIndex.backdropColor;\r\n        const padding = toPadding(optsAtIndex.backdropPadding);\r\n        ctx.fillRect(\r\n          -width / 2 - padding.left,\r\n          -offset - tickFont.size / 2 - padding.top,\r\n          width + padding.width,\r\n          tickFont.size + padding.height\r\n        );\r\n      }\r\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\r\n        color: optsAtIndex.color,\r\n      });\r\n    });\r\n    ctx.restore();\r\n  }\r\n  drawTitle() {}\r\n}\r\nRadialLinearScale.id = 'radialLinear';\r\nRadialLinearScale.defaults = {\r\n  display: true,\r\n  animate: true,\r\n  position: 'chartArea',\r\n  angleLines: {\r\n    display: true,\r\n    lineWidth: 1,\r\n    borderDash: [],\r\n    borderDashOffset: 0.0\r\n  },\r\n  grid: {\r\n    circular: false\r\n  },\r\n  startAngle: 0,\r\n  ticks: {\r\n    showLabelBackdrop: true,\r\n    callback: Ticks.formatters.numeric\r\n  },\r\n  pointLabels: {\r\n    backdropColor: undefined,\r\n    backdropPadding: 2,\r\n    display: true,\r\n    font: {\r\n      size: 10\r\n    },\r\n    callback(label) {\r\n      return label;\r\n    },\r\n    padding: 5,\r\n    centerPointLabels: false\r\n  }\r\n};\r\nRadialLinearScale.defaultRoutes = {\r\n  'angleLines.color': 'borderColor',\r\n  'pointLabels.color': 'color',\r\n  'ticks.color': 'color'\r\n};\r\nRadialLinearScale.descriptors = {\r\n  angleLines: {\r\n    _fallback: 'grid'\r\n  }\r\n};\r\n\r\nconst INTERVALS = {\r\n  millisecond: {common: true, size: 1, steps: 1000},\r\n  second: {common: true, size: 1000, steps: 60},\r\n  minute: {common: true, size: 60000, steps: 60},\r\n  hour: {common: true, size: 3600000, steps: 24},\r\n  day: {common: true, size: 86400000, steps: 30},\r\n  week: {common: false, size: 604800000, steps: 4},\r\n  month: {common: true, size: 2.628e9, steps: 12},\r\n  quarter: {common: false, size: 7.884e9, steps: 4},\r\n  year: {common: true, size: 3.154e10}\r\n};\r\nconst UNITS = (Object.keys(INTERVALS));\r\nfunction sorter(a, b) {\r\n  return a - b;\r\n}\r\nfunction parse(scale, input) {\r\n  if (isNullOrUndef(input)) {\r\n    return null;\r\n  }\r\n  const adapter = scale._adapter;\r\n  const {parser, round, isoWeekday} = scale._parseOpts;\r\n  let value = input;\r\n  if (typeof parser === 'function') {\r\n    value = parser(value);\r\n  }\r\n  if (!isNumberFinite(value)) {\r\n    value = typeof parser === 'string'\r\n      ? adapter.parse(value, parser)\r\n      : adapter.parse(value);\r\n  }\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (round) {\r\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\r\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\r\n      : adapter.startOf(value, round);\r\n  }\r\n  return +value;\r\n}\r\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\r\n  const ilen = UNITS.length;\r\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\r\n    const interval = INTERVALS[UNITS[i]];\r\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\r\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\r\n      return UNITS[i];\r\n    }\r\n  }\r\n  return UNITS[ilen - 1];\r\n}\r\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\r\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\r\n    const unit = UNITS[i];\r\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\r\n      return unit;\r\n    }\r\n  }\r\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\r\n}\r\nfunction determineMajorUnit(unit) {\r\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\r\n    if (INTERVALS[UNITS[i]].common) {\r\n      return UNITS[i];\r\n    }\r\n  }\r\n}\r\nfunction addTick(ticks, time, timestamps) {\r\n  if (!timestamps) {\r\n    ticks[time] = true;\r\n  } else if (timestamps.length) {\r\n    const {lo, hi} = _lookup(timestamps, time);\r\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\r\n    ticks[timestamp] = true;\r\n  }\r\n}\r\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\r\n  const adapter = scale._adapter;\r\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\r\n  const last = ticks[ticks.length - 1].value;\r\n  let major, index;\r\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\r\n    index = map[major];\r\n    if (index >= 0) {\r\n      ticks[index].major = true;\r\n    }\r\n  }\r\n  return ticks;\r\n}\r\nfunction ticksFromTimestamps(scale, values, majorUnit) {\r\n  const ticks = [];\r\n  const map = {};\r\n  const ilen = values.length;\r\n  let i, value;\r\n  for (i = 0; i < ilen; ++i) {\r\n    value = values[i];\r\n    map[value] = i;\r\n    ticks.push({\r\n      value,\r\n      major: false\r\n    });\r\n  }\r\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\r\n}\r\nclass TimeScale extends Scale {\r\n  constructor(props) {\r\n    super(props);\r\n    this._cache = {\r\n      data: [],\r\n      labels: [],\r\n      all: []\r\n    };\r\n    this._unit = 'day';\r\n    this._majorUnit = undefined;\r\n    this._offsets = {};\r\n    this._normalized = false;\r\n    this._parseOpts = undefined;\r\n  }\r\n  init(scaleOpts, opts) {\r\n    const time = scaleOpts.time || (scaleOpts.time = {});\r\n    const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);\r\n    mergeIf(time.displayFormats, adapter.formats());\r\n    this._parseOpts = {\r\n      parser: time.parser,\r\n      round: time.round,\r\n      isoWeekday: time.isoWeekday\r\n    };\r\n    super.init(scaleOpts);\r\n    this._normalized = opts.normalized;\r\n  }\r\n  parse(raw, index) {\r\n    if (raw === undefined) {\r\n      return null;\r\n    }\r\n    return parse(this, raw);\r\n  }\r\n  beforeLayout() {\r\n    super.beforeLayout();\r\n    this._cache = {\r\n      data: [],\r\n      labels: [],\r\n      all: []\r\n    };\r\n  }\r\n  determineDataLimits() {\r\n    const options = this.options;\r\n    const adapter = this._adapter;\r\n    const unit = options.time.unit || 'day';\r\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\r\n    function _applyBounds(bounds) {\r\n      if (!minDefined && !isNaN(bounds.min)) {\r\n        min = Math.min(min, bounds.min);\r\n      }\r\n      if (!maxDefined && !isNaN(bounds.max)) {\r\n        max = Math.max(max, bounds.max);\r\n      }\r\n    }\r\n    if (!minDefined || !maxDefined) {\r\n      _applyBounds(this._getLabelBounds());\r\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\r\n        _applyBounds(this.getMinMax(false));\r\n      }\r\n    }\r\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\r\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\r\n    this.min = Math.min(min, max - 1);\r\n    this.max = Math.max(min + 1, max);\r\n  }\r\n  _getLabelBounds() {\r\n    const arr = this.getLabelTimestamps();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let max = Number.NEGATIVE_INFINITY;\r\n    if (arr.length) {\r\n      min = arr[0];\r\n      max = arr[arr.length - 1];\r\n    }\r\n    return {min, max};\r\n  }\r\n  buildTicks() {\r\n    const options = this.options;\r\n    const timeOpts = options.time;\r\n    const tickOpts = options.ticks;\r\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\r\n    if (options.bounds === 'ticks' && timestamps.length) {\r\n      this.min = this._userMin || timestamps[0];\r\n      this.max = this._userMax || timestamps[timestamps.length - 1];\r\n    }\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const ticks = _filterBetween(timestamps, min, max);\r\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\r\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\r\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\r\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\r\n      : determineMajorUnit(this._unit);\r\n    this.initOffsets(timestamps);\r\n    if (options.reverse) {\r\n      ticks.reverse();\r\n    }\r\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\r\n  }\r\n  afterAutoSkip() {\r\n    if (this.options.offsetAfterAutoskip) {\r\n      this.initOffsets(this.ticks.map(tick => +tick.value));\r\n    }\r\n  }\r\n  initOffsets(timestamps) {\r\n    let start = 0;\r\n    let end = 0;\r\n    let first, last;\r\n    if (this.options.offset && timestamps.length) {\r\n      first = this.getDecimalForValue(timestamps[0]);\r\n      if (timestamps.length === 1) {\r\n        start = 1 - first;\r\n      } else {\r\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\r\n      }\r\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\r\n      if (timestamps.length === 1) {\r\n        end = last;\r\n      } else {\r\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\r\n      }\r\n    }\r\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\r\n    start = _limitValue(start, 0, limit);\r\n    end = _limitValue(end, 0, limit);\r\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\r\n  }\r\n  _generate() {\r\n    const adapter = this._adapter;\r\n    const min = this.min;\r\n    const max = this.max;\r\n    const options = this.options;\r\n    const timeOpts = options.time;\r\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\r\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\r\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n    const hasWeekday = isNumber(weekday) || weekday === true;\r\n    const ticks = {};\r\n    let first = min;\r\n    let time, count;\r\n    if (hasWeekday) {\r\n      first = +adapter.startOf(first, 'isoWeek', weekday);\r\n    }\r\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\r\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\r\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\r\n    }\r\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\r\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\r\n      addTick(ticks, time, timestamps);\r\n    }\r\n    if (time === max || options.bounds === 'ticks' || count === 1) {\r\n      addTick(ticks, time, timestamps);\r\n    }\r\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\r\n  }\r\n  getLabelForValue(value) {\r\n    const adapter = this._adapter;\r\n    const timeOpts = this.options.time;\r\n    if (timeOpts.tooltipFormat) {\r\n      return adapter.format(value, timeOpts.tooltipFormat);\r\n    }\r\n    return adapter.format(value, timeOpts.displayFormats.datetime);\r\n  }\r\n  _tickFormatFunction(time, index, ticks, format) {\r\n    const options = this.options;\r\n    const formats = options.time.displayFormats;\r\n    const unit = this._unit;\r\n    const majorUnit = this._majorUnit;\r\n    const minorFormat = unit && formats[unit];\r\n    const majorFormat = majorUnit && formats[majorUnit];\r\n    const tick = ticks[index];\r\n    const major = majorUnit && majorFormat && tick && tick.major;\r\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\r\n    const formatter = options.ticks.callback;\r\n    return formatter ? callback(formatter, [label, index, ticks], this) : label;\r\n  }\r\n  generateTickLabels(ticks) {\r\n    let i, ilen, tick;\r\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\r\n      tick = ticks[i];\r\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\r\n    }\r\n  }\r\n  getDecimalForValue(value) {\r\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\r\n  }\r\n  getPixelForValue(value) {\r\n    const offsets = this._offsets;\r\n    const pos = this.getDecimalForValue(value);\r\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\r\n  }\r\n  getValueForPixel(pixel) {\r\n    const offsets = this._offsets;\r\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n    return this.min + pos * (this.max - this.min);\r\n  }\r\n  _getLabelSize(label) {\r\n    const ticksOpts = this.options.ticks;\r\n    const tickLabelWidth = this.ctx.measureText(label).width;\r\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\r\n    const cosRotation = Math.cos(angle);\r\n    const sinRotation = Math.sin(angle);\r\n    const tickFontSize = this._resolveTickFontOptions(0).size;\r\n    return {\r\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\r\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\r\n    };\r\n  }\r\n  _getLabelCapacity(exampleTime) {\r\n    const timeOpts = this.options.time;\r\n    const displayFormats = timeOpts.displayFormats;\r\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\r\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\r\n    const size = this._getLabelSize(exampleLabel);\r\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\r\n    return capacity > 0 ? capacity : 1;\r\n  }\r\n  getDataTimestamps() {\r\n    let timestamps = this._cache.data || [];\r\n    let i, ilen;\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n    const metas = this.getMatchingVisibleMetas();\r\n    if (this._normalized && metas.length) {\r\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\r\n    }\r\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\r\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\r\n    }\r\n    return (this._cache.data = this.normalize(timestamps));\r\n  }\r\n  getLabelTimestamps() {\r\n    const timestamps = this._cache.labels || [];\r\n    let i, ilen;\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n    const labels = this.getLabels();\r\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\r\n      timestamps.push(parse(this, labels[i]));\r\n    }\r\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\r\n  }\r\n  normalize(values) {\r\n    return _arrayUnique(values.sort(sorter));\r\n  }\r\n}\r\nTimeScale.id = 'time';\r\nTimeScale.defaults = {\r\n  bounds: 'data',\r\n  adapters: {},\r\n  time: {\r\n    parser: false,\r\n    unit: false,\r\n    round: false,\r\n    isoWeekday: false,\r\n    minUnit: 'millisecond',\r\n    displayFormats: {}\r\n  },\r\n  ticks: {\r\n    source: 'auto',\r\n    major: {\r\n      enabled: false\r\n    }\r\n  }\r\n};\r\n\r\nfunction interpolate(table, val, reverse) {\r\n  let lo = 0;\r\n  let hi = table.length - 1;\r\n  let prevSource, nextSource, prevTarget, nextTarget;\r\n  if (reverse) {\r\n    if (val >= table[lo].pos && val <= table[hi].pos) {\r\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\r\n    }\r\n    ({pos: prevSource, time: prevTarget} = table[lo]);\r\n    ({pos: nextSource, time: nextTarget} = table[hi]);\r\n  } else {\r\n    if (val >= table[lo].time && val <= table[hi].time) {\r\n      ({lo, hi} = _lookupByKey(table, 'time', val));\r\n    }\r\n    ({time: prevSource, pos: prevTarget} = table[lo]);\r\n    ({time: nextSource, pos: nextTarget} = table[hi]);\r\n  }\r\n  const span = nextSource - prevSource;\r\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\r\n}\r\nclass TimeSeriesScale extends TimeScale {\r\n  constructor(props) {\r\n    super(props);\r\n    this._table = [];\r\n    this._minPos = undefined;\r\n    this._tableRange = undefined;\r\n  }\r\n  initOffsets() {\r\n    const timestamps = this._getTimestampsForTable();\r\n    const table = this._table = this.buildLookupTable(timestamps);\r\n    this._minPos = interpolate(table, this.min);\r\n    this._tableRange = interpolate(table, this.max) - this._minPos;\r\n    super.initOffsets(timestamps);\r\n  }\r\n  buildLookupTable(timestamps) {\r\n    const {min, max} = this;\r\n    const items = [];\r\n    const table = [];\r\n    let i, ilen, prev, curr, next;\r\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n      curr = timestamps[i];\r\n      if (curr >= min && curr <= max) {\r\n        items.push(curr);\r\n      }\r\n    }\r\n    if (items.length < 2) {\r\n      return [\r\n        {time: min, pos: 0},\r\n        {time: max, pos: 1}\r\n      ];\r\n    }\r\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\r\n      next = items[i + 1];\r\n      prev = items[i - 1];\r\n      curr = items[i];\r\n      if (Math.round((next + prev) / 2) !== curr) {\r\n        table.push({time: curr, pos: i / (ilen - 1)});\r\n      }\r\n    }\r\n    return table;\r\n  }\r\n  _getTimestampsForTable() {\r\n    let timestamps = this._cache.all || [];\r\n    if (timestamps.length) {\r\n      return timestamps;\r\n    }\r\n    const data = this.getDataTimestamps();\r\n    const label = this.getLabelTimestamps();\r\n    if (data.length && label.length) {\r\n      timestamps = this.normalize(data.concat(label));\r\n    } else {\r\n      timestamps = data.length ? data : label;\r\n    }\r\n    timestamps = this._cache.all = timestamps;\r\n    return timestamps;\r\n  }\r\n  getDecimalForValue(value) {\r\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\r\n  }\r\n  getValueForPixel(pixel) {\r\n    const offsets = this._offsets;\r\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\r\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\r\n  }\r\n}\r\nTimeSeriesScale.id = 'timeseries';\r\nTimeSeriesScale.defaults = TimeScale.defaults;\r\n\r\nvar scales = /*#__PURE__*/Object.freeze({\r\n__proto__: null,\r\nCategoryScale: CategoryScale,\r\nLinearScale: LinearScale,\r\nLogarithmicScale: LogarithmicScale,\r\nRadialLinearScale: RadialLinearScale,\r\nTimeScale: TimeScale,\r\nTimeSeriesScale: TimeSeriesScale\r\n});\r\n\r\nChart.register(controllers, scales, elements, plugins);\r\nChart.helpers = {...helpers};\r\nChart._adapters = _adapters;\r\nChart.Animation = Animation;\r\nChart.Animations = Animations;\r\nChart.animator = animator;\r\nChart.controllers = registry.controllers.items;\r\nChart.DatasetController = DatasetController;\r\nChart.Element = Element;\r\nChart.elements = elements;\r\nChart.Interaction = Interaction;\r\nChart.layouts = layouts;\r\nChart.platforms = platforms;\r\nChart.Scale = Scale;\r\nChart.Ticks = Ticks;\r\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\r\nChart.Chart = Chart;\r\nif (typeof window !== 'undefined') {\r\n  window.Chart = Chart;\r\n}\r\n\r\nreturn Chart;\r\n\r\n}));"],"names":["global","factory","this","requestAnimFrame","window","callback","requestAnimationFrame","throttled","fn","thisArg","updateFn","updateArgs","args","Array","prototype","slice","call","ticking","rest","apply","debounce","delay","timeout","clearTimeout","setTimeout","_toLeftRightCenter","align","_alignStartEnd","start","end","_textX","left","right","rtl","animator","constructor","_request","_charts","Map","_running","_lastDate","undefined","_notify","chart","anims","date","type","callbacks","listeners","numSteps","duration","forEach","initial","currentStep","Math","min","_refresh","_update","Date","now","remaining","running","items","length","item","i","draw","_active","_total","tick","pop","_getAnims","charts","get","complete","progress","set","listen","event","cb","push","add","has","reduce","acc","cur","max","_duration","stop","cancel","remove","delete","round","v","lim","l","h","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","a","b","c","d","e","f","hex","h1","h2","eq","hexString","r","g","isShort","alpha","HUE_RE","hsl2rgbn","s","n","k","hsv2rgbn","hwb2rgbn","w","rgb","rgb2hsl","hueValue","calln","isArray","map","hsl2rgb","hue","hueParse","str","m","exec","p1","p2","hwb2rgb","hsv2rgb","map$2","x","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","nameParse","unpacked","keys","Object","tkeys","j","ok","nk","replace","parseInt","unpack","transparent","toLowerCase","RGB_RE","to","pow","from","modHSL","ratio","tmp","clone$1","proto","assign","fromObject","input","functionParse","charAt","rgbParse","Color","ret","len","_rgb","_valid","valid","obj","rgbString","hslString","mix","color","weight","c1","c2","w2","p","w1","interpolate","t","rgb1","rgb2","interpolate$1","clone","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","index_esm","isPatternOrGradient","value","toString","getHoverColor","noop","uid","id","isNullOrUndef","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toPercentage","dimension","endsWith","parseFloat","toDimension","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","index","source","target","create","klen","isValidKey","key","indexOf","_merger","options","tval","sval","merge","sources","merger","mergeIf","_mergerIf","hasOwnProperty","indexOfDotOrLength","idx","resolveObjectKey","pos","_capitalize","toUpperCase","defined","isFunction","setsEqual","size","_isClickEvent","overrides","descriptors","getScope$1","node","split","root","scope","values","defaults","_descriptors","animation","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","enumerable","local","_scriptable","startsWith","_indexable","_fallback","_lookup","table","cmp","mid","hi","lo","_lookupByKey","_rlookupByKey","_filterBetween","arrayEvents","listenArrayEvents","array","listener","_chartjs","defineProperty","configurable","method","base","res","object","unlistenArrayEvents","stub","splice","_arrayUnique","Set","PI","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","niceNum","range","roundedRange","almostEquals","niceRange","floor","fraction","_factorize","result","sqrt","sort","isNumber","isNaN","y","epsilon","abs","almostWhole","rounded","_setMinAndMaxByKey","property","toRadians","degrees","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","_isBetween","_isDomSupported","document","_getParentNode","domNode","parent","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","getStyle","el","getPropertyValue","positions","getPositionedStyle","styles","suffix","width","height","top","bottom","getRelativePosition","evt","canvas","currentDevicePixelRatio","borderBox","boxSizing","paddings","borders","box","touches","offsetX","offsetY","shadowRoot","useOffsetPos","rect","getBoundingClientRect","clientX","clientY","getCanvasPosition","xOffset","yOffset","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","maxWidth","maxHeight","containerSize","container","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","getContainerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","matches","match","toFontString","_measureText","data","gc","longest","string","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","halfWidth","clearCanvas","getContext","resetTransform","clearRect","drawPoint","cornerRadius","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","fill","borderWidth","stroke","_isPointInArea","point","area","margin","clipArea","clip","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","renderText","text","opts","lines","strokeWidth","strokeColor","line","setRenderOpts","strokeStyle","lineWidth","strokeText","fillText","decorateText","translation","fillStyle","textAlign","textBaseline","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","decorationWidth","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","_createResolver","scopes","prefixes","rootScopes","fallback","getTarget","_resolve","Symbol","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","prop","_keys","_cached","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","includes","ownKeys","storage","_storage","_attachContext","proxy","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","isScriptable","Error","join","needsSubResolver","createSubResolver","_resolveScriptable","isIndexable","arr","filter","resolver","_resolveArray","_resolveWithContext","allKeys","scriptable","indexable","_allKeys","readKey","prefix","resolve","resolveFallback","getScope","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","meta","count","iScale","_parsing","parsed","parse","EPSILON","getPoint","points","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","current","next","d01","d12","s01","s12","fa","fb","monotoneAdjust","deltaK","mK","pointsLen","alphaK","betaK","tauK","squaredMagnitude","pointCurrent","pointAfter","monotoneCompute","valueAxis","delta","pointBefore","iPixel","vPixel","splineCurveMonotone","slopeDelta","capControlPoint","pt","_updateBezierControlPoints","loop","controlPoints","spanGaps","cubicInterpolationMode","prev","tension","capBezierPoints","inArea","inAreaPrev","inAreaNext","atEdge","elasticIn","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","intlCache","formatNumber","num","locale","cacheKey","JSON","stringify","formatter","Intl","NumberFormat","getNumberFormat","format","LINE_HEIGHT","RegExp","FONT_STYLE","toLineHeight","_readValueToProps","props","objProps","read","toTRBL","toTRBLCorners","toPadding","toFont","console","warn","inputs","info","cacheable","_addGrace","minmax","grace","beginAtZero","change","keepZero","createContext","parentContext","getRtlAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","_boundSegment","segment","bounds","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","_boundSegments","segments","sub","_computeSegments","segmentOptions","_loop","findStartAndEnd","splitByStyles","last","solidSegments","_fullLoop","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","doSplitByStyles","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","helpers","freeze","__proto__","easingEffects","_deprecated","fontString","pixelSize","fontStyle","fontFamily","binarySearch","metaset","axis","controller","_sorted","_cachedMeta","lookupMethod","_reversePixels","_sharedOptions","getRange","evaluateInteractionItems","position","handler","metasets","getSortedVisibleDatasetMetas","getIntersectItems","useFinalPosition","isPointInArea","chartArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","center","getCenterPoint","getNearestItems","startAngle","endAngle","getProps","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","dataset","getDatasetMeta","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","layouts","params","stacks","wrap","stack","stackWeight","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","factor","horizontal","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","other","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","changed","update","setBoxDims","placeBoxes","userPadding","padding","autoPadding","addBox","_layers","z","removeBox","layoutItem","configure","minPadding","layoutBoxes","isHorizontal","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","concat","rightAndBottom","vertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","total","display","updatePos","handleMaxPadding","BasePlatform","acquireContext","releaseContext","isAttached","updateConfig","config","BasicPlatform","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","entries","trigger","entry","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","resize","createResizeObserver","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","native","fromNativeEvent","addListener","DomPlatform","renderHeight","getAttribute","renderWidth","displayWidth","displayHeight","initCanvas","removeAttribute","setAttribute","proxies","$proxies","attach","detach","isConnected","_detectPlatform","OffscreenCanvas","platforms","interpolators","boolean","c0","number","Animation","cfg","currentValue","_fn","_easing","easing","_start","_target","_prop","_from","_to","_promises","active","elapsed","remain","wait","promises","Promise","rej","resolved","animationOptions","colors","properties","numbers","show","animations","visible","hide","Animations","_properties","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","$shared","$animations","resolveTargetOptions","_createAnimations","anim","all","awaitAll","then","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","_getSortedDatasetMetas","applyStack","dsIndex","singleMode","otherValue","isStacked","stacked","getOrCreateStack","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","_stacks","iAxis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","getFirstScaleId","shift","clearStacks","_parsed","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","_ctx","_cachedDataOpts","getMeta","_type","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","_stacked","addElements","updateIndex","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","xScale","getScaleForId","yScale","rScale","scaleID","_getOtherScale","reset","_destroy","_dataCheck","adata","convertObjectDataToArray","isExtensible","datasetElementType","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","parsedValue","NaN","getMinMax","canStack","otherScale","hidden","createStack","NEGATIVE_INFINITY","otherMin","otherMax","minDefined","maxDefined","getUserBounds","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","toClip","defaultClip","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","dataElementType","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","transition","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","updateElement","updateSharedOptions","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","Element","tooltipPosition","hasValue","final","defaultRoutes","formatters","numeric","tickValue","ticks","notation","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","Ticks","autoSkip","tickOpts","ticksLimit","maxTicksLimit","offset","tickLength","_tickSize","maxScale","_length","maxChart","_maxLength","determineMaxTicks","majorIndices","major","enabled","getMajorIndices","numMajorIndices","first","newTicks","spacing","ceil","skipMajors","evenMajorSpacing","diff","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","grid","drawBorder","drawOnChartArea","drawTicks","tickWidth","tickColor","title","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkipPadding","labelOffset","minor","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","offsetFromEdge","edge","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","_startPixel","_endPixel","lineValue","getPixelForTick","getTickMarkLength","getTitleHeight","titleAlign","reverseAlign","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","startPixel","endPixel","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","tickFont","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","getPixelForValue","getValueForPixel","getPixelForDecimal","decimal","getDecimalForPixel","getBasePixel","getBaseValue","createTickContext","optionTicks","rot","_computeGridLineItems","ticksLength","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","limit","step","optsAtIndex","lineColor","tickBorderDash","tickBorderDashOffset","_computeLabelItems","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","backdrop","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","fillRect","getLineWidthForValue","findIndex","drawGrid","drawLine","setLineDash","lineDashOffset","lastLineWidth","drawLabels","drawTitle","titleX","titleY","titleArgs","tz","gz","axisID","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","register","parentScope","isIChartComponent","itemDefaults","routes","propertyParts","sourceName","sourceScope","parts","routeDefaults","registerDefaults","unregister","registry","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","component","camelMethod","PluginService","_init","notify","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","some","pluginScopeKeys","getIndexAxis","datasetDefaults","determineAxis","scaleOptions","initOptions","chartDefaults","configScales","chartIndexAxis","firstIDs","scaleConf","error","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","mergeScaleConfig","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","Chart","userConfig","initialCanvas","existingChart","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","newControllers","order","isDatasetVisible","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","useClip","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","_ref2","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","lastEvent","determineLastEvent","invalidatePlugins","abstract","version","DateAdapter","formats","timestamp","amount","unit","startOf","weekday","endOf","members","_adapters","_date","computeMinSampleSize","$bar","visibleMetas","getAllScaleValues","curr","updateMinAndPrev","parseValue","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","borderSkipped","borderProps","enableBorderRadius","parseEdge","orig","v2","startEnd","setInflateAmount","inflateAmount","BarController","iAxisKey","vAxisKey","bars","ruler","_getRuler","firstOpts","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","_getStacks","grouped","_getStackCount","_getStackIndex","pixels","barThickness","stackCount","categoryPercentage","barPercentage","baseValue","minBarLength","actualBase","floating","barSign","halfGrid","skipNull","maxBarThickness","Infinity","percent","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","_index_","_value_","BubbleController","super","tooltip","DoughnutController","innerRadius","outerRadius","getter","_getRotation","_getCircumference","circumference","_getRotationExtents","arcs","getMaxBorderWidth","getMaxOffset","maxSize","cutout","chartWeight","_getRingWeight","ratioX","ratioY","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","calculateTotal","_getRingWeightOffset","_circumference","animateRotate","calculateCircumference","animationOpts","centerX","centerY","animateScale","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","legend","generateLabels","legendItem","tooltipItem","dataLabel","formattedValue","LineController","animationsDisabled","pointCount","getStartAndCountOfVisiblePoints","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","scaleRangesChanged","_decimated","animated","maxGapLength","directUpdate","prevParsed","nullData","border","lastPoint","updateControlPoints","PolarAreaController","bind","_updateRadius","cutoutPercentage","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","angleLines","circular","pointLabels","PieController","RadarController","pointPosition","getPointPositionForValue","ScatterController","clipArc","pixelMargin","angleMargin","parseBorderRadius$1","angleDelta","o","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","pCenter","p4","p8","inner","lineJoin","fullCircles","drawFullCircleBorders","ArcElement","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","setStyle","lineCap","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","path","_path","strokePathWithCache","segmentMethod","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","_interpolate","_getInterpolationMethod","interpolated","inRange$1","hitRadius","PointElement","mouseX","mouseY","inXRange","inYRange","hoverRadius","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","inflateRect","refRect","BarElement","addRectPath","cleanDecimatedDataset","cleanDecimatedData","plugin_decimation","algorithm","beforeElementsUpdate","xAxis","decimated","getStartAndCountOfVisiblePointsSimplified","threshold","samples","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_ref4","_pointsFromSegments","_resolveTarget","propagate","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","unshift","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","below","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","above","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","_args","$filler","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","heightLimit","totalWidth","currentColWidth","currentColHeight","col","adjustHitBoxes","rtlHelper","hitbox","_draw","defaultColor","fontColor","halfFontSize","cursor","textDirection","lineDash","drawOptions","SQRT2","yBoxTop","xBoxLeft","drawLegendBox","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","sameItem","plugin_legend","_element","afterEvent","ci","Title","_padding","textSize","_drawArgs","fontOpts","plugin_title","titleBlock","createTitle","WeakMap","plugin_subtitle","positioners","average","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","createTooltipItem","getTooltipSize","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","getTitle","beforeTitle","afterTitle","getBeforeBody","getBody","bodyItems","scoped","beforeLabel","afterLabel","getAfterBody","getFooter","beforeFooter","afterFooter","_createItems","itemSort","labelColor","labelPointStyle","labelTextColor","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","bodyColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","_ref5","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","labelCount","Decimation","Filler","SubTitle","findOrAddLabel","addedLabels","addIfString","lastIndexOf","CategoryScale","_startValue","_valueRange","_addedLabels","added","relativeLabelSize","minSpacing","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getTickLimit","maxTicks","stepSize","computeTickLimit","generationOptions","dataRange","precision","maxDigits","includeBounds","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks$1","LinearScale","isMajor","tickVal","LogarithmicScale","_zero","exp","endExp","endSignificand","significand","lastTick","generateTicks","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","updateLimits","setCenterPoint","_pointLabelItems","extra","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","buildPointLabelItems","hLimits","vLimits","pathRadiusLine","RadialLinearScale","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","getBasePosition","getPointLabelPosition","backdropLeft","backdropTop","backdropWidth","backdropHeight","drawPointLabels","gridLineOpts","drawRadiusLine","animate","INTERVALS","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","addTick","time","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","_unit","_majorUnit","_offsets","_normalized","adapters","displayFormats","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","hasWeekday","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","exports","module","define","amd","globalThis","self"],"mappings":"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"}