{"version":3,"file":"courseeditor.min.js","sources":["../../../src/local/courseeditor/courseeditor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport {Reactive} from 'core/reactive';\r\nimport notification from 'core/notification';\r\nimport Exporter from 'core_courseformat/local/courseeditor/exporter';\r\nimport log from 'core/log';\r\nimport ajax from 'core/ajax';\r\nimport * as Storage from 'core/sessionstorage';\r\n\r\n/**\r\n * Main course editor module.\r\n *\r\n * All formats can register new components on this object to create new reactive\r\n * UI components that watch the current course state.\r\n *\r\n * @module     core_courseformat/local/courseeditor/courseeditor\r\n * @class     core_courseformat/local/courseeditor/courseeditor\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nexport default class extends Reactive {\r\n\r\n    /**\r\n     * The current state cache key\r\n     *\r\n     * The state cache is considered dirty if the state changes from the last page or\r\n     * if the page has editing mode on.\r\n     *\r\n     * @attribute stateKey\r\n     * @type number|null\r\n     * @default 1\r\n     * @package\r\n     */\r\n    stateKey = 1;\r\n\r\n    /**\r\n     * The current page section return\r\n     * @attribute sectionReturn\r\n     * @type number\r\n     * @default 0\r\n     */\r\n    sectionReturn = 0;\r\n\r\n    /**\r\n     * Set up the course editor when the page is ready.\r\n     *\r\n     * The course can only be loaded once per instance. Otherwise an error is thrown.\r\n     *\r\n     * The backend can inform the module of the current state key. This key changes every time some\r\n     * update in the course affect the current user state. Some examples are:\r\n     *  - The course content has been edited\r\n     *  - The user marks some activity as completed\r\n     *  - The user collapses or uncollapses a section (it is stored as a user preference)\r\n     *\r\n     * @param {number} courseId course id\r\n     * @param {string} serverStateKey the current backend course cache reference\r\n     */\r\n    async loadCourse(courseId, serverStateKey) {\r\n\r\n        if (this.courseId) {\r\n            throw new Error(`Cannot load ${courseId}, course already loaded with id ${this.courseId}`);\r\n        }\r\n\r\n        if (!serverStateKey) {\r\n            // The server state key is not provided, we use a invalid statekey to force reloading.\r\n            serverStateKey = `invalidStateKey_${Date.now()}`;\r\n        }\r\n\r\n        // Default view format setup.\r\n        this._editing = false;\r\n        this._supportscomponents = false;\r\n\r\n        this.courseId = courseId;\r\n\r\n        let stateData;\r\n\r\n        const storeStateKey = Storage.get(`course/${courseId}/stateKey`);\r\n        try {\r\n            // Check if the backend state key is the same we have in our session storage.\r\n            if (!this.isEditing && serverStateKey == storeStateKey) {\r\n                stateData = JSON.parse(Storage.get(`course/${courseId}/staticState`));\r\n            }\r\n            if (!stateData) {\r\n                stateData = await this.getServerCourseState();\r\n            }\r\n\r\n        } catch (error) {\r\n            log.error(\"EXCEPTION RAISED WHILE INIT COURSE EDITOR\");\r\n            log.error(error);\r\n            return;\r\n        }\r\n\r\n        this.setInitialState(stateData);\r\n\r\n        // In editing mode, the session cache is considered dirty always.\r\n        if (this.isEditing) {\r\n            this.stateKey = null;\r\n        } else {\r\n            // Check if the last state is the same as the cached one.\r\n            const newState = JSON.stringify(stateData);\r\n            const previousState = Storage.get(`course/${courseId}/staticState`);\r\n            if (previousState !== newState || storeStateKey !== serverStateKey) {\r\n                Storage.set(`course/${courseId}/staticState`, newState);\r\n                Storage.set(`course/${courseId}/stateKey`, stateData?.course?.statekey ?? serverStateKey);\r\n            }\r\n            this.stateKey = Storage.get(`course/${courseId}/stateKey`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the current view settings\r\n     *\r\n     * @param {Object} setup format, page and course settings\r\n     * @param {boolean} setup.editing if the page is in edit mode\r\n     * @param {boolean} setup.supportscomponents if the format supports components for content\r\n     * @param {string} setup.cacherev the backend cached state revision\r\n     */\r\n    setViewFormat(setup) {\r\n        this._editing = setup.editing ?? false;\r\n        this._supportscomponents = setup.supportscomponents ?? false;\r\n    }\r\n\r\n    /**\r\n     * Load the current course state from the server.\r\n     *\r\n     * @returns {Object} the current course state\r\n     */\r\n    async getServerCourseState() {\r\n        const courseState = await ajax.call([{\r\n            methodname: 'core_courseformat_get_state',\r\n            args: {\r\n                courseid: this.courseId,\r\n            }\r\n        }])[0];\r\n\r\n        const stateData = JSON.parse(courseState);\r\n\r\n        return {\r\n            course: {},\r\n            section: [],\r\n            cm: [],\r\n            ...stateData,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Return the current edit mode.\r\n     *\r\n     * Components should use this method to check if edit mode is active.\r\n     *\r\n     * @return {boolean} if edit is enabled\r\n     */\r\n    get isEditing() {\r\n        return this._editing ?? false;\r\n    }\r\n\r\n    /**\r\n     * Return a data exporter to transform state part into mustache contexts.\r\n     *\r\n     * @return {Exporter} the exporter class\r\n     */\r\n    getExporter() {\r\n        return new Exporter(this);\r\n    }\r\n\r\n    /**\r\n     * Return if the current course support components to refresh the content.\r\n     *\r\n     * @returns {boolean} if the current content support components\r\n     */\r\n    get supportComponents() {\r\n        return this._supportscomponents ?? false;\r\n    }\r\n\r\n    /**\r\n     * Get a value from the course editor static storage if any.\r\n     *\r\n     * The course editor static storage uses the sessionStorage to store values from the\r\n     * components. This is used to prevent unnecesary template loadings on every page. However,\r\n     * the storage does not work if no sessionStorage can be used (in debug mode for example),\r\n     * if the page is in editing mode or if the initial state change from the last page.\r\n     *\r\n     * @param {string} key the key to get\r\n     * @return {boolean|string} the storage value or false if cannot be loaded\r\n     */\r\n    getStorageValue(key) {\r\n        if (this.isEditing || !this.stateKey) {\r\n            return false;\r\n        }\r\n        const dataJson = Storage.get(`course/${this.courseId}/${key}`);\r\n        if (!dataJson) {\r\n            return false;\r\n        }\r\n        // Check the stateKey.\r\n        try {\r\n            const data = JSON.parse(dataJson);\r\n            if (data?.stateKey !== this.stateKey) {\r\n                return false;\r\n            }\r\n            return data.value;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores a value into the course editor static storage if available\r\n     *\r\n     * @param {String} key the key to store\r\n     * @param {*} value the value to store (must be compatible with JSON,stringify)\r\n     * @returns {boolean} true if the value is stored\r\n     */\r\n    setStorageValue(key, value) {\r\n        // Values cannot be stored on edit mode.\r\n        if (this.isEditing) {\r\n            return false;\r\n        }\r\n        const data = {\r\n            stateKey: this.stateKey,\r\n            value,\r\n        };\r\n        return Storage.set(`course/${this.courseId}/${key}`, JSON.stringify(data));\r\n    }\r\n\r\n    /**\r\n     * Dispatch a change in the state.\r\n     *\r\n     * Usually reactive modules throw an error directly to the components when something\r\n     * goes wrong. However, course editor can directly display a notification.\r\n     *\r\n     * @method dispatch\r\n     * @param {mixed} args any number of params the mutation needs.\r\n     */\r\n    async dispatch(...args) {\r\n        try {\r\n            await super.dispatch(...args);\r\n        } catch (error) {\r\n            // Display error modal.\r\n            notification.exception(error);\r\n            // Force unlock all elements.\r\n            super.dispatch('unlockAll');\r\n        }\r\n    }\r\n}\r\n"],"names":["Reactive","courseId","serverStateKey","this","Error","stateData","Date","now","_editing","_supportscomponents","storeStateKey","Storage","get","isEditing","JSON","parse","getServerCourseState","error","setInitialState","stateKey","newState","stringify","set","_stateData","course","_stateData$course","statekey","setViewFormat","setup","editing","supportscomponents","courseState","ajax","call","methodname","args","courseid","section","cm","getExporter","Exporter","supportComponents","getStorageValue","key","dataJson","data","value","setStorageValue","super","dispatch","exception"],"mappings":";;;;;;;;;;;g7BAiC6BA,qFAad,wCAQK,oBAgBCC,SAAUC,mBAEnBC,KAAKF,eACC,IAAIG,4BAAqBH,oDAA2CE,KAAKF,eAc/EI,UAXCH,iBAEDA,yCAAoCI,KAAKC,aAIxCC,UAAW,OACXC,qBAAsB,OAEtBR,SAAWA,eAIVS,cAAgBC,QAAQC,qBAAcX,2BAGnCE,KAAKU,WAAaX,gBAAkBQ,gBACrCL,UAAYS,KAAKC,MAAMJ,QAAQC,qBAAcX,4BAE5CI,YACDA,gBAAkBF,KAAKa,wBAG7B,MAAOC,2BACDA,MAAM,+DACNA,MAAMA,eAITC,gBAAgBb,WAGjBF,KAAKU,eACAM,SAAW,SACb,OAEGC,SAAWN,KAAKO,UAAUhB,qEACVM,QAAQC,qBAAcX,4BACtBmB,UAAYV,gBAAkBR,eAChDS,QAAQW,qBAAcrB,yBAAwBmB,UAC9CT,QAAQW,qBAAcrB,uEAAqBI,2DAAAkB,WAAWC,2CAAXC,kBAAmBC,gEAAYxB,qBAEzEiB,SAAWR,QAAQC,qBAAcX,wBAY9C0B,cAAcC,qDACLpB,gCAAWoB,MAAMC,uDACjBpB,kDAAsBmB,MAAME,8GAS3BC,kBAAoBC,cAAKC,KAAK,CAAC,CACjCC,WAAY,8BACZC,KAAM,CACFC,SAAUjC,KAAKF,aAEnB,SAIG,CACHuB,OAAQ,GACRa,QAAS,GACTC,GAAI,MALUxB,KAAKC,MAAMgB,cAiB7BlB,iEACOV,KAAKK,mDAQhB+B,qBACW,IAAIC,kBAASrC,MAQpBsC,uFACOtC,KAAKM,4EAchBiC,gBAAgBC,QACRxC,KAAKU,YAAcV,KAAKgB,gBACjB,QAELyB,SAAWjC,QAAQC,qBAAcT,KAAKF,qBAAY0C,UACnDC,gBACM,YAIDC,KAAO/B,KAAKC,MAAM6B,iBACpBC,MAAAA,YAAAA,KAAM1B,YAAahB,KAAKgB,UAGrB0B,KAAKC,MACd,MAAO7B,cACE,GAWf8B,gBAAgBJ,IAAKG,UAEb3C,KAAKU,iBACE,QAELgC,KAAO,CACT1B,SAAUhB,KAAKgB,SACf2B,MAAAA,cAEGnC,QAAQW,qBAAcnB,KAAKF,qBAAY0C,KAAO7B,KAAKO,UAAUwB,kCAc1DG,MAAMC,uBACd,MAAOhC,6BAEQiC,UAAUjC,aAEjBgC,SAAS"}